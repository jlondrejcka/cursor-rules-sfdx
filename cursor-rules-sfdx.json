{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "cursor-rules-sfdx",
  "type": "registry:file",
  "title": "Prompt rules for Salesforce DX in Cursor IDE",
  "description": "Prompts for working with Salesforce DX projects using Cursor AI-powered IDE tools",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/cursor-rules/distribution/convert_2_shadcn_installable.md",
      "content": "---\ndescription: \nglobs: \nalwaysApply: false\n---\n---\ndescription: Guidelines for converting cursor rules to shadcn-compatible JSON format\nglobs: '.cursor/rules/**/*.mdc'\n---\n\n# Converting Cursor Rules to shadcn-compatible JSON\n\nYou are an expert in converting Cursor Rules to a shadcn-compatible registry format. Follow these guidelines to generate a JSON file that adheres to the shadcn registry schema.\n\n## Implementation\n\nThe conversion is implemented in TypeScript using the script at `scripts/convert-rules-to-shadcn.ts`. The implementation requires:\n\n```json\n{\n  \"dependencies\": {\n    \"yaml\": \"^2.3.4\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.11.19\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n```\n\n## Usage\n\n1. Install dependencies:\n```bash\nnpm install\n```\n\n2. Run the conversion:\n```bash\nnpm run convert\n```\n\nThe script will generate `cursor-rules-sfdx.json` in the project root.\n\n## Output Structure\n\nThe generated JSON file follows this structure:\n\n```json\n{\n  \"$schema\": \"https://ui.shadcn.com/schema/registry-item.json\",\n  \"name\": \"cursor-rules-sfdx\",\n  \"type\": \"registry:file\",\n  \"title\": \"Prompt rules for Salesforce DX in Cursor IDE\",\n  \"description\": \"Prompts for working with Salesforce DX projects using Cursor AI-powered IDE tools\",\n  \"dependencies\": [],\n  \"registryDependencies\": [],\n  \"files\": []\n}\n```\n\n## File Processing\n\nThe script processes files according to these rules:\n\n1. **File Selection**:\n   - Recursively scans `.cursor/rules` directory\n   - Includes all `.mdc` files\n   - Excludes files starting with `@`\n   - Handles nested directories\n\n2. **Path Conversion**:\n   - Original: `.cursor/rules/example.mdc`\n   - Converted: `registry/default/cursor-rules/example.md`\n   - Maintains relative path structure\n   - Preserves directory hierarchy\n\n3. **Content Handling**:\n   - Preserves original file content exactly\n   - Maintains all YAML frontmatter\n   - Keeps markdown formatting intact\n   - Preserves line breaks and special characters\n\n## File Entry Structure\n\nEach cursor rule is converted to this format:\n\n```json\n{\n  \"path\": \"registry/default/cursor-rules/[rule-name].md\",\n  \"content\": \"[original-content]\",\n  \"type\": \"registry:file\",\n  \"target\": \".cursor/rules/[original-file-name]\"\n}\n```\n\n## Error Handling\n\nThe script includes error handling for:\n- File system operations\n- Invalid file contents\n- Processing failures\n- Output writing errors\n\n## Validation\n\nThe script ensures:\n1. All required fields are present\n2. Paths are properly formatted\n3. Content is preserved accurately\n4. Output JSON is valid\n\n## Example Output\n\nFor a file at `.cursor/rules/example.mdc`:\n\nInput:\n```markdown\n---\ndescription: Example rule\nglobs: '**/*.ts'\n---\n\n# Example Rule\nContent here...\n```\n\nGenerated entry in `cursor-rules-sfdx.json`:\n```json\n{\n  \"path\": \"registry/default/cursor-rules/example.md\",\n  \"content\": \"---\\ndescription: Example rule\\nglobs: '**/*.ts'\\n---\\n\\n# Example Rule\\nContent here...\",\n  \"type\": \"registry:file\",\n  \"target\": \".cursor/rules/example.mdc\"\n}\n```\n\n## Limitations\n\n1. File size is limited only by system memory\n2. All files must be valid markdown with frontmatter\n3. File paths must not contain special characters\n4. Target directory must exist and be writable",
      "type": "registry:file",
      "target": ".cursor/rules/distribution/convert_2_shadcn_installable.mdc"
    },
    {
      "path": "registry/default/cursor-rules/general/general_rules.md",
      "content": "---\ndescription: \nglobs: \nalwaysApply: true\n---\nThis is a Salesforce project leveraging the Salesforce CLI. ",
      "type": "registry:file",
      "target": ".cursor/rules/general/general_rules.mdc"
    },
    {
      "path": "registry/default/cursor-rules/general/rule_extraction.md",
      "content": "---\ndescription: Guidelines for extracting rules from Salesforce DX documentation\nglobs: \nalwaysApply: false\n---\n# Rule Extraction Process\n\nBased on a PDF provided by the user, use the structure of the PDF to create/update cursor rules in .mdc format. If the PDF is inaccessible or difficult to extract content from, leverage existing Salesforce DX documentation to create comprehensive rules.\n\n## Rule Repository Structure\nChapters should follow the repo structure in the .cursor/rules/sf_dx as follows:\nChapter 1: -> .cursor/rules/sf_dx/getting_started/\nChapter 2: -> .cursor/rules/sf_dx/dev_hub/\nChapter 3: -> .cursor/rules/sf_dx/project_setup/\nChapter 4: -> .cursor/rules/sf_dx/authorization/\nChapter 5: -> .cursor/rules/sf_dx/metadata_coverage/\nChapter 6: -> .cursor/rules/sf_dx/scratch_orgs/\nChapter 7: -> .cursor/rules/sf_dx/sandboxes/\nChapter 8: -> .cursor/rules/sf_dx/track_changes/\nChapter 9: -> .cursor/rules/sf_dx/work_with_data/\nChapter 10: -> .cursor/rules/sf_dx/development/\nChapter 11: -> .cursor/rules/sf_dx/build_and_release/\nChapter 12: -> .cursor/rules/sf_dx/unlocked_packages/\nChapter 13: -> .cursor/rules/sf_dx/continous_integration/\nChapter 14: -> .cursor/rules/sf_dx/troubleshoot/\nChapter 15: -> .cursor/rules/sf_dx/limiations/\n\n## Rule Files\n1. Create a new rule, or update existing rules, for each sub section in each chapter.\n2. Rules should be in their own file as follows:\n   - File Name: `section_title.mdc` (use snake_case)\n   - Rule type: Agent Requested\n   - Description: brief description on when to use the content of the rule\n   - Rule Body: content of the section in markdown format\n\n## Rule File Structure\nEach rule file should follow this structure:\n\n```markdown\n---\ndescription: Brief description of when to use this rule\nglobs: \nalwaysApply: false\n---\n# Title of the Rule\n\n## Overview\nA concise overview of what this rule covers.\n\n## Key Concepts/Features\n- Important point 1\n- Important point 2\n- Important point 3\n\n## Detailed Sections\n### Section 1\nDetails about section 1\n\n### Section 2\nDetails about section 2\n\n## Code Examples\n```bash\n# Example code\ncommand --flag value\n```\n\n## Best Practices\n1. Best practice 1\n2. Best practice 2\n3. Best practice 3\n\n## Further Reading\nLink to official documentation\n```\n\n## Extraction Approach\n\nWhen extracting rules from a PDF or documentation:\n\n1. **Analyze Chapter Structure**: Identify main sections and subsections in the chapter\n2. **Check Existing Rules**: Review any existing rules in the chapter directory\n3. **Create Rule Files**: For each significant topic, create a dedicated rule file\n4. **Organize Content**: Structure the content with clear headings and sections\n5. **Include Examples**: Add code examples where appropriate\n6. **Add Best Practices**: Include relevant best practices for the topic\n7. **Reference Sources**: Link to official documentation for further reading\n\n## Content Guidelines\n\n1. Use markdown formatting for readability\n2. Include code examples in appropriate code blocks\n3. Structure content with clear hierarchy (headings and subheadings)\n4. Focus on practical guidance over theoretical explanations\n5. Highlight command syntax and parameters\n6. Include common error scenarios and solutions when relevant\n7. Keep content concise but comprehensive\n\n## Example: Chapter 3 (Project Setup)\n\nFor Chapter 3, we created rules for:\n- Creating Salesforce DX Projects\n- Excluding Source When Syncing\n- Project Configuration File\n- Source Format\n- Package Development Setup\n- Environment Config and Variables\n- Source-Driven Development\n\nEach rule follows the structure outlined above and provides practical guidance for Salesforce DX developers. ",
      "type": "registry:file",
      "target": ".cursor/rules/general/rule_extraction.mdc"
    },
    {
      "path": "registry/default/cursor-rules/prompting/prompt_structure.md",
      "content": "---\ndescription: How a prompt should be structured\nglobs: \nalwaysApply: false\n---\nScruture prompts based on the following format:\n1. Goal\n2. Return Format\n3. Warnings\n4. Context\n\nHere is an example: \n\n<goal>\nI Want A Web Scraper That Retrieves Real-Time Stock Prices For A Given List Of Stock Ticker Symbols From A Reliable Financial Data Source.\n\nEach Stock Price Should Be Accurate, Up-To-Date, And Include Key Financial Metrics That Traders Care About.\n</goal>\n\n<return_format>\nFor Each Stock, Return The Ticker Symbol As I'd Find It On A Major Exchange (E.G., NASDAQ, NYSE), Then Provide The Current Stock Price, Percentage Change From The Previous Closing Price, Daily High And Low, Trading Volume, And A Brief Summary Of The Stock's Recent Movement (E.G., Notable Gains/Losses, Trends, Or News Impact).\n\n\nReturn The Top 10 Most Actively Traded Stocks.\n</return_format>\n\n<warnings>\nBe Careful To Ensure That The Stock Data Comes From A Reliable Financial Source, That Prices Are Accurate And Up To Date, And That The Scraper Avoids Detection And Anti-Bot Measures To Prevent Being Blocked.\n</warnings>\n\n<context>\nFor Context: I'm Building A Stock Tracking Tool For Active Traders Who Need Real-Time Updates. We Want To Avoid API Costs, So We're Scraping Data Instead. The Scraper Needs To Be Efficient And Undetectable, While Still Getting Accurate Results.\n</context>",
      "type": "registry:file",
      "target": ".cursor/rules/prompting/prompt_structure.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/auth_info.md",
      "content": "---\ndescription: How to view and manage authorization information for Salesforce orgs\nglobs: \nalwaysApply: false\n---\n# Authorization Information for an Org\n\n## Overview\nManaging authorization information is essential for working with Salesforce DX. This rule explains how to view, understand, and manage the authorization details of your authenticated Salesforce orgs.\n\n## Viewing Organization Authorization Information\n\n### Basic Org Information\nView basic information about an authenticated org:\n\n```bash\n# Display information about a specific org\nsf org display --target-org MyOrgAlias\n```\n\n### Detailed Authorization Information\nView detailed authorization information, including access tokens and refresh tokens:\n\n```bash\n# Display verbose information about a specific org\nsf org display --target-org MyOrgAlias --verbose\n```\n\n### List All Authorized Orgs\nSee all orgs you currently have access to:\n\n```bash\n# List all authenticated orgs\nsf org list\n```\n\n## Understanding Authorization Information\n\n### Key Information Fields\n\nWhen you run `sf org display`, you'll see information such as:\n\n- **Username**: The authenticated user's username\n- **Org ID**: The 18-character Salesforce organization ID\n- **Instance URL**: The URL of the Salesforce instance\n- **Access Token**: (in verbose mode) The OAuth access token\n- **Refresh Token**: (not directly displayed) Used to get new access tokens\n- **Client ID**: The Connected App's consumer key\n- **Connected Status**: Whether the connection is still valid\n- **Alias**: Your locally assigned alias for this org\n\n### Example Output\n```\n=== Org Description\nKey              Value\n───────────────  ────────────────────────────────────────────────────────────────\nAccess Token     00D...\nAlias            DevHub\nClient Id        PlatformCLI\nConnected Status Connected\nId               00D1a000000xxxXXXX\nInstance Url     https://mycompany.my.salesforce.com\nIs Dev Hub       Yes\nOrg Id           00D1a000000xxxXXXAA\nStatus           Active\nUsername         admin@mycompany.com\n```\n\n## Managing Authorization Information\n\n### Setting Default Orgs\nSet a default org for cli commands:\n\n```bash\n# Set default username\nsf config set target-org=MyOrgAlias\n\n# Set default Dev Hub org\nsf config set target-dev-hub=MyDevHubAlias\n```\n\n### Changing Org Aliases\nChange the alias for an authenticated org:\n\n```bash\n# Change org alias\nsf alias set MyNewAlias=username@example.com\n```\n\n### Revoking Authorization\nRemove the authorization when it's no longer needed:\n\n```bash\n# Logout from a specific org\nsf org logout --target-org MyOrgAlias\n\n# Logout from all orgs\nsf org logout --all\n```\n\n## Authorization Storage\n\n### Local Storage Location\nAuthentication information is stored securely in your local environment:\n\n- **MacOS**: Keychain\n- **Windows**: Windows Credential Manager\n- **Linux**: Secret Service API/gnome-keyring/libsecret\n\n### Manual Management\nIn some cases, you may need to manage the auth files directly:\n\n```bash\n# View config location\nsf config list\n\n# Alternative environment variables for auth storage\nexport SF_USE_GENERIC_UNIX_KEYCHAIN=true\nexport SF_DISABLE_ENCRYPTION=true  # Not recommended for production\n```\n\n## Troubleshooting Authorization Issues\n\n### Checking Connection Status\nVerify if your authorization is still valid:\n\n```bash\n# Check status\nsf org display --target-org MyOrgAlias\n```\n\nLook for \"Connected Status: Connected\" in the output.\n\n### Common Auth Problems\n1. **Expired Access Token**: Re-authenticate using the stored refresh token (happens automatically)\n2. **Expired Refresh Token**: You'll need to completely re-authenticate\n3. **Revoked Access**: If access was revoked from Salesforce, you'll need to re-authenticate\n4. **Invalid Alias**: Verify your alias with `sf org list`\n\n### Refreshing Authentication\nIf you're experiencing authorization issues:\n\n```bash\n# Re-authenticate using web flow\nsf org login web --alias MyOrgAlias \n\n# Force token refresh (if supported by auth method)\nsf org refresh --target-org MyOrgAlias\n```\n\n## Security Best Practices\n\n### Protecting Authorization Information\n1. Never share access or refresh tokens\n2. Secure your local machine to protect stored credentials\n3. Use short-lived tokens in CI/CD environments\n4. Implement proper key rotation for JWT-based auth\n5. Avoid using `--verbose` flag in shared environments or scripts\n\n### Regular Maintenance\n1. Periodically review authenticated orgs with `sf org list`\n2. Remove unused authentications with `sf org logout`\n3. Update authentication for long-running integrations regularly\n4. Audit Connected App usage in your Salesforce org\n\n## Further Reading\nFor more information about authorization in Salesforce DX, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_view_info.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/auth_info.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/auth_url_auth.md",
      "content": "---\ndescription: How to use SFDX Auth URL for authentication between environments and in CI/CD pipelines\nglobs: \nalwaysApply: false\n---\n# SFDX Auth URL Authentication\n\n## Overview\nSFDX Auth URL authentication allows you to authenticate to Salesforce orgs using a URL string that contains encoded credentials. This method is particularly useful for transferring authentication between environments or machines, and for setting up automated CI/CD pipelines.\n\n## What is an SFDX Auth URL?\nAn SFDX Auth URL is a specially formatted URL string that contains:\n- The OAuth refresh token\n- The instance URL\n- The login URL\n- The client ID (consumer key)\n- Other authentication details\n\nThe URL follows this format:\n```\nforce://<clientId>:<clientSecret>:<refreshToken>@<instanceUrl>\n```\n\n## Generating an Auth URL\n\n### From an Existing Authenticated Org\n```bash\n# Display org details with auth URL\nsf org display --target-org MyOrg --verbose\n```\n\nLook for the \"Sfdx Auth Url\" in the output.\n\n### Saving the Auth URL to a File\n```bash\n# Save auth URL to a file\nsf org display --target-org MyOrg --verbose --json | jq -r .result.sfdxAuthUrl > authFile.txt\n```\n\n## Using an Auth URL for Authentication\n\n### Command Syntax\n```bash\nsf org login sfdx-url --sfdx-url-file <path/to/file> [--set-default] [--alias <alias>]\n```\n\n### Parameters\n- `--sfdx-url-file`: Path to the file containing the SFDX Auth URL\n- `--sfdx-url`: The actual SFDX Auth URL string (alternative to file)\n- `--set-default`: Set as default username\n- `--alias`: Set an alias for this authenticated org\n\n### Authentication Examples\n\n#### Using a File\n```bash\n# Authenticate using a file\nsf org login sfdx-url --sfdx-url-file ~/authFile.txt --alias MyOrg\n```\n\n#### Using the URL Directly\n```bash\n# Authenticate using the URL string directly\nsf org login sfdx-url --sfdx-url \"force://CLIENT_ID:CLIENT_SECRET:REFRESH_TOKEN@INSTANCE_URL\" --alias MyOrg\n```\n\n## Implementation in CI/CD Environments\n\n### Environment Variables\n```bash\n# Set auth URL as environment variable\nexport SFDX_AUTH_URL=force://CLIENT_ID:CLIENT_SECRET:REFRESH_TOKEN@INSTANCE_URL\n\n# Use environment variable for authentication\nsf org login sfdx-url --sfdx-url $SFDX_AUTH_URL\n```\n\n### GitHub Actions Example\n```yaml\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Authenticate to Salesforce\n        run: |\n          echo ${{ secrets.SFDX_AUTH_URL }} > authFile.txt\n          sf org login sfdx-url --sfdx-url-file authFile.txt\n          rm authFile.txt\n      - name: Deploy Changes\n        run: sf project deploy start\n```\n\n### Circle CI Example\n```yaml\njobs:\n  deploy:\n    docker:\n      - image: salesforce/salesforcedx:latest\n    steps:\n      - checkout\n      - run:\n          name: Authenticate to Salesforce\n          command: |\n            echo $SFDX_AUTH_URL > authFile.txt\n            sf org login sfdx-url --sfdx-url-file authFile.txt\n            rm authFile.txt\n      - run:\n          name: Deploy\n          command: sf project deploy start\n```\n\n## Security Considerations\n\n### Protecting Auth URLs\nAuth URLs contain sensitive information and should be protected:\n1. Never commit auth URLs to version control\n2. Use secret management in CI/CD platforms\n3. Delete auth URL files after use\n4. Limit access to environment variables containing auth URLs\n\n### Revoking Access\nIf an auth URL is compromised:\n1. Revoke the connected app's access in Salesforce\n2. Reset the user's password\n3. Generate new auth URLs if needed\n\n## Troubleshooting\n\n### Common Issues\n1. **Expired Refresh Token**: Auth URLs contain refresh tokens that can expire\n2. **URL Format**: Ensure the URL is correctly formatted\n3. **Special Characters**: URL-encode any special characters in the auth URL\n4. **File Access**: Verify file permissions when using auth URL files\n\n### Error Handling\n```bash\n# Debug auth URL login\nsf org login sfdx-url --sfdx-url-file authFile.txt --loglevel debug\n```\n\n## Best Practices\n1. Regenerate auth URLs periodically for security\n2. Use dedicated integration users with appropriate permissions\n3. Store auth URLs securely using environment variables or secrets managers\n4. Delete auth URL files immediately after use\n5. Consider JWT-based authentication for long-term automated processes\n6. Use different auth URLs for different environments (dev, staging, prod)\n\n## Further Reading\nFor more information about SFDX Auth URL authentication, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_sfdxurl.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/auth_url_auth.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/authorization_concepts.md",
      "content": "---\ndescription: Understanding the key authorization concepts in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Salesforce DX Authorization Concepts\n\n## Overview\nAuthorization in Salesforce DX involves authenticating and connecting to different Salesforce orgs. Understanding the authentication mechanisms and authorization flows is essential for effective Salesforce DX development.\n\n## Key Concepts\n\n### Authentication Methods\n- **Web-Based OAuth Flow**: Interactive browser-based authentication\n- **JWT OAuth Flow**: Non-interactive, server-to-server authentication\n- **Refresh Token Flow**: Uses stored refresh tokens for re-authentication\n- **SFDX Auth URL**: URL format that contains encoded credentials\n\n### Org Types and Authorization\n- **Dev Hub Org**: Production or Developer Edition org that has Dev Hub enabled\n- **Scratch Org**: Short-lived, disposable org for development\n- **Sandbox Org**: Testing and staging environment\n- **Production Org**: Live environment with real data\n\n### Credential Storage\n- Salesforce DX stores encrypted credentials locally\n- Credentials include access tokens, refresh tokens, and instance URLs\n- Default location varies by operating system\n\n## Authorization Commands\n\n### Interactive Web-Based Login\n```bash\n# Login to a production or Developer Edition org\nsf org login web --alias MyOrg\n\n# Login to a sandbox org\nsf org login web --alias MySandbox --instance-url https://test.salesforce.com\n```\n\n### Non-Interactive JWT-Based Login\n```bash\n# Login using JWT flow\nsf org login jwt --username username@example.com --jwt-key-file server.key --client-id your_consumer_key --instance-url https://login.salesforce.com\n```\n\n### List and Manage Authenticated Orgs\n```bash\n# List all authorized orgs\nsf org list\n\n# Display org details\nsf org display --target-org MyOrg\n\n# Set default username for subsequent commands\nsf config set target-org=MyOrg\n```\n\n### Logout and Revoke Access\n```bash\n# Logout from a specific org\nsf org logout --target-org MyOrg\n\n# Logout from all orgs\nsf org logout --all\n```\n\n## Authorization for CI/CD Environments\n\n### Using SFDX Auth URL\n```bash\n# Login using auth URL\nsf org login sfdx-url --sfdx-url-file /path/to/auth-url-file.txt\n```\n\n### Generating Auth URLs\n```bash\n# Generate auth URL for a connected org\nsf org display --target-org MyOrg --verbose\n```\n\n### Environment Variables\n```bash\n# Example of using environment variables\nexport SF_USE_GENERIC_UNIX_KEYCHAIN=true\nexport SFDX_AUDIENCE_URL=https://login.salesforce.com\n```\n\n## Best Practices\n1. Use named aliases for all authenticated orgs\n2. Store credentials securely, especially in CI/CD environments\n3. Implement JWT-based authentication for automated processes\n4. Regularly refresh and rotate credentials\n5. Never hardcode credentials in scripts or configuration files\n6. Use environment variables for sensitive information\n7. For local development, leverage the system keychain for secure storage\n\n## Further Reading\nFor detailed information about authorization in Salesforce DX, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/authorization_concepts.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/create_connected_app.md",
      "content": "---\ndescription: How to create a Connected App in your Salesforce org for API integration and authentication\nglobs: \nalwaysApply: false\n---\n# Create a Connected App in Your Org\n\n## Overview\nA Connected App is required for OAuth-based authentication flows in Salesforce, including JWT-based authentication. It defines how an external application can connect to Salesforce and what data it can access.\n\n## Connected App Configuration Steps\n\n### 1. Navigate to Connected App Setup\n1. Log in to your Salesforce org\n2. Go to Setup\n3. In the Quick Find box, enter \"App Manager\"\n4. Click on \"App Manager\"\n5. Click \"New Connected App\" button in the upper right\n\n### 2. Basic Information\nFill in the required basic information:\n- Connected App Name: A descriptive name (e.g., \"SFDX Integration\")\n- API Name: Will auto-populate based on the Connected App Name\n- Contact Email: Your email address or a team email\n- Description: Purpose of the Connected App (e.g., \"Used for SFDX CLI authentication\")\n\n### 3. API (Enable OAuth Settings)\nConfigure OAuth settings:\n1. Check \"Enable OAuth Settings\"\n2. Callback URL: `http://localhost:1717/OauthRedirect` (for SFDX CLI)\n3. Selected OAuth Scopes:\n   - \"Manage user data via APIs (api)\"\n   - \"Perform requests at any time (refresh_token, offline_access)\"\n   - Add other scopes as needed\n\n### 4. JWT Authentication Settings (for JWT Flow)\nIf using JWT authentication:\n1. Check \"Use digital signatures\"\n2. Upload your certificate file (.crt)\n\n### 5. Save the Connected App\nClick \"Save\" to create the Connected App.\n\n## Important Connected App Values\n\nAfter saving, you'll need these values for authentication:\n- **Consumer Key**: Used as the client ID in authentication commands\n- **Consumer Secret**: Used as the client secret in some authentication flows\n- **Callback URL**: The configured redirect URL\n\nTo view these values after creation:\n1. Go to Setup > App Manager\n2. Find your Connected App\n3. Click the dropdown arrow and select \"View\"\n4. In the \"API (Enable OAuth Settings)\" section, you'll see the Consumer Key and Secret\n\n## Connected App Security Policies\n\n### Configure Policies\nAfter creating the Connected App, you need to set security policies:\n\n1. From Setup > App Manager, find your Connected App\n2. Click the dropdown arrow and select \"Manage\"\n3. Click \"Edit Policies\"\n\n### OAuth Policies\nSet appropriate policies:\n- **Permitted Users**: Choose who can access your app\n  - \"All users may self-authorize\" - Any user can authorize themselves\n  - \"Admin approved users are pre-authorized\" - Only users with proper profile/permission set can access\n\n### IP Relaxation\nChoose an IP relaxation setting:\n- **Enforce IP restrictions**: Users must be in trusted IP ranges\n- **Relax IP restrictions**: IP restrictions are validated but users outside the range can approve access\n- **Relax IP restrictions with second factor**: Requires two-factor authentication for users outside trusted IP ranges\n\n### Refresh Token Policy\nSet refresh token behavior:\n- **Refresh token is valid until revoked**: Tokens never expire (best for long-term automation)\n- **Refresh token expires after X**: Set an expiration period\n\n## Assign Users to the Connected App\n\nIf using \"Admin approved users are pre-authorized\":\n\n1. From Setup > App Manager, find your Connected App\n2. Click the dropdown arrow and select \"Manage\"\n3. Scroll down to \"Profiles\" or \"Permission Sets\" section\n4. Click \"Manage Profiles\" or \"Manage Permission Sets\"\n5. Add appropriate profiles or permission sets\n\n## Testing the Connected App\n\n### Test Web-Based OAuth\n```bash\nsf org login web --instance-url https://login.salesforce.com\n```\n\n### Test JWT-Based OAuth\n```bash\nsf org login jwt --username user@example.com --jwt-key-file server.key --client-id YOUR_CONSUMER_KEY --instance-url https://login.salesforce.com\n```\n\n## Troubleshooting Connected App Issues\n\n### Common Problems\n1. **Invalid client**: Incorrect Consumer Key or Connected App not properly set up\n2. **Invalid redirect_uri**: Callback URL in authentication request doesn't match Connected App\n3. **Authorization failure**: User doesn't have permission to access the Connected App\n4. **Certificate issues**: Certificate not properly uploaded or formatted\n\n### Debugging Steps\n1. Verify the Consumer Key matches what's in the Connected App\n2. Check that your callback URL matches exactly (including http/https)\n3. Ensure the user has been assigned to the Connected App (if using admin approval)\n4. Try authentication with the `--loglevel debug` flag\n\n## Best Practices\n1. Use a meaningful Connected App name that identifies its purpose\n2. Request only the OAuth scopes that your application needs\n3. Implement proper IP restrictions for production Connected Apps\n4. Use a dedicated user for automated processes\n5. Create separate Connected Apps for different environments\n6. Regularly audit Connected App usage and assigned users\n7. Implement session policies appropriate to your security requirements\n\n## Further Reading\nFor more information, see the [Salesforce Connected App Documentation](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_connected_app.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/create_connected_app.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/create_private_key_certificate.md",
      "content": "---\ndescription: How to create a private key and self-signed digital certificate for JWT-based authentication\nglobs: \nalwaysApply: false\n---\n# Create a Private Key and Self-Signed Digital Certificate\n\n## Overview\nJWT-based authentication with Salesforce requires a private key and digital certificate. This rule guides you through the process of creating these security artifacts using OpenSSL.\n\n## Prerequisites\n- OpenSSL installed on your system\n- Appropriate permissions to create files in your working directory\n\n## Generate Private Key and Certificate\n\n### Basic Command Sequence\n```bash\n# Step 1: Generate the private key\nopenssl genrsa -out server.key 2048\n\n# Step 2: Generate a certificate signing request (CSR)\nopenssl req -new -key server.key -out server.csr\n\n# Step 3: Generate a self-signed certificate\nopenssl x509 -req -sha256 -days 365 -in server.csr -signkey server.key -out server.crt\n```\n\n### Detailed Steps\n\n#### 1. Generate the Private Key\n```bash\nopenssl genrsa -out server.key 2048\n```\nThis creates a 2048-bit RSA private key and saves it to `server.key`.\n\n#### 2. Generate a Certificate Signing Request\n```bash\nopenssl req -new -key server.key -out server.csr\n```\nDuring this step, you'll be prompted for information:\n- Country Name (2 letter code)\n- State or Province Name\n- Locality Name (city)\n- Organization Name\n- Organizational Unit Name\n- Common Name (your name or server FQDN)\n- Email Address\n\nYou can press Enter to use defaults for non-critical fields.\n\n#### 3. Generate the Self-Signed Certificate\n```bash\nopenssl x509 -req -sha256 -days 365 -in server.csr -signkey server.key -out server.crt\n```\nThis creates a self-signed certificate valid for 365 days.\n\n## One-Line Command (Non-Interactive)\nFor automated scenarios, use this non-interactive command:\n\n```bash\nopenssl req -new -newkey rsa:2048 -days 365 -nodes -x509 \\\n  -subj \"/C=US/ST=State/L=City/O=Organization/CN=example.com\" \\\n  -keyout server.key -out server.crt\n```\n\n## Certificate Format Requirements\nSalesforce requires:\n- RSA keys with 2048 bits or more\n- The private key in PEM format (begins with `-----BEGIN RSA PRIVATE KEY-----`)\n- The certificate in PEM format (begins with `-----BEGIN CERTIFICATE-----`)\n\n## Using the Certificate\n\n### In Connected App Setup\n1. In your Salesforce org, go to Setup > App Manager > New Connected App\n2. Check \"Enable OAuth Settings\"\n3. Check \"Use digital signatures\"\n4. Click \"Choose File\" and upload your `server.crt` file\n\n### For JWT Authentication\nThe private key file (`server.key`) is used with the JWT authentication command:\n```bash\nsf org login jwt --username user@example.com --jwt-key-file server.key --client-id your_connected_app_consumer_key\n```\n\n## Security Best Practices\n\n1. **Protect Your Private Key**\n   - Never share your private key\n   - Don't commit it to version control\n   - Store it securely in a secrets manager or encrypted storage\n\n2. **Certificate Management**\n   - Set a calendar reminder to renew certificates before expiration\n   - Keep track of where certificates are used\n   - Implement a rotation strategy for keys and certificates\n\n3. **For Production Use**\n   - Consider using a properly signed certificate from a Certificate Authority for production\n   - Use hardware security modules (HSMs) for critical environments\n\n## Troubleshooting\n\n### Common Issues\n1. **Permission Denied**: Ensure you have write permissions in the directory\n2. **OpenSSL Not Found**: Install OpenSSL or ensure it's in your PATH\n3. **Invalid Key Format**: Ensure the key is in PEM format with proper headers/footers\n\n### Verifying Your Certificate\n```bash\n# Verify the private key\nopenssl rsa -check -in server.key\n\n# View certificate information\nopenssl x509 -text -noout -in server.crt\n```\n\n## Further Reading\nFor more information about certificates and JWT-based authentication, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_key_and_cert.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/create_private_key_certificate.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/default_connected_app.md",
      "content": "---\ndescription: How to use the default Connected App security in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Use the Default Connected App Security\n\n## Overview\nSalesforce DX provides a default Connected App for authentication that simplifies the process for developers. Understanding how this default Connected App works and its security implications is important for effective development with Salesforce DX.\n\n## Default Connected App Details\n\n### What is the Default Connected App?\nThe default Connected App is a pre-configured Connected App that ships with the Salesforce CLI. It is used automatically when you authenticate using the web-based flow without specifying a client ID.\n\n### Key Characteristics\n- Pre-configured OAuth settings\n- Standard callback URL\n- Predefined OAuth scopes\n- Managed by Salesforce\n\n## Using the Default Connected App\n\n### Web-Based Authentication\nWhen you use the basic web authentication command without specifying a client ID, the default Connected App is used:\n\n```bash\n# Uses the default Connected App\nsf org login web --alias MyOrg\n```\n\n### Viewing Default Connected App Details\nWhile you can't directly view all details of the default Connected App, you can see the authorization details after authenticating:\n\n```bash\n# Display details of the authenticated org\nsf org display --target-org MyOrg --verbose\n```\n\n## Default Connected App Security Considerations\n\n### Security Model\nThe default Connected App follows these security principles:\n- Uses standard OAuth 2.0 authorization code flow\n- Stores refresh tokens securely in your local keychain\n- Implements standard token rotation policies\n- Adheres to Salesforce platform security standards\n\n### Limitations and Constraints\n- Cannot be used for JWT-based authentication\n- Cannot modify the OAuth scopes or policies\n- Relies on web-based user interaction (not suitable for headless scenarios)\n- Subject to standard Salesforce session timeout policies\n\n## When to Use Custom Connected Apps Instead\n\n### Scenarios Requiring Custom Connected Apps\nConsider creating your own Connected App when you need to:\n1. Implement JWT-based authentication\n2. Customize OAuth scopes\n3. Set specific security policies\n4. Use custom certificate-based authentication\n5. Implement IP restrictions\n6. Control token lifetimes\n7. Track API usage by application\n\n### Command With Custom Connected App\nWhen using a custom Connected App, include the client ID:\n\n```bash\n# Uses a custom Connected App\nsf org login web --client-id YOUR_CONSUMER_KEY --alias MyOrg\n```\n\n## Revoking Access for Default Connected App\n\n### From Salesforce UI\n1. Log in to your Salesforce org\n2. Navigate to Setup > Connected Apps OAuth Usage\n3. Find \"Salesforce CLI\" or \"SFDX CLI\" in the list\n4. Click \"Revoke\" to revoke all refresh tokens\n\n### From CLI\n```bash\n# Logout from a specific org\nsf org logout --target-org MyOrg\n\n# Logout from all orgs\nsf org logout --all\n```\n\n## Best Practices\n\n### For Development and Personal Use\n1. The default Connected App is suitable for individual developer activities\n2. Secure your device to protect stored tokens\n3. Log out when working on shared computers\n4. Regularly review and clean up authenticated orgs\n\n### For Team and Enterprise Use\n1. Create dedicated Connected Apps for team/project use\n2. Implement appropriate security policies on custom Connected Apps\n3. Use JWT-based authentication for CI/CD and automation\n4. Track and audit Connected App usage\n\n### For Production Deployments\n1. Never use the default Connected App for production deployments\n2. Create a dedicated Connected App with appropriate security policies\n3. Assign proper user permissions and profiles\n4. Implement strict IP restrictions\n\n## Troubleshooting\n\n### Common Issues\n1. **Authorization Errors**: Could be due to user permissions or security settings\n2. **Invalid Session ID**: Token expired and needs re-authentication\n3. **Access Denied**: User doesn't have proper permissions or IP restrictions are enforced\n\n### Resolution Steps\n1. Re-authenticate using `sf org login web`\n2. Verify network connectivity and proxy settings\n3. Check user permissions in Salesforce\n\n## Further Reading\nFor more information about Connected Apps and authentication, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/default_connected_app.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/existing_access_token.md",
      "content": "---\ndescription: How to use an existing access token for Salesforce DX authentication\nglobs: \nalwaysApply: false\n---\n# Use an Existing Access Token\n\n## Overview\nIn some scenarios, you may already have a valid Salesforce access token that you want to use with Salesforce DX. This approach allows you to authenticate without going through the web-based or JWT-based flows again.\n\n## What is an Access Token?\nAn access token is a security credential that allows you to make authorized API calls to Salesforce. It's a string that:\n- Is obtained through OAuth authentication\n- Has a limited lifetime (typically 2 hours)\n- Represents a specific user's access permissions\n- Can be used with the Salesforce REST, SOAP, and other APIs\n\n## Using an Existing Access Token\n\n### Command Syntax\n```bash\nsf org login access-token --instance-url <instance_url> --alias <alias> [--set-default]\n```\n\n### Parameters\n- `--instance-url`: The Salesforce instance URL (e.g., https://yourInstance.my.salesforce.com)\n- `--alias`: An alias to identify this authenticated org\n- `--set-default`: Sets this as the default org for future commands\n- `--no-prompt`: Bypass prompt for access token input\n\n### Interactive Example\n```bash\n# Interactive method (will prompt for access token)\nsf org login access-token --instance-url https://yourInstance.my.salesforce.com --alias MyOrg\n```\n\n### Non-Interactive Example\n```bash\n# Non-interactive method (using command line pipe)\necho \"00D...your_access_token\" | sf org login access-token --instance-url https://yourInstance.my.salesforce.com --alias MyOrg --no-prompt\n```\n\n## Scenarios for Using Access Tokens\n\n### Integration with External Systems\nWhen you have an authentication system that already obtains Salesforce access tokens:\n```bash\n# Script example\nACCESS_TOKEN=$(get-token-from-external-system)\necho $ACCESS_TOKEN | sf org login access-token --instance-url $INSTANCE_URL --alias ExternalAuth --no-prompt\n```\n\n### Custom Authentication Flows\nWhen you've implemented a custom OAuth flow that obtains access tokens:\n```bash\n# Example script using curl to get token and then use it\nTOKEN_RESPONSE=$(curl -s -d \"grant_type=password&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET&username=$USERNAME&password=$PASSWORD\" https://login.salesforce.com/services/oauth2/token)\nACCESS_TOKEN=$(echo $TOKEN_RESPONSE | jq -r .access_token)\nINSTANCE_URL=$(echo $TOKEN_RESPONSE | jq -r .instance_url)\n\necho $ACCESS_TOKEN | sf org login access-token --instance-url $INSTANCE_URL --alias CustomAuth --no-prompt\n```\n\n### Sharing Authentication Context\nWhen another team member or system has provided you with a valid access token:\n```bash\n# Store token securely first\necho $ACCESS_TOKEN > token.txt\nsf org login access-token --instance-url https://yourInstance.my.salesforce.com --alias SharedToken\n# Immediately delete the token file\nrm token.txt\n```\n\n## Limitations of Access Token Authentication\n\n### Short Lifespan\n- Access tokens typically expire after 2 hours\n- No refresh token is stored, so you can't automatically re-authenticate\n- You need to obtain a new access token when the current one expires\n\n### Limited Operations\nWithout a refresh token:\n- Long-running operations might fail if the token expires\n- You'll need to re-authenticate more frequently\n- Some CLI commands that require a refresh token won't work\n\n### Security Considerations\n- Access tokens provide immediate access to your org\n- They should be treated as sensitive credentials\n- They are transmitted in plain text when used with this command\n\n## Best Practices\n\n### Secure Handling of Access Tokens\n1. Never store access tokens in version control\n2. Transmit access tokens only through secure channels\n3. Delete access tokens when no longer needed\n4. Use environment variables for temporary storage\n\n### Workflow Suggestions\n1. For short-term operations, access token authentication is convenient\n2. For development work, prefer web-based or JWT-based authentication\n3. For CI/CD pipelines, prefer JWT-based authentication\n4. For automated processes, implement proper token refresh mechanisms\n\n### Alternate Approaches\nFor most scenarios, consider these alternatives:\n- Web-based authentication: `sf org login web`\n- JWT-based authentication: `sf org login jwt`\n- SFDX Auth URL: `sf org login sfdx-url`\n\n## Further Reading\nFor more information about authentication methods, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_access_token.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/existing_access_token.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/jwt_based_auth.md",
      "content": "---\ndescription: How to use JWT-based OAuth flow for automated and headless authentication\nglobs: \nalwaysApply: false\n---\n# JWT-Based Authentication in Salesforce DX\n\n## Overview\nJWT-based authentication provides a secure way to authenticate to Salesforce orgs in non-interactive or automated scenarios, such as CI/CD pipelines. It uses a JWT (JSON Web Token) and a private key for authentication without user interaction.\n\n## Prerequisites\n\n### 1. Create a Connected App\n1. In your Salesforce org, go to Setup > App Manager > New Connected App\n2. Configure the Connected App:\n   - Enable OAuth Settings\n   - Set Callback URL (e.g., `http://localhost:1717/OauthRedirect`)\n   - Select \"Use digital signatures\" and upload a certificate\n   - Add \"Manage user data via APIs\" to Selected OAuth Scopes\n\n### 2. Generate Certificate and Private Key\n```bash\n# Generate private key\nopenssl genrsa -out server.key 2048\n\n# Generate certificate signing request\nopenssl req -new -key server.key -out server.csr\n\n# Generate self-signed certificate\nopenssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt\n```\n\n### 3. Configure Connected App Policies\n1. In your Connected App settings, set appropriate policies:\n   - Permitted Users: \"Admin approved users are pre-authorized\"\n2. Manage Profiles and Permission Sets to authorize appropriate users\n\n## JWT Authentication Command\n\n### Basic Syntax\n```bash\nsf org login jwt --username <username> --jwt-key-file <path/to/server.key> --client-id <connected_app_consumer_key> [--instance-url <url>] [--set-default] [--alias <alias>]\n```\n\n### Parameters\n- `--username`: The username of the Salesforce user\n- `--jwt-key-file`: Path to the private key file\n- `--client-id`: Consumer Key from the Connected App\n- `--instance-url`: Login URL (default is https://login.salesforce.com)\n- `--set-default`: Set as default username\n- `--alias`: Set an alias for this authenticated org\n\n## Authentication Examples\n\n### Production Org\n```bash\nsf org login jwt --username user@example.com --jwt-key-file server.key --client-id 1234567890abcdef --alias ProdOrg\n```\n\n### Sandbox Org\n```bash\nsf org login jwt --username user@example.com.sandbox --jwt-key-file server.key --client-id 1234567890abcdef --instance-url https://test.salesforce.com --alias SandboxOrg\n```\n\n## Implementation in CI/CD\n\n### CircleCI Example\n```yaml\njobs:\n  deploy:\n    docker:\n      - image: salesforce/salesforcedx:latest\n    steps:\n      - checkout\n      - run:\n          name: Setup Salesforce Authentication\n          command: |\n            echo \"$SERVER_KEY\" > server.key\n            sf org login jwt --username $SF_USERNAME --jwt-key-file server.key --client-id $CLIENT_ID --instance-url $INSTANCE_URL\n      - run:\n          name: Deploy to Org\n          command: sf project deploy start\n```\n\n### GitHub Actions Example\n```yaml\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Install Salesforce CLI\n        run: npm install @salesforce/cli --global\n      - name: Authenticate to Salesforce\n        run: |\n          echo \"${{ secrets.SERVER_KEY }}\" > server.key\n          sf org login jwt --username ${{ secrets.SF_USERNAME }} --jwt-key-file server.key --client-id ${{ secrets.CLIENT_ID }}\n      - name: Deploy Changes\n        run: sf project deploy start\n```\n\n## Troubleshooting\n\n### Common Issues\n1. **Invalid Key Format**: Ensure the private key is in PEM format and includes header/footer\n2. **Consumer Key Issues**: Verify the Connected App's consumer key is correct\n3. **User Authorization**: Check that the user is pre-authorized for the Connected App\n4. **IP Restrictions**: Verify IP restrictions on the profile or Connected App allow access\n\n### Debugging\n```bash\n# Run with debug logging\nsf org login jwt --username user@example.com --jwt-key-file server.key --client-id 1234567890abcdef --loglevel debug\n```\n\n## Security Best Practices\n1. Store private keys securely (use secret management in CI/CD)\n2. Rotate certificates and keys regularly\n3. Use IP restrictions on Connected Apps when possible\n4. Create dedicated integration users with minimum required permissions\n5. Avoid committing keys or credentials to source control\n6. Use environment variables for sensitive information\n\n## Further Reading\nFor detailed information on JWT-based authentication, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_jwt_flow.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/jwt_based_auth.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/logout.md",
      "content": "---\ndescription: How to log out and remove authentication from Salesforce orgs\nglobs: \nalwaysApply: false\n---\n# Log Out of an Org\n\n## Overview\nLogging out from Salesforce orgs is an important security practice when you no longer need access or when you're working on shared computers. This rule explains how to properly log out from Salesforce orgs using the Salesforce CLI.\n\n## Logging Out Commands\n\n### Log Out from a Specific Org\nTo log out from a specific Salesforce org:\n\n```bash\n# Log out using the org alias\nsf org logout --target-org MyOrgAlias\n\n# Log out using the username\nsf org logout --target-org username@example.com\n```\n\n### Log Out from All Orgs\nTo log out from all authenticated Salesforce orgs:\n\n```bash\n# Log out from all authenticated orgs\nsf org logout --all\n```\n\n## What Happens During Logout\n\n### Local Effects\n- Removes the authentication credentials from your local secure storage\n- Deletes the access and refresh tokens\n- Removes the org from your list of authenticated orgs\n\n### Remote Effects\n- Revokes the OAuth refresh token on the Salesforce server\n- Prevents the issuance of new access tokens with the revoked refresh token\n- Terminates the authorization granted to the connected app\n\n## Verifying Logout\n\n### Check Authenticated Orgs\nVerify that the org is no longer listed in your authenticated orgs:\n\n```bash\n# List all authenticated orgs\nsf org list\n```\n\n### Check Specific Org Status\nAttempting to access a logged-out org will result in an error:\n\n```bash\n# Attempt to display org info (will fail if logged out)\nsf org display --target-org MyOrgAlias\n```\n\n## Scenarios for Logout\n\n### Security and Maintenance\n- When you finish working with an org\n- When working on shared or public computers\n- When a project is completed\n- As part of regular security maintenance\n\n### Troubleshooting\n- When you encounter authentication issues\n- When you need to reset the authentication context\n- When switching between different users in the same org\n\n### Team and Environment Changes\n- When team members change roles\n- When rotating access credentials\n- When migrating between environments\n\n## Best Practices\n\n### Regular Cleanup\n```bash\n# View all authenticated orgs\nsf org list\n\n# Log out from unused orgs\nsf org logout --target-org UnusedOrg1\nsf org logout --target-org UnusedOrg2\n```\n\n### In Scripts and Automation\nInclude logout commands in your scripts after completing operations:\n\n```bash\n#!/bin/bash\n# Authenticate\nsf org login jwt --username user@example.com --jwt-key-file server.key --client-id $CLIENT_ID --alias TempOrg\n\n# Perform operations\nsf project deploy start --target-org TempOrg\n\n# Log out when done\nsf org logout --target-org TempOrg\n```\n\n### Shared Computers\nAlways log out after each session on shared computers:\n\n```bash\n# Log out from all orgs at the end of your session\nsf org logout --all\n```\n\n## Troubleshooting Logout Issues\n\n### Common Problems\n1. **Command Failed**: Verify the org alias or username is correct\n2. **Unable to Revoke Token**: Network or server issues may prevent proper revocation\n3. **Org Still Listed**: Refresh your org list or restart the CLI\n\n### Force Logout\nIn case of persistent issues, force removal of credentials:\n\n```bash\n# Force logout (will remove local credentials even if server revocation fails)\nsf org logout --target-org MyOrgAlias --no-prompt\n```\n\n### Manual Cleanup\nIn extreme cases, you may need to manually clean up:\n\n1. **MacOS**: Use Keychain Access to remove Salesforce entries\n2. **Windows**: Use Credential Manager to remove Salesforce entries\n3. **Linux**: Use your keyring manager to remove Salesforce entries\n\n## Re-authenticating After Logout\nAfter logging out, you'll need to authenticate again to access the org:\n\n```bash\n# Web-based authentication\nsf org login web --alias MyOrgAlias\n\n# JWT-based authentication\nsf org login jwt --username user@example.com --jwt-key-file server.key --client-id $CLIENT_ID --alias MyOrgAlias\n```\n\n## Further Reading\nFor more information about authentication and logout, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_logout.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/logout.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/managing_auth_environments.md",
      "content": "---\ndescription: Best practices for managing authentication across different Salesforce environments\nglobs: \nalwaysApply: false\n---\n# Managing Authentication Across Environments\n\n## Overview\nWhen working with Salesforce DX, developers often need to authenticate to multiple orgs across different environments (development, testing, staging, production). This rule provides best practices for managing these authentication contexts effectively.\n\n## Environment Types\n\n### Development Environments\n- Developer sandboxes\n- Scratch orgs\n- Developer Edition orgs\n- Personal dev environments\n\n### Testing and Staging Environments\n- UAT sandboxes\n- Integration testing environments\n- Partial/Full copy sandboxes\n- Staging environments\n\n### Production Environments\n- Production orgs\n- Release orgs\n\n## Authentication Strategies by Environment\n\n### Local Development\n```bash\n# Create aliases for different environments\nsf org login web --alias DevSandbox --instance-url https://test.salesforce.com\nsf org login web --alias Scratch1 --set-default\nsf org login web --alias Scratch2\n\n# Switch between environments\nsf config set target-org=DevSandbox\n```\n\n### CI/CD Pipelines\n```bash\n# JWT-based auth for automated processes\nsf org login jwt --username ciuser@example.com --jwt-key-file server.key --client-id $CLIENT_ID --alias CIOrg\n\n# Auth URL for simpler setups\nsf org login sfdx-url --sfdx-url $SFDX_AUTH_URL --alias CIOrg\n```\n\n### Production Deployments\n```bash\n# Authenticate to production for deployment\nsf org login web --alias Production --instance-url https://login.salesforce.com\nsf project deploy validate --target-org Production\nsf project deploy start --target-org Production\n```\n\n## Managing Multiple Authentication Contexts\n\n### Listing and Viewing Orgs\n```bash\n# List all authenticated orgs\nsf org list\n\n# List org details\nsf org display --target-org MyOrg\n\n# List all default settings\nsf config list\n```\n\n### Setting Default Orgs\n```bash\n# Set default username\nsf config set target-org=MyOrg\n\n# Set default DevHub org\nsf config set target-dev-hub=MyDevHub\n```\n\n### Removing Authentication\n```bash\n# Logout from specific org\nsf org logout --target-org MyOrg\n\n# Logout from all orgs\nsf org logout --all\n```\n\n## Project-Specific Configuration\n\n### Using Configuration Files\nCreate a `.sf/config.json` file in your project to set project-specific defaults:\n\n```json\n{\n  \"target-org\": \"MyProjectOrg\",\n  \"target-dev-hub\": \"MyDevHub\",\n  \"org-api-version\": \"58.0\"\n}\n```\n\n### Environment Variables\nSet environment variables for different contexts:\n\n```bash\n# Development environment\nexport SF_TARGET_ORG=DevSandbox\n\n# Testing environment\nexport SF_TARGET_ORG=TestSandbox\n\n# Production environment\nexport SF_TARGET_ORG=Production\n```\n\n## Authentication in Team Environments\n\n### Team Development Workflow\n1. Each developer authenticates to their own environments\n2. Shared integration environments use dedicated service accounts\n3. CI/CD uses JWT-based authentication with dedicated users\n4. Production access is limited to release managers\n\n### Sharing Authentication Context (When Needed)\n```bash\n# Generate auth URL (Only share through secure channels!)\nsf org display --target-org MyOrg --verbose\n\n# Use auth URL on other machine\nsf org login sfdx-url --sfdx-url \"force://...\" --alias SharedOrg\n```\n\n## Security Best Practices\n\n### Authentication Hygiene\n1. Regularly review and clean up authenticated orgs\n2. Use different users for different environments\n3. Implement MFA for all Salesforce users\n4. Rotate secrets and certificates regularly\n\n### Credential Management\n1. Use system keychain for local development\n2. Use secret management for CI/CD (GitHub Secrets, Jenkins Credentials, etc.)\n3. Never store credentials in version control\n4. Use environment variables for sensitive information\n\n### Permissions and Access\n1. Use principle of least privilege for integration users\n2. Create permission sets specifically for API/integration access\n3. Implement IP restrictions for API access when possible\n4. Audit API access regularly\n\n## Troubleshooting Authentication Issues\n\n### Common Issues\n1. **Session Expiration**: Re-authenticate if session has expired\n2. **Invalid Credentials**: Verify username, password, and security token\n3. **IP Restrictions**: Check for IP restrictions on profile or Connected App\n4. **API Permissions**: Ensure user has API access enabled\n\n### Debugging Tools\n```bash\n# Enable debug logging\nsf org login web --loglevel debug\n\n# Check current auth status\nsf org display --target-org MyOrg --verbose\n```\n\n## Further Reading\nFor detailed information about Salesforce DX authentication, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/managing_auth_environments.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/scratch_org_jwt_auth.md",
      "content": "---\ndescription: How to authorize a Scratch Org using the JWT-based OAuth flow\nglobs: \nalwaysApply: false\n---\n# Authorize a Scratch Org Using the JWT Flow\n\n## Overview\nScratch orgs can be authorized using the JWT-based OAuth flow, which is particularly useful for automated processes and CI/CD pipelines. This approach allows for non-interactive authentication to scratch orgs.\n\n## Prerequisites\n\nBefore authorizing a scratch org with JWT flow, ensure you have:\n1. A Dev Hub org that's already authenticated\n2. A private key and certificate for JWT authentication\n3. A Connected App configured in your Dev Hub org\n4. The username of the scratch org you want to authenticate to\n\n## Scratch Org JWT Authorization Process\n\n### 1. Create a Scratch Org\nFirst, create a scratch org if you don't already have one:\n\n```bash\n# Create a scratch org using your Dev Hub\nsf org create scratch --target-dev-hub MyDevHub --definition-file config/project-scratch-def.json --set-default --alias MyScratchOrg\n```\n\n### 2. Get the Scratch Org Username\nRetrieve the username of your scratch org:\n\n```bash\n# Display scratch org information\nsf org display --target-org MyScratchOrg\n\n# The output will include the username (typically ends with @example.com)\n```\n\nNote the username, which will look something like `test-xyzabc@example.com`.\n\n### 3. Authenticate Using JWT Flow\nUse the JWT-based authentication command with the scratch org username:\n\n```bash\n# JWT authentication to scratch org\nsf org login jwt --username test-xyzabc@example.com --jwt-key-file server.key --client-id YOUR_CONNECTED_APP_CONSUMER_KEY --instance-url https://test.salesforce.com --alias MyScratchOrg\n```\n\n## Key Parameters for Scratch Org JWT Authentication\n\n- `--username`: The full username of the scratch org user\n- `--jwt-key-file`: Path to your private key file\n- `--client-id`: Consumer Key from your Connected App in the Dev Hub\n- `--instance-url`: For scratch orgs, typically https://test.salesforce.com\n- `--alias`: A local alias to refer to this scratch org\n\n## Use Cases for JWT Authentication with Scratch Orgs\n\n### CI/CD Pipeline Integration\nAuthenticate to scratch orgs in automated build processes:\n\n```yaml\n# Example GitHub Actions workflow step\n- name: Authenticate to Scratch Org\n  run: |\n    echo \"${{ secrets.SERVER_KEY }}\" > server.key\n    sf org login jwt --username $SCRATCH_ORG_USERNAME --jwt-key-file server.key --client-id ${{ secrets.CLIENT_ID }} --instance-url https://test.salesforce.com\n```\n\n### Automated Testing\nSet up authentication for automated test suites:\n\n```bash\n#!/bin/bash\n# Create scratch org\nsf org create scratch --target-dev-hub DevHub --definition-file config/test-scratch-def.json --alias TestOrg\n\n# Get username\nSCRATCH_USERNAME=$(sf org display --target-org TestOrg --json | jq -r .result.username)\n\n# JWT auth for scripts\nsf org login jwt --username $SCRATCH_USERNAME --jwt-key-file server.key --client-id $CLIENT_ID --instance-url https://test.salesforce.com --alias TestOrg\n\n# Run tests\nsf apex run test --target-org TestOrg\n```\n\n### Multiple Scratch Org Management\nWhen working with multiple scratch orgs in different contexts:\n\n```bash\n# For each scratch org, authenticate using JWT\nfor org in $(sf org list scratch --json | jq -r '.scratchOrgs[].username'); do\n  sf org login jwt --username $org --jwt-key-file server.key --client-id $CLIENT_ID --instance-url https://test.salesforce.com\ndone\n```\n\n## Special Considerations for Scratch Orgs\n\n### Authentication Lifecycle\n- Scratch orgs have a limited lifespan (typically 1-30 days)\n- JWT authentication will fail after the scratch org expires\n- The connected app in the Dev Hub must have appropriate permissions\n\n### User Provisioning\n- The admin user is automatically created when the scratch org is created\n- This user has a username that ends with @example.com\n- The Connected App must be configured to allow this user to authenticate\n\n### Instance URL\n- Scratch orgs use different instances, but you can typically use https://test.salesforce.com\n- For more specific control, use the exact instance URL from `sf org display`\n\n## Troubleshooting JWT Authentication with Scratch Orgs\n\n### Common Issues\n1. **Invalid User**: Verify the scratch org username is correct and the org hasn't expired\n2. **Connected App Issues**: Ensure your Connected App in Dev Hub is properly configured\n3. **Permission Problems**: Check that the Connected App has proper OAuth scopes\n4. **Certificate Mismatch**: Verify the certificate in the Connected App matches your private key\n\n### Debugging Steps\n```bash\n# Check scratch org status\nsf org list scratch\n\n# Get detailed info\nsf org display --target-org MyScratchOrg --verbose\n\n# Attempt JWT auth with debug logging\nsf org login jwt --username test-xyz@example.com --jwt-key-file server.key --client-id YOUR_CONSUMER_KEY --instance-url https://test.salesforce.com --loglevel debug\n```\n\n## Best Practices\n\n1. Create a dedicated Connected App in your Dev Hub for scratch org JWT authentication\n2. Use descriptive aliases for scratch orgs to keep track of their purpose\n3. In CI/CD, ensure scratch orgs are created with sufficient duration for your processes\n4. Clean up expired scratch orgs regularly\n5. Store JWK keys securely, especially in automation environments\n6. Consider using different Connected Apps for different environments/purposes\n\n## Further Reading\nFor more information about JWT-based authentication with scratch orgs, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_jwt_flow.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/scratch_org_jwt_auth.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/authorization/web_based_auth.md",
      "content": "---\ndescription: How to authenticate to Salesforce orgs using the web-based OAuth flow\nglobs: \nalwaysApply: false\n---\n# Web-Based Authentication in Salesforce DX\n\n## Overview\nWeb-based authentication is the most common and user-friendly method for authenticating to Salesforce orgs. It uses the OAuth 2.0 web server flow to authenticate a user through their web browser.\n\n## How It Works\n1. The CLI opens a browser window to Salesforce login page\n2. User enters credentials and approves access\n3. Salesforce issues an access token and refresh token\n4. The CLI securely stores these tokens locally\n5. Tokens are used for subsequent API calls\n\n## Command Syntax\n\n### Basic Authentication\n```bash\nsf org login web [--set-default] [--alias <alias>] [--instance-url <url>]\n```\n\n### Common Parameters\n- `--set-default`: Sets the authenticated org as the default for future commands\n- `--alias <alias>`: Assigns a name to the authenticated org for future reference\n- `--instance-url <url>`: Specifies the login URL (e.g., https://test.salesforce.com for sandboxes)\n\n## Authentication Examples\n\n### Production or Developer Edition Org\n```bash\n# Basic authentication\nsf org login web\n\n# With alias and set as default\nsf org login web --set-default --alias DevOrg\n```\n\n### Sandbox Org\n```bash\n# Authenticate to a sandbox\nsf org login web --instance-url https://test.salesforce.com --alias MySandbox\n```\n\n### Custom Domain\n```bash\n# Authenticate to org with custom domain\nsf org login web --instance-url https://mycustomdomain.my.salesforce.com --alias CustomDomain\n```\n\n## Managing Web-Based Authentications\n\n### List Authenticated Orgs\n```bash\nsf org list\n```\n\n### Display Org Details\n```bash\nsf org display --target-org MyOrgAlias\n```\n\n### Set Default Username\n```bash\nsf config set target-org=MyOrgAlias\n```\n\n### Revoking Access\n```bash\n# Logout from a specific org\nsf org logout --target-org MyOrgAlias\n\n# Logout from all orgs\nsf org logout --all\n```\n\n## Troubleshooting\n\n### Common Issues\n1. **Session Timeout**: If you encounter \"Session expired or invalid\" errors, re-authenticate\n2. **Browser Issues**: If browser doesn't open automatically, use the URL displayed in the terminal\n3. **Permission Issues**: Ensure your user has appropriate API permissions in the org\n\n### Error Handling\n```bash\n# Force login refresh\nsf org login web --instance-url https://login.salesforce.com --alias MyOrg --no-prompt\n```\n\n## Security Considerations\n1. Tokens are stored securely in your local system keychain\n2. Never share credential files between machines or users\n3. Avoid using shared computers for authentication when possible\n4. Set reasonable session timeout policies in your Salesforce org\n\n## Best Practices\n1. Use meaningful aliases for different orgs\n2. Create separate authentications for each project\n3. Regularly verify your authenticated orgs with `sf org list`\n4. Log out from unused or unnecessary org connections\n5. For automated processes, consider using JWT-based authentication instead\n\n## Further Reading\nFor more details on web-based authentication, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_web_flow.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/authorization/web_based_auth.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/build_and_release/build_release_with_metadata_api.md",
      "content": "---\ndescription: How to build and release your Salesforce app using the Metadata API\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to build and release your Salesforce app using the Metadata API\nglobs: \nalwaysApply: false\n---\n# Build and Release Your App with Metadata API\n\n## Overview\nThe Metadata API provides a comprehensive way to build and release Salesforce applications through a structured deployment process.\n\n## Key Concepts\n- Metadata API is the foundation for deploying changes between Salesforce orgs\n- The deployment process follows a defined workflow: development, testing, staging, and production\n- Salesforce CLI provides commands to interact with the Metadata API\n\n## Detailed Guide\n### Understanding the Deployment Process\nThe complete deployment process typically includes:\n1. Developing and testing changes locally\n2. Building a release artifact\n3. Testing the artifact in a staging environment\n4. Releasing to production\n\n### Using Metadata API for Deployments\nThe Metadata API allows you to:\n- Deploy metadata components between orgs\n- Validate deployments without committing changes\n- Roll back failed deployments\n- Monitor deployment status\n\n## Code Examples\n```bash\n# Deploy metadata to an org\nsf project deploy start --source-dir force-app\n\n# Validate a deployment without making changes\nsf project deploy start --source-dir force-app --check-only\n\n# Deploy with specified test level\nsf project deploy start --source-dir force-app --test-level RunLocalTests\n```\n\n## Best Practices\n1. Always validate deployments before committing to production\n2. Use appropriate test levels for different deployment scenarios\n3. Monitor deployment status through the CLI or Salesforce Setup\n4. Maintain detailed release notes for each deployment\n\n## Further Reading\n- [Salesforce Metadata API Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_intro.htm)\n- [Salesforce CLI Deployment Commands](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_force_mdapi.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/build_and_release/build_release_with_metadata_api.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/build_and_release/build_test_release_artifact.md",
      "content": "---\ndescription: How to build and test a release artifact for Salesforce deployments\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to build and test a release artifact for Salesforce deployments\nglobs: \nalwaysApply: false\n---\n# Build and Test the Release Artifact\n\n## Overview\nCreating a release artifact is an essential step in the Salesforce deployment process, providing a consistent package that can be deployed across environments.\n\n## Key Concepts\n- A release artifact contains all components to be deployed\n- Artifacts should be versioned and tracked\n- Testing the artifact validates its integrity\n- Proper artifact management ensures deployment consistency\n\n## Detailed Guide\n### Creating a Release Artifact\n1. Define which components to include in the release\n2. Package components into a deployable format\n3. Version the artifact for tracking and rollback purposes\n4. Store the artifact in a secure, accessible location\n\n### Testing the Release Artifact\nBefore deploying to staging or production:\n1. Validate the artifact against a test environment\n2. Run tests to ensure components function correctly\n3. Verify that all dependencies are included\n4. Document test results for audit purposes\n\n## Code Examples\n```bash\n# Create a metadata package (artifact)\nsf project deploy start --source-dir force-app --target-org DevOrg --manifest-dir path/to/package.xml\n\n# Validate a metadata package without deploying\nsf project deploy start --manifest-dir path/to/package.xml --check-only --test-level RunLocalTests\n\n# Create an artifact using a SFDX project\nsfdx force:source:convert -d ./mdapioutput/\n```\n\n## Best Practices\n1. Include a consistent set of components in each artifact\n2. Version artifacts with meaningful names (e.g., v1.2.3-beta)\n3. Document the contents of each artifact\n4. Automate artifact creation through CI/CD pipelines\n5. Test each artifact thoroughly before promoting to staging\n\n## Further Reading\n- [Salesforce Package Development Model](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_dev2gp.htm)\n- [Continuous Integration with Salesforce DX](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ci.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/build_and_release/build_test_release_artifact.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/build_and_release/cancel_metadata_deployment.md",
      "content": "---\ndescription: How to cancel a Metadata API deployment in progress\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to cancel a Metadata API deployment in progress\nglobs: \nalwaysApply: false\n---\n# Cancel a Metadata Deployment\n\n## Overview\nSometimes it's necessary to cancel a deployment that's in progress due to errors, performance issues, or other concerns. Salesforce provides mechanisms to safely cancel deployments.\n\n## Key Concepts\n- Deployments can be canceled while they're in a queued or in-progress state\n- Cancellation rolls back any partially applied changes\n- Quick action can prevent negative impacts on your organization\n- Not all deployments can be canceled once they reach certain stages\n\n## Detailed Guide\n### When to Cancel a Deployment\nConsider canceling a deployment when:\n1. You discover errors in the deployment package\n2. The deployment is causing unexpected system behavior\n3. The deployment is taking too long during business hours\n4. You need to make urgent changes to the deployment package\n\n### How to Cancel a Deployment\n1. Identify the deployment job ID\n2. Use Salesforce CLI or Setup UI to cancel the deployment\n3. Verify the cancellation was successful\n4. Document the reason for cancellation\n\n## Code Examples\n```bash\n# Check deployment status\nsf project deploy report --job-id 0Afxxxxxxxxxxxx\n\n# Cancel an in-progress deployment\nsf project deploy cancel --job-id 0Afxxxxxxxxxxxx\n\n# Verify the deployment was canceled\nsf project deploy report --job-id 0Afxxxxxxxxxxxx\n```\n\n## Best Practices\n1. Monitor deployments actively so you can quickly identify issues\n2. Have authorized personnel ready to make cancellation decisions\n3. Document all canceled deployments and their reasons\n4. Review canceled deployments to improve future releases\n5. Consider using validation deployments (--check-only) to identify issues before actual deployment\n\n## Further Reading\n- [Salesforce Metadata API Deployment Options](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deploy_options.htm)\n- [Canceling Deployments in Salesforce](https://help.salesforce.com/articleView?id=sf.deploy_cancel.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/build_and_release/cancel_metadata_deployment.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/build_and_release/develop_test_changes_locally.md",
      "content": "---\ndescription: How to develop and test changes locally before deployment\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to develop and test changes locally before deployment\nglobs: \nalwaysApply: false\n---\n# Develop and Test Changes Locally\n\n## Overview\nDeveloping and testing changes locally is a critical first step in the Salesforce application release cycle, ensuring quality and reducing risks before deployment.\n\n## Key Concepts\n- Local development environments isolate changes from production\n- Scratch orgs and sandboxes provide safe testing spaces\n- Automated testing validates changes before deployment\n- Source tracking helps manage local versus remote changes\n\n## Detailed Guide\n### Setting Up Your Local Development Environment\n1. Create a scratch org or authorize a sandbox for development\n2. Push your source code to the development environment\n3. Make and test changes iteratively\n4. Track changes using source tracking\n\n### Testing Strategies\n- Unit tests: Verify individual components function correctly\n- Integration tests: Ensure components work together\n- UI tests: Validate user interface functionality\n- Performance tests: Check for efficiency and speed\n\n## Code Examples\n```bash\n# Create a scratch org for development\nsf org create scratch -f config/project-scratch-def.json -a DevOrg\n\n# Push source to development environment\nsf project deploy start --source-dir force-app --target-org DevOrg\n\n# Run Apex tests locally\nsf apex test run --test-level RunLocalTests --target-org DevOrg\n\n# Pull changes back to your project\nsf project retrieve start --source-dir force-app --target-org DevOrg\n```\n\n## Best Practices\n1. Create dedicated development environments for each major feature\n2. Run all tests locally before building release artifacts\n3. Use consistent naming conventions for development orgs\n4. Document all changes during development\n5. Use source control to track changes to your local codebase\n\n## Further Reading\n- [Salesforce DX Development Model](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_develop.htm)\n- [Apex Testing Best Practices](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_best_practices.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/build_and_release/develop_test_changes_locally.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/build_and_release/release_to_production.md",
      "content": "---\ndescription: How to safely release your Salesforce app to production\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to safely release your Salesforce app to production\nglobs: \nalwaysApply: false\n---\n# Release Your App to Production\n\n## Overview\nReleasing your app to production is the final step in the deployment process, requiring careful planning and execution to minimize risks and ensure a smooth transition.\n\n## Key Concepts\n- Production deployments require thorough preparation and testing\n- Deployment windows should be scheduled during low-activity periods\n- Post-deployment validation confirms success\n- Rollback plans provide safety in case of issues\n\n## Detailed Guide\n### Pre-Deployment Preparation\n1. Schedule a maintenance window if needed\n2. Notify users of potential downtime\n3. Ensure all stakeholders have approved the release\n4. Prepare detailed deployment and rollback plans\n\n### Executing the Production Deployment\n1. Validate the deployment without committing changes\n2. Monitor system performance during deployment\n3. Run automated tests to verify functionality\n4. Perform manual checks of critical functionality\n\n### Post-Deployment Activities\n1. Notify users that deployment is complete\n2. Monitor for any issues or performance degradation\n3. Document the deployment for audit purposes\n4. Update documentation and release notes\n\n## Code Examples\n```bash\n# Validate deployment without committing changes\nsf project deploy start --source-dir mdapioutput/ --target-org Production --check-only --test-level RunLocalTests\n\n# Execute production deployment\nsf project deploy start --source-dir mdapioutput/ --target-org Production --test-level RunLocalTests\n\n# Check deployment status\nsf project deploy report --job-id 0Afxxxxxxxxxxxx\n```\n\n## Best Practices\n1. Always validate deployments before committing changes\n2. Deploy during off-peak hours to minimize impact\n3. Have a detailed rollback plan ready\n4. Test critical functionality immediately after deployment\n5. Document each production deployment thoroughly\n6. Implement progressive deployments for complex changes\n\n## Further Reading\n- [Salesforce Deployment Best Practices](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deploy_best_practices.htm)\n- [Monitoring Deployments](https://help.salesforce.com/articleView?id=sf.deploy_monitoring.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/build_and_release/release_to_production.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/build_and_release/test_release_in_staging.md",
      "content": "---\ndescription: How to test your release artifact in a staging environment before production deployment\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to test your release artifact in a staging environment before production deployment\nglobs: \nalwaysApply: false\n---\n# Test the Release Artifact in a Staging Environment\n\n## Overview\nTesting a release artifact in a staging environment that mirrors production is a critical step in the deployment process, providing final validation before production release.\n\n## Key Concepts\n- Staging environments should closely resemble production\n- User acceptance testing (UAT) validates business requirements\n- Integration testing confirms compatibility with other systems\n- Performance testing identifies potential bottlenecks\n\n## Detailed Guide\n### Setting Up a Staging Environment\n1. Create a sandbox that matches production configuration\n2. Keep staging data synchronized with production (or representative data)\n3. Ensure all integrations are configured similarly to production\n4. Implement the same security and sharing model as production\n\n### Conducting Testing in Staging\n1. Deploy the release artifact to staging\n2. Run automated tests to verify functionality\n3. Perform manual UAT with business stakeholders\n4. Test integrations with external systems\n5. Conduct performance and load testing if necessary\n\n## Code Examples\n```bash\n# Deploy release artifact to staging\nsf project deploy start --source-dir mdapioutput/ --target-org StagingOrg\n\n# Run specified tests in staging\nsf apex test run --tests MyApexTest --target-org StagingOrg\n\n# Generate test coverage report\nsf apex test report --test-run-id 707xxxxxxxxxxxx --output-dir ./test-results\n```\n\n## Best Practices\n1. Use staging environments dedicated to pre-release validation\n2. Include user acceptance testing with key stakeholders\n3. Test all critical business processes end-to-end\n4. Document and fix all issues before promoting to production\n5. Create a formal sign-off process for release approval\n\n## Further Reading\n- [Salesforce Sandbox Environments](https://help.salesforce.com/articleView?id=sf.create_test_instance.htm)\n- [Testing Best Practices in Salesforce](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_best_practices.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/build_and_release/test_release_in_staging.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/continuous_integration/ci_development_models.md",
      "content": "---\ndescription: How to implement continuous integration for different Salesforce development models\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to implement continuous integration for different Salesforce development models\nglobs: \nalwaysApply: false\n---\n# CI Development Models for Salesforce DX\n\n## Overview\nThis guide explains how to set up continuous integration for different Salesforce development models, with sample repository configurations.\n\n## Key Concepts\n- Continuous integration can be implemented for both org-based and package development models\n- Different CI approaches are needed depending on your development model\n- Sample repositories provide templates for common CI scenarios\n\n## Detailed Implementation\n\n### CI for Org Development Model\nThe org development model focuses on using a source control system with direct deployments to orgs:\n\n1. Source code is stored in version control (Git)\n2. CI system authenticates to target orgs\n3. Changes are deployed directly to orgs using Metadata API\n4. Tests are run in the target org\n5. Deployments can be to sandboxes or production\n\n### CI for Package Development Model\nThe package development model centers around developing, versioning, and distributing packages:\n\n1. Source code is organized into package directories\n2. CI system creates package versions\n3. Package versions are tested in scratch orgs\n4. Successful packages can be promoted and installed to target orgs\n5. Dependencies between packages are managed in the CI process\n\n## Code Examples\n\n### Sample CI Config for Org Development Model\n\n```yaml\n# Example CI configuration for org-based development\nsteps:\n  - step: \"Authenticate to org\"\n    command: sfdx auth:jwt:grant --clientid $CONSUMER_KEY --jwtkeyfile assets/server.key --username $SF_USERNAME\n  \n  - step: \"Convert source to metadata format\"\n    command: sfdx force:source:convert -d ./mdapi_output\n  \n  - step: \"Deploy to target org\"\n    command: sfdx force:mdapi:deploy -d ./mdapi_output -u $SF_USERNAME -w 10 -l RunLocalTests\n```\n\n### Sample CI Config for Package Development Model\n\n```yaml\n# Example CI configuration for package development\nsteps:\n  - step: \"Authenticate to DevHub\"\n    command: sfdx auth:jwt:grant --clientid $CONSUMER_KEY --jwtkeyfile assets/server.key --username $DEVHUB_USERNAME --setdefaultdevhubusername\n  \n  - step: \"Create scratch org\"\n    command: sfdx force:org:create -f config/project-scratch-def.json -a scratch-org -s\n  \n  - step: \"Create package version\"\n    command: sfdx force:package:version:create -p MyPackage -d force-app -k $PACKAGE_KEY -w 10\n  \n  - step: \"Install package in scratch org\"\n    command: sfdx force:package:install -p \"MyPackage@1.0.0-1\" -w 10 -u scratch-org\n  \n  - step: \"Run tests\"\n    command: sfdx force:apex:test:run -u scratch-org -c -r json\n```\n\n## Best Practices\n\n### For Org Development Model\n1. Use sandbox orgs for testing before production deployment\n2. Include data migration scripts if needed\n3. Set up CI with branch-specific deployment targets\n4. Implement validation-only deployments for pull requests\n5. Use deployment parameters to control test execution\n\n### For Package Development Model\n1. Implement CI with package version creation\n2. Test installation of packages on clean scratch orgs\n3. Manage dependencies between packages\n4. Set up automatic promotion of packages after successful testing\n5. Consider release management strategies for multi-package projects\n\n## Further Reading\nFor more information, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/) and [Trailhead modules on CI/CD](https://trailhead.salesforce.com/en/content/learn/modules/sfdx_travis_ci).",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/continuous_integration/ci_development_models.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/continuous_integration/circleci_integration.md",
      "content": "---\ndescription: How to implement continuous integration using CircleCI with Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to implement continuous integration using CircleCI with Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Continuous Integration Using CircleCI\n\n## Overview\nThis guide provides instructions on how to set up and use CircleCI for continuous integration with your Salesforce DX projects.\n\n## Key Concepts\n- CircleCI is a popular continuous integration platform that can be used with Salesforce DX\n- CircleCI can automate testing, building, and deploying Salesforce applications\n- Integration with DevHub enables a complete CI pipeline\n\n## Detailed Implementation\n\n### Configure Your Environment for CircleCI\n1. Create a CircleCI account and connect it to your GitHub or Bitbucket repository\n2. Install the CircleCI CLI for local testing\n3. Set up environment variables in CircleCI for Salesforce authentication\n4. Create a configuration file for CircleCI (.circleci/config.yml)\n\n### Connect CircleCI to Your DevHub\n1. Store your DevHub authentication credentials securely in CircleCI\n2. Use JWT-based authentication for headless (CI) environments\n3. Configure CircleCI to authenticate to your DevHub org\n4. Validate the connection with a simple test job\n\n## Code Examples\n\n```yaml\n# Example .circleci/config.yml\nversion: 2.1\njobs:\n  build:\n    docker:\n      - image: salesforce/salesforcedx:latest\n    steps:\n      - checkout\n      - run:\n          name: Setup Org\n          command: |\n            echo \"$SFDX_AUTH_URL\" > sfdx_auth.txt\n            sfdx auth:sfdxurl:store -f sfdx_auth.txt -a DevHub\n      - run:\n          name: Create Scratch Org\n          command: sfdx force:org:create -f config/project-scratch-def.json -a scratch-org -s\n      - run:\n          name: Push Source\n          command: sfdx force:source:push -u scratch-org\n      - run:\n          name: Run Tests\n          command: sfdx force:apex:test:run -u scratch-org --codecoverage --resultformat json\n```\n\n## Best Practices\n1. Store sensitive credentials as encrypted environment variables in CircleCI\n2. Use separate environments (Scratch Orgs) for each build\n3. Include automated testing as part of your CI workflow\n4. Create a comprehensive config.yml that handles different branches appropriately\n5. Implement status checks in your repository to enforce quality gates\n\n## Further Reading\nFor more information, see the [CircleCI documentation](https://circleci.com/docs/) and [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/).",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/continuous_integration/circleci_integration.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/continuous_integration/jenkins_integration.md",
      "content": "---\ndescription: How to implement continuous integration using Jenkins with Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to implement continuous integration using Jenkins with Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Continuous Integration Using Jenkins\n\n## Overview\nThis guide provides instructions on how to set up and use Jenkins for continuous integration with your Salesforce DX projects.\n\n## Key Concepts\n- Jenkins is a powerful, open-source automation server that can be used for CI/CD\n- Jenkins provides extensive customization options for Salesforce DX pipelines\n- Jenkinsfiles define your build pipeline as code\n\n## Detailed Implementation\n\n### Configure Your Environment for Jenkins\n1. Install Jenkins on your server or use a cloud-hosted Jenkins instance\n2. Install necessary plugins (Git, Pipeline, Credentials)\n3. Install the Salesforce CLI on your Jenkins server\n4. Configure credentials for Salesforce authentication\n\n### Jenkinsfile Walkthrough\nA Jenkinsfile defines your build pipeline as code:\n1. Define stages of your build process\n2. Configure environment variables\n3. Specify test requirements\n4. Set up deployment steps\n5. Configure post-build actions\n\n### Sample Jenkinsfile\nA sample Jenkinsfile for a Salesforce DX project typically includes:\n1. Checkout stage for source control\n2. Authentication to DevHub\n3. Scratch org creation\n4. Source code deployment\n5. Test execution\n6. Scratch org cleanup\n\n## Code Examples\n\n```groovy\n// Example Jenkinsfile\npipeline {\n    agent any\n    \n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n            }\n        }\n        \n        stage('Authorize DevHub') {\n            steps {\n                withCredentials([file(credentialsId: 'sfdx_auth_url', variable: 'AUTH_FILE')]) {\n                    sh 'sfdx auth:sfdxurl:store -f $AUTH_FILE -a DevHub -d'\n                }\n            }\n        }\n        \n        stage('Create Scratch Org') {\n            steps {\n                sh 'sfdx force:org:create -f config/project-scratch-def.json -a scratch-org -s -d 1'\n            }\n        }\n        \n        stage('Push Source') {\n            steps {\n                sh 'sfdx force:source:push -u scratch-org'\n            }\n        }\n        \n        stage('Run Tests') {\n            steps {\n                sh 'sfdx force:apex:test:run -u scratch-org -c -r json -d test-results'\n            }\n        }\n    }\n    \n    post {\n        always {\n            sh 'sfdx force:org:delete -u scratch-org -p'\n        }\n    }\n}\n```\n\n## Best Practices\n1. Store Salesforce credentials securely using Jenkins Credentials plugin\n2. Use Pipeline as Code (Jenkinsfile) for version-controlled build definitions\n3. Set up separate agents/nodes for parallel builds\n4. Implement webhooks for automatic builds on code changes\n5. Archive test results and logs for troubleshooting\n6. Set up notifications for build status\n\n## Further Reading\nFor more information, see the [Jenkins documentation](https://www.jenkins.io/doc/) and [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/).",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/continuous_integration/jenkins_integration.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/continuous_integration/travis_ci_integration.md",
      "content": "---\ndescription: How to implement continuous integration using Travis CI with Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to implement continuous integration using Travis CI with Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Continuous Integration with Travis CI\n\n## Overview\nThis guide provides instructions on how to set up and use Travis CI for continuous integration with your Salesforce DX projects.\n\n## Key Concepts\n- Travis CI is a widely-used continuous integration service that integrates with GitHub\n- Travis CI can automate building, testing, and deploying Salesforce DX projects\n- Travis CI uses a YAML configuration file (.travis.yml) to define your build process\n\n## Detailed Implementation\n\n### Configure Your Environment for Travis CI\n1. Sign up for Travis CI and connect it to your GitHub repository\n2. Create a `.travis.yml` configuration file in your repository root\n3. Configure environment variables for Salesforce authentication\n4. Install the Salesforce CLI in your Travis build\n\n### Travis CI Configuration for Salesforce DX\n1. Define the build environment and dependencies\n2. Set up authentication to your DevHub org\n3. Configure scratch org creation and management\n4. Implement testing and deployment steps\n5. Set up notifications and artifacts\n\n## Code Examples\n\n```yaml\n# Example .travis.yml for Salesforce DX\nlanguage: node_js\nnode_js:\n  - \"12\"\n\nbefore_install:\n  # Install Salesforce CLI\n  - wget https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz\n  - mkdir sfdx\n  - tar xJf sfdx-linux-x64.tar.xz -C sfdx --strip-components 1\n  - export PATH=./sfdx/bin:$PATH\n  - sfdx --version\n  - sfdx plugins --core\n\nbefore_script:\n  # Authenticate to DevHub\n  - openssl enc -nosalt -aes-256-cbc -d -in assets/server.key.enc -out assets/server.key -base64 -K $ENCRYPTION_KEY -iv $ENCRYPTION_IV\n  - sfdx force:auth:jwt:grant --clientid $CONSUMER_KEY --jwtkeyfile assets/server.key --username $SF_USERNAME --setdefaultdevhubusername\n\nscript:\n  # Create a scratch org\n  - sfdx force:org:create -f config/project-scratch-def.json -a scratch-org -s\n  # Push source to scratch org\n  - sfdx force:source:push -u scratch-org\n  # Run Apex tests\n  - sfdx force:apex:test:run -u scratch-org -c -r v\n  # Delete the scratch org\n  - sfdx force:org:delete -u scratch-org -p\n```\n\n## Sample CI Repos for Development Models\n\n### Sample CI Repos for Org Development Model\nFor org-based development, CI repositories typically include:\n1. Configuration for deploying to a sandbox or production org\n2. Metadata-based deployment workflows\n3. Data migration scripts if needed\n4. Environment-specific configuration\n\n### Sample CI Repos for Package Development Model\nFor package development, CI repositories typically include:\n1. Package creation and versioning steps\n2. Package installation testing\n3. Cross-package dependency management\n4. Package promotion workflows\n\n## Best Practices\n1. Encrypt sensitive credentials using Travis encryption tools\n2. Cache dependencies to speed up builds\n3. Use build stages to create a comprehensive pipeline\n4. Implement code quality checks in addition to Apex tests\n5. Configure build notifications for your team\n6. Set up branch-specific build configurations\n\n## Further Reading\nFor more information, see the [Travis CI documentation](https://docs.travis-ci.com/) and [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/).",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/continuous_integration/travis_ci_integration.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/assign_permission_set.md",
      "content": "---\ndescription: How to assign permission sets to users in Salesforce orgs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to assign permission sets to users in Salesforce orgs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Assign a Permission Set\n\n## Overview\nThis rule covers how to assign permission sets to users in your Salesforce orgs using Salesforce CLI commands.\n\n## Key Concepts\n- Permission set assignments through CLI\n- Managing user access programmatically\n- Automation of permission assignments in deployment scripts\n\n## Detailed Sections\n### Assigning Permission Sets\n- Identify the permission set API name\n- Find the username to assign to\n- Use the CLI command to assign the permission set\n\n### Managing Permission Set Assignments\n- Listing existing permission set assignments\n- Removing permission set assignments\n- Bulk assignment operations\n\n## Code Examples\n```bash\n# Assign a permission set to a user\nsf org assign permset -n PermissionSetName -u username@example.com\n\n# Assign a permission set to the default org user\nsf org assign permset -n PermissionSetName\n\n# List all permission sets assigned to a user\nsf data query -q \"SELECT PermissionSet.Name FROM PermissionSetAssignment WHERE Assignee.Username = 'username@example.com'\" -u OrgAlias\n```\n\n## Best Practices\n1. Include permission set assignments in deployment scripts for consistent environments\n2. Use permission sets to manage access instead of modifying profiles directly\n3. Document which permission sets are required for different user roles\n4. Create scripts to automate permission assignments for consistent org setup\n\n## Further Reading\n- [Salesforce CLI Command Reference: Permission Set Assignment](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_force_user.htm)\n- [Permission Sets and Permission Set Groups](https://help.salesforce.com/articleView?id=perm_sets_overview.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/assign_permission_set.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/create_apex_class.md",
      "content": "---\ndescription: How to create and manage Apex classes using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and manage Apex classes using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create an Apex Class\n\n## Overview\nThis rule covers how to create, deploy, and manage Apex classes using Salesforce CLI commands.\n\n## Key Concepts\n- Apex class development\n- Different Apex class templates\n- Apex testing framework\n\n## Detailed Sections\n### Creating Apex Classes\n- Using CLI to generate different types of Apex classes\n- Available templates (default, controller, test, interface, etc.)\n- Structure and naming conventions\n\n### Deploying and Testing Apex\n- Deploying Apex classes to orgs\n- Running tests for Apex classes\n- Code coverage requirements\n\n## Code Examples\n```bash\n# Create a basic Apex class\nsf apex generate class --class-name MyApexClass --output-dir force-app/main/default/classes\n\n# Create an Apex controller\nsf apex generate class --class-name MyController --template DefaultController --output-dir force-app/main/default/classes\n\n# Create an Apex test class\nsf apex generate class --class-name MyClassTest --template ApexUnitTest --output-dir force-app/main/default/classes\n\n# Deploy Apex class to org\nsf project deploy start --source-dir force-app/main/default/classes\n\n# Run Apex tests\nsf apex run test --tests MyClassTest --code-coverage\n```\n\n## Best Practices\n1. Follow naming conventions (e.g., service classes end with \"Service\")\n2. Write test classes with at least 75% code coverage\n3. Use bulkification patterns for efficient data processing\n4. Implement error handling and proper exception classes\n5. Comment your code for better maintainability\n6. Follow SOLID principles in Apex development\n\n## Further Reading\n- [Apex Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/)\n- [Apex Testing Best Practices](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_best_practices.htm)\n- [Salesforce CLI Command Reference: Apex](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_apex.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/create_apex_class.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/create_apex_trigger.md",
      "content": "---\ndescription: How to create and manage Apex triggers using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and manage Apex triggers using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create an Apex Trigger\n\n## Overview\nThis rule covers how to create, deploy, and manage Apex triggers using Salesforce CLI commands, along with best practices for trigger implementation.\n\n## Key Concepts\n- Apex trigger architecture\n- Trigger context variables\n- Trigger handler pattern\n\n## Detailed Sections\n### Creating Apex Triggers\n- Using CLI to generate Apex triggers\n- Structure of an Apex trigger\n- Available trigger events (before/after insert/update/delete/undelete)\n\n### Trigger Best Practices\n- One trigger per object approach\n- Trigger handler pattern implementation\n- Bulkification for handling multiple records\n\n## Code Examples\n```bash\n# Create an Apex trigger\nsf apex generate trigger --trigger-name AccountTrigger --sobject Account --output-dir force-app/main/default/triggers\n\n# Deploy trigger to org\nsf project deploy start --source-dir force-app/main/default/triggers\n\n# Example trigger handler pattern\n```apex\ntrigger AccountTrigger on Account (before insert, before update, after insert, after update) {\n    AccountTriggerHandler handler = new AccountTriggerHandler();\n    \n    if (Trigger.isBefore) {\n        if (Trigger.isInsert) {\n            handler.onBeforeInsert(Trigger.new);\n        } else if (Trigger.isUpdate) {\n            handler.onBeforeUpdate(Trigger.new, Trigger.oldMap);\n        }\n    } else if (Trigger.isAfter) {\n        if (Trigger.isInsert) {\n            handler.onAfterInsert(Trigger.new);\n        } else if (Trigger.isUpdate) {\n            handler.onAfterUpdate(Trigger.new, Trigger.oldMap);\n        }\n    }\n}\n```\n\n## Best Practices\n1. Create one trigger per object\n2. Use a trigger handler class to separate trigger logic from the trigger itself\n3. Make triggers bulkified to handle multiple records efficiently\n4. Avoid SOQL queries and DML operations inside loops\n5. Use custom metadata or custom settings for trigger control/bypass logic\n6. Write comprehensive test coverage for all trigger paths\n\n## Further Reading\n- [Apex Trigger Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers.htm)\n- [Trigger Design Patterns](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_best_practices.htm)\n- [Salesforce CLI Command Reference: Apex](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_apex.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/create_apex_trigger.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/create_custom_object.md",
      "content": "---\ndescription: How to create and manage custom objects in Salesforce using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and manage custom objects in Salesforce using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create a Custom Object\n\n## Overview\nThis rule covers how to create and manage custom objects in Salesforce using Salesforce CLI and source-driven development.\n\n## Key Concepts\n- Custom object structure and metadata\n- Field types and properties\n- Object relationships\n\n## Detailed Sections\n### Creating Custom Objects\n- Manual XML creation\n- UI-based creation and retrieval\n- Required components and fields\n- Object metadata structure\n\n### Custom Object Fields\n- Different field types\n- Field properties (required, unique, external ID)\n- Formulas and rollup summaries\n\n### Object Relationships\n- Lookup relationships\n- Master-detail relationships\n- Many-to-many relationships\n\n## Code Examples\n```bash\n# Create a new custom object definition file\nmkdir -p force-app/main/default/objects/CustomObject__c/fields\n\n# Retrieve an existing custom object definition\nsf project retrieve start -m CustomObject__c\n\n# Deploy a custom object to an org\nsf project deploy start -m CustomObject__c\n```\n\nExample CustomObject__c metadata structure:\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CustomObject xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <label>Custom Object</label>\n    <pluralLabel>Custom Objects</pluralLabel>\n    <nameField>\n        <label>Custom Object Name</label>\n        <type>Text</type>\n    </nameField>\n    <deploymentStatus>Deployed</deploymentStatus>\n    <sharingModel>ReadWrite</sharingModel>\n    <enableActivities>true</enableActivities>\n    <enableReports>true</enableReports>\n</CustomObject>\n```\n\n## Best Practices\n1. Use descriptive labels and API names\n2. Plan object relationships before implementation\n3. Create fields with proper data types and validation\n4. Consider record access and sharing model\n5. Use custom metadata types for configuration data instead of custom objects\n6. Document object purpose and relationships\n\n## Further Reading\n- [Custom Objects in Salesforce](https://help.salesforce.com/articleView?id=dev_objects.htm)\n- [Object Relationship Overview](https://help.salesforce.com/articleView?id=overview_of_custom_object_relationships.htm)\n- [Metadata API Developer Guide: Custom Object](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_customobject.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/create_custom_object.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/create_lightning_apps_aura_components.md",
      "content": "---\ndescription: How to create Lightning apps and Aura components using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create Lightning apps and Aura components using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create Lightning Apps and Aura Components\n\n## Overview\nThis rule covers how to create and deploy Lightning applications and Aura components using Salesforce CLI commands.\n\n## Key Concepts\n- Lightning application architecture\n- Aura component development\n- Using templates to create Lightning components\n\n## Detailed Sections\n### Creating Lightning Apps\n- Structure of a Lightning application\n- Using CLI to generate Lightning app scaffolding\n- Customizing Lightning apps\n\n### Creating Aura Components\n- Structure of Aura components\n- Creating controller and helper files\n- Component bundles and organization\n\n## Code Examples\n```bash\n# Create a Lightning app\nsf lightning generate app --app-name MyLightningApp --output-dir force-app/main/default/aura\n\n# Create an Aura component\nsf lightning generate component --component-name MyAuraComponent --output-dir force-app/main/default/aura\n\n# Create an Aura component with all supporting files\nsf lightning generate component --component-name MyAuraComponent --type aura --output-dir force-app/main/default/aura\n```\n\n## Best Practices\n1. Follow component naming conventions for clarity and organization\n2. Use descriptive names for controller methods\n3. Separate concerns between components, controllers, and helpers\n4. Use design attributes to make components configurable\n5. Test Lightning components with Lightning Testing Service\n\n## Further Reading\n- [Lightning Aura Components Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.lightning.meta/lightning/intro_framework.htm)\n- [Salesforce CLI Command Reference: Lightning](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_lightning.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/create_lightning_apps_aura_components.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/create_lightning_web_components.md",
      "content": "---\ndescription: How to create Lightning Web Components (LWC) using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create Lightning Web Components (LWC) using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create Lightning Web Components\n\n## Overview\nThis rule covers how to create and develop Lightning Web Components (LWC) using Salesforce CLI commands and modern web standards.\n\n## Key Concepts\n- Lightning Web Components framework\n- Component-based architecture\n- Web standards and modern JavaScript\n\n## Detailed Sections\n### Creating LWC Components\n- Structure of an LWC component\n- Using CLI to generate LWC scaffolding\n- Component bundle files\n\n### LWC Development\n- JavaScript controller\n- HTML templates\n- CSS styling\n- XML configuration\n- Jest testing\n\n## Code Examples\n```bash\n# Create a Lightning Web Component\nsf lightning generate component --type lwc --component-name myComponent --output-dir force-app/main/default/lwc\n\n# Create an LWC with specific files\nsf lightning generate component --type lwc --component-name myComponent --output-dir force-app/main/default/lwc --template analytics\n\n# Deploy LWC to an org\nsf project deploy start --source-dir force-app/main/default/lwc/myComponent\n```\n\n## Best Practices\n1. Use kebab-case for HTML attributes and camelCase for JavaScript properties\n2. Follow component encapsulation principles\n3. Use @api decorators for public properties\n4. Create reusable, single-responsibility components\n5. Write Jest tests for components\n6. Use CSS custom properties for consistent styling\n\n## Further Reading\n- [Lightning Web Components Developer Guide](https://developer.salesforce.com/docs/component-library/documentation/lwc)\n- [Lightning Web Components Recipes](https://github.com/trailheadapps/lwc-recipes)\n- [Lightning Web Components Open Source](https://lwc.dev/)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/create_lightning_web_components.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/debug_apex.md",
      "content": "---\ndescription: How to debug Apex code in Salesforce using various debugging tools and techniques\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to debug Apex code in Salesforce using various debugging tools and techniques\nglobs: \nalwaysApply: false\n---\n# Debug Apex\n\n## Overview\nThis rule covers techniques and tools for debugging Apex code in Salesforce, including log analysis, IDE debugging, and troubleshooting common issues.\n\n## Key Concepts\n- Debug logs and log levels\n- Checkpoints and breakpoints\n- IDE debugging tools\n\n## Detailed Sections\n### Setting Up Debug Logs\n- Configuring trace flags\n- Setting log levels\n- Monitoring logs\n\n### IDE Debugging\n- Using Replay Debugger in VS Code\n- Setting breakpoints\n- Inspecting variables\n\n### Common Debugging Techniques\n- Using System.debug statements\n- Exception handling and error logging\n- Performance analysis\n\n## Code Examples\n```bash\n# Get a list of debug logs\nsf apex get log list --target-org myOrg\n\n# Get the most recent debug log\nsf apex get log --target-org myOrg\n\n# Save a log to a file\nsf apex get log --log-id 07L... --target-org myOrg --output-dir ./logs\n\n# Set a trace flag on a user\nsf apex get log --user-id 005... --debug-level FINEST --target-org myOrg\n```\n\nExample debug statements in Apex:\n```apex\n// Basic debug statement\nSystem.debug('Processing account: ' + account.Name);\n\n// Debug with different log levels\nSystem.debug(LoggingLevel.ERROR, 'Critical error occurred: ' + e.getMessage());\nSystem.debug(LoggingLevel.INFO, 'Process completed successfully');\n\n// Debug complex objects\nSystem.debug(LoggingLevel.FINE, 'Query results: ' + JSON.serializePretty(results));\n\n// Time-based debugging\nLong startTime = System.now().getTime();\n// ... code to measure ...\nLong endTime = System.now().getTime();\nSystem.debug('Process took ' + (endTime - startTime) + ' ms');\n```\n\n## Best Practices\n1. Use appropriate log levels to filter noise\n2. Add meaningful context to debug statements\n3. Remove or disable debug statements in production code\n4. Use try-catch blocks to capture and log exceptions\n5. Check governor limits during debugging\n6. Set up user trace flags instead of modifying code for debugging\n7. Use the Developer Console and IDE tools for complex debugging\n\n## Further Reading\n- [Debugging Apex](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging.htm)\n- [Debug Logs](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging_debug_log.htm)\n- [Replay Debugger](https://developer.salesforce.com/tools/vscode/en/apex/replay-debugger)\n- [Apex Flex Query](https://developer.salesforce.com/blogs/2018/05/summer-18-apex-flex-query)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/debug_apex.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/develop_against_any_org.md",
      "content": "---\ndescription: How to set up your development environment to work with any Salesforce org\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to set up your development environment to work with any Salesforce org\nglobs: \nalwaysApply: false\n---\n# Develop Against Any Org\n\n## Overview\nThis rule covers how to set up your development environment to work with any Salesforce org, not just scratch orgs, using Salesforce DX tools.\n\n## Key Concepts\n- Development against production, sandbox, or other non-scratch orgs\n- Source tracking with non-scratch orgs\n- Development workflows outside of the scratch org model\n\n## Detailed Sections\n### Setting Up Environment\n- Authenticate to your target org using `sf org login`\n- Set up source tracking for your target org\n- Configure your project for non-scratch org development\n\n### Working with Non-Scratch Orgs\n- Differences between scratch org and non-scratch org development\n- Managing source conflicts\n- Best practices for team development\n\n## Code Examples\n```bash\n# Authenticate to a production or sandbox org\nsf org login web -a MyOrgAlias\n\n# Pull source from the org to your local project\nsf project retrieve start\n\n# Push local changes to the org\nsf project deploy start\n```\n\n## Best Practices\n1. Use source tracking to keep local project in sync with org\n2. Establish team workflows to avoid conflicts when multiple developers work against the same org\n3. Use Git or another version control system alongside SFDX for tracking changes\n4. Consider partial deployments for large orgs to improve performance\n\n## Further Reading\n- [Salesforce DX Developer Guide: Develop Against Any Org](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_develop_any_org.htm)\n- [Source-Driven Development](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_develop_any_org.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/develop_against_any_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/execute_anonymous_apex.md",
      "content": "---\ndescription: How to execute anonymous Apex code against Salesforce orgs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to execute anonymous Apex code against Salesforce orgs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Execute Anonymous Apex\n\n## Overview\nThis rule covers how to execute anonymous Apex code blocks against Salesforce orgs using Salesforce CLI, useful for testing code snippets, data manipulation, and debugging.\n\n## Key Concepts\n- Anonymous Apex execution\n- Debugging and logging\n- Real-time code execution\n\n## Detailed Sections\n### Executing Anonymous Apex\n- Command syntax and options\n- Executing code from a file\n- Executing inline code\n\n### Logging and Debugging\n- Log levels and categories\n- Viewing debug logs\n- Troubleshooting execution errors\n\n## Code Examples\n```bash\n# Execute inline anonymous Apex\nsf apex run --target-org myOrg --code \"System.debug('Hello World');\"\n\n# Execute Apex from a file\nsf apex run --target-org myOrg --file path/to/apex/script.apex\n\n# Execute with specific log level\nsf apex run --target-org myOrg --file path/to/script.apex --log-level FINEST\n\n# Execute Apex with seeAllData=true\nsf apex run --target-org myOrg --file path/to/script.apex --see-all-data\n\n# Retrieve and view most recent debug log\nsf apex get log --target-org myOrg\n```\n\nExample Apex script file (script.apex):\n```apex\n// Query for accounts\nList<Account> accounts = [SELECT Id, Name FROM Account LIMIT 10];\n\n// Display results\nfor(Account acc : accounts) {\n    System.debug('Account: ' + acc.Name);\n}\n\n// Update a record\nif (!accounts.isEmpty()) {\n    accounts[0].Description = 'Updated via anonymous Apex';\n    update accounts[0];\n    System.debug('Updated account: ' + accounts[0].Id);\n}\n```\n\n## Best Practices\n1. Use System.debug statements strategically for useful information\n2. Set appropriate log levels to avoid excessive logs\n3. Consider governor limits when executing Apex anonymously\n4. Use anonymous Apex for testing and debugging, not production changes\n5. Include error handling in your anonymous Apex scripts\n6. Save frequently used scripts in version control\n\n## Further Reading\n- [Execute Anonymous Apex](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_anonymous_block.htm)\n- [Salesforce CLI Command Reference: Apex](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_apex.htm)\n- [Debug Logs](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/execute_anonymous_apex.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/generate_view_apex_debug_logs.md",
      "content": "---\ndescription: How to generate, retrieve, and analyze Apex debug logs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to generate, retrieve, and analyze Apex debug logs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Generate and View Apex Debug Logs\n\n## Overview\nThis rule covers how to set up, generate, retrieve, and analyze Apex debug logs using Salesforce CLI and other debugging tools.\n\n## Key Concepts\n- Debug log generation\n- Log levels and categories\n- Log retrieval and analysis\n\n## Detailed Sections\n### Setting Up Debug Logs\n- Debug levels configuration\n- Trace flags and expiration\n- User-based logging\n\n### Retrieving Debug Logs\n- Fetching logs via CLI\n- Filtering and searching logs\n- Managing log retention\n\n### Analyzing Log Content\n- Understanding log structure\n- Common log entries\n- Performance analysis\n\n## Code Examples\n```bash\n# Create a trace flag for a user (enables logging)\nsf apex get log --user-id 005... --debug-level FINEST --start-date \"2023-01-01T00:00:00.000+0000\" --expiration \"2023-01-02T00:00:00.000+0000\" --target-org myOrg\n\n# List available debug logs\nsf apex get log list --target-org myOrg\n\n# Get a specific log by ID\nsf apex get log --log-id 07L... --target-org myOrg\n\n# Get the most recent log\nsf apex get log --target-org myOrg\n\n# Save log to a file\nsf apex get log --log-id 07L... --output-dir ./logs --target-org myOrg\n```\n\nExample debug log level configuration:\n```apex\n// Setting up a custom Debug Level in Anonymous Apex\nLoggingLevel apexLogLevel = LoggingLevel.FINEST;\nLoggingLevel visualforceLogLevel = LoggingLevel.INFO;\nLoggingLevel systemLogLevel = LoggingLevel.DEBUG;\n\n// Creating a trace flag for current user\nId userId = UserInfo.getUserId();\nDebugLevel debugLevel = [SELECT Id FROM DebugLevel WHERE DeveloperName = 'MyCustomDebugLevel' LIMIT 1];\n\nTraceFlag traceFlag = new TraceFlag(\n    DebugLevelId = debugLevel.Id,\n    LogType = 'USER_DEBUG',\n    TracedEntityId = userId,\n    StartDate = Datetime.now(),\n    ExpirationDate = Datetime.now().addHours(1)\n);\ninsert traceFlag;\n```\n\n## Best Practices\n1. Set appropriate log levels to avoid excessive log size\n2. Create time-limited trace flags to avoid filling log storage\n3. Use specific log categories to focus on relevant information\n4. Parse logs programmatically for complex analysis\n5. Set up logging before executing the code you want to debug\n6. Use log viewers with filtering and search capabilities\n7. Delete old logs regularly to manage storage\n\n## Further Reading\n- [Debug Logs](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging_debug_log.htm)\n- [Debug Log Categories](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging_debug_log_categories.htm)\n- [Salesforce CLI Command Reference: Debug Logs](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_force_apex_log.htm)\n- [Monitoring Debug Logs](https://help.salesforce.com/articleView?id=sf.code_debug_log.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/generate_view_apex_debug_logs.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/development/run_apex_tests.md",
      "content": "---\ndescription: How to run Apex tests using Salesforce CLI and analyze test results\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to run Apex tests using Salesforce CLI and analyze test results\nglobs: \nalwaysApply: false\n---\n# Run Apex Tests\n\n## Overview\nThis rule covers how to run Apex tests using Salesforce CLI, view test results, and analyze code coverage.\n\n## Key Concepts\n- Apex test execution\n- Code coverage requirements\n- Test result analysis\n\n## Detailed Sections\n### Running Apex Tests\n- Running all tests in an org\n- Running specific test classes\n- Running tests with different options\n\n### Test Results and Code Coverage\n- Viewing test results\n- Understanding code coverage reports\n- Troubleshooting test failures\n\n## Code Examples\n```bash\n# Run a specific test class\nsf apex run test --tests MyTestClass --target-org myOrg\n\n# Run multiple test classes\nsf apex run test --tests MyTestClass,AnotherTestClass --target-org myOrg\n\n# Run tests with code coverage\nsf apex run test --tests MyTestClass --code-coverage --target-org myOrg\n\n# Run all tests in the org\nsf apex run test --test-level RunAllTestsInOrg --target-org myOrg\n\n# Run all local tests \nsf apex run test --test-level RunLocalTests --target-org myOrg\n\n# Output test results to JSON file\nsf apex run test --tests MyTestClass --result-format json --output-dir ./test-results\n\n# Run tests synchronously\nsf apex run test --tests MyTestClass --synchronous --target-org myOrg\n```\n\n## Best Practices\n1. Write tests for all Apex classes and triggers with at least 75% code coverage\n2. Use `@isTest` annotation for all test classes\n3. Create test data within test methods, not in the database\n4. Use `Test.startTest()` and `Test.stopTest()` to reset governor limits\n5. Test both positive and negative scenarios\n6. Use `System.assert` methods to verify expected behavior\n7. Run tests before every deployment\n8. Set up CI/CD pipelines to run tests automatically\n\n## Further Reading\n- [Apex Testing Framework](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing.htm)\n- [Salesforce CLI Command Reference: Apex Test](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_apex_commands_testing.htm)\n- [Best Practices for Apex Testing](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_best_practices.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/development/run_apex_tests.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/getting_started/create_application.md",
      "content": "---\ndescription: when creating a new salesforce application from scratch, follow these rules\nglobs: \nalwaysApply: false\n---\nCreate an Application\n\nFollow the basic workflow when you are starting from scratch to create and develop an app that runs on the Lightning Platform.\n\nSet up your project.\nAuthorize the Developer Hub org for the project.\nConfigure your local project.\nCreate a scratch org.\nPush the source from your project to the scratch org.\nDevelop the app.\nPull the source to keep your project and scratch org in sync.\nRun tests.\nAdd, commit, and push changes. Create a pull request.\nDeploy your app using one of the following methods:\n\nBuild and release your app with managed packages\nBuild and release your app using the Metadata API",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/getting_started/create_application.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/limitations/general_limitations.md",
      "content": "---\ndescription: Understanding general limitations and constraints when working with Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding general limitations and constraints when working with Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Salesforce DX Limitations\n\n## Overview\nSalesforce DX has several limitations and constraints that developers should be aware of when building and deploying applications. Understanding these limitations helps you make informed decisions about your development approach and avoid common pitfalls.\n\n## Key Limitations\n\n- **Metadata Type Coverage**: Not all metadata types are fully supported in source format\n- **API Limits**: Standard Salesforce API governor limits apply to DX operations\n- **Scratch Org Limitations**: Scratch orgs have time and feature limitations\n- **Package Version Creation**: Creating package versions can be time-consuming\n- **Performance**: Large deployments may experience performance issues\n- **Source Tracking**: Some metadata types have limitations with source tracking\n\n## Metadata Coverage Limitations\n\n### Partially Supported Metadata Types\nSome metadata types are only partially supported in source format:\n- Profiles and permission sets may require special handling\n- Custom settings with large data volumes\n- Some Lightning components with complex dependencies\n\n### Unsupported Metadata Types\nSome metadata types are not supported in source format and require workarounds:\n- Certain types of reports and dashboards\n- Some customizations made through the Setup menu\n- Organization-specific settings\n\n## Scratch Org Limitations\n\n### Time Constraints\n- Default 7-day lifespan (max 30 days)\n- Limited number of active scratch orgs per Dev Hub (default allocation)\n\n### Feature Constraints\n- Not all Salesforce features available in production are available in scratch orgs\n- Edition-specific features may not be available in all scratch org types\n- Performance differences between scratch orgs and production environments\n\n## Deployment Limitations\n\n### Size and Complexity\n- Large deployments may time out or fail\n- Complex dependency trees can cause deployment issues\n- Certain components must be deployed in a specific order\n\n### API Limits\n- Salesforce API limits apply to deployment operations\n- Bulk operations are subject to governor limits\n- Rate limiting may affect continuous integration processes\n\n## Source Tracking Limitations\n\n### Performance Issues\n- Source tracking may be slow for orgs with large amounts of metadata\n- Pull and push operations can time out for complex changes\n\n### Tracking Gaps\n- Not all changes are tracked automatically\n- Profile changes may require special handling\n- Some UI customizations may not be properly tracked\n\n## Best Practices to Mitigate Limitations\n\n1. Break deployments into smaller, manageable packages\n2. Implement retry mechanisms in CI/CD pipelines\n3. Use selective deployment to focus on changed components\n4. Test deployments in full sandboxes before production\n5. Document known limitations for your specific organization\n6. Create specialized scripts to handle problematic metadata types\n7. Implement proper error handling in automated processes\n\n## Further Reading\n- [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_intro.htm)\n- [Metadata Coverage Report](https://mdcoverage.secure.force.com/docs/metadata-coverage)\n- [Known Issues](https://success.salesforce.com/issues_index)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/limitations/general_limitations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/limitations/metadata_limitations.md",
      "content": "---\ndescription: Understanding the limitations of metadata support in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding the limitations of metadata support in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Metadata Support Limitations in Salesforce DX\n\n## Overview\nWhile Salesforce DX improves many aspects of development, not all metadata types are fully supported in the source format and deployment workflows. Understanding these limitations helps you plan your development and deployment strategies accordingly.\n\n## Metadata Coverage Limitations\n\n### Source Format Limitations\n- Some metadata types are only partially decomposed in source format\n- Large XML files may require special handling \n- Some metadata types maintain relationships in ways that aren't obvious\n- Complex dependencies can cause deployment order issues\n\n### Deployment Behavior\n- Certain metadata components must be deployed in a specific order\n- Some metadata types can't be deleted directly through source deployment\n- Destructive changes require special handling\n- Organization settings may vary between environments affecting deployments\n\n### Profile and Permission Set Challenges\n- Profiles retrieved from production include all permissions, not just customizations\n- Permission dependencies can cause deployment failures\n- User permissions are environment-specific and may require filtering\n- Custom field permissions require special handling during deployment\n\n## Common Problematic Metadata Types\n\n### Reports and Dashboards\n- Report types with complex folder structures\n- Dashboards with dynamic components\n- Reports with org-specific formula fields\n\n### Workflow and Process Automation\n- Process Builder flows with complex conditions\n- Workflow rules with time-dependent actions\n- Flow interviews and saved states\n\n### User Interface Components\n- Lightning page layouts with dynamic components\n- Custom Lightning components with complex dependencies\n- AppExchange-installed components\n\n## Workarounds and Solutions\n\n### For Partially Supported Types\n1. Use post-deployment scripts to configure metadata\n2. Create specialized deployment tools for specific metadata types\n3. Break down complex metadata into smaller components\n\n### For Profiles and Permissions\n1. Use permission sets instead of profiles where possible\n2. Create dedicated deployment profiles for each environment\n3. Use tools to filter permissions before deployment\n\n### For Complex Dependencies\n1. Document dependency orders for manual deployments\n2. Create package.xml files with proper sequencing\n3. Implement pre-deployment validation checks\n\n## Best Practices\n\n1. Regularly check the [Metadata Coverage Report](https://mdcoverage.secure.force.com/docs/metadata-coverage)\n2. Test deployments in sandboxes before production\n3. Create environment-specific deployment strategies for problematic metadata\n4. Document known limitations for your specific organization\n5. Use specialized tools for complex metadata management\n6. Consider change set deployment for certain metadata types\n\n## Further Reading\n- [Metadata API Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_intro.htm)\n- [Metadata Coverage Report](https://mdcoverage.secure.force.com/docs/metadata-coverage)\n- [Salesforce DX Metadata Format](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_source_file_format.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/limitations/metadata_limitations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/limitations/packaging_and_cicd_limitations.md",
      "content": "---\ndescription: Understanding the limitations of packaging and CI/CD in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding the limitations of packaging and CI/CD in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Packaging and CI/CD Limitations in Salesforce DX\n\n## Overview\nSalesforce DX introduced second-generation packaging and improved CI/CD capabilities, but these features have limitations that can impact your development and deployment processes. Understanding these limitations helps you design more effective CI/CD pipelines and packaging strategies.\n\n## Package Development Limitations\n\n### Package Version Creation\n- Package version creation can be time-consuming (often 10+ minutes)\n- Limited number of package versions created per day (varies by license)\n- Package version numbers cannot be reused once created\n\n### Dependencies Management\n- Complex dependency chains can be difficult to manage\n- Dependencies must be explicitly declared and versioned\n- Changing dependencies requires new package versions\n\n### Feature Limitations\n- Not all metadata types can be included in packages\n- Some components require special handling in package context\n- Certain org-specific customizations cannot be packaged\n\n## CI/CD Pipeline Limitations\n\n### Authentication Challenges\n- JWT-based authentication has implementation complexity\n- Authentication token management across environments\n- Connected App configuration must be maintained across orgs\n\n### Execution Time\n- Long-running operations can time out in CI/CD environments\n- Package installation and deployment can exceed CI/CD timeout limits\n- Test execution in deployment validation can be time-consuming\n\n### Validation Limitations\n- Limited pre-deployment validation capabilities\n- Destructive changes require special handling\n- Environmental differences can cause unexpected deployment failures\n\n## Unlocked Package Limitations\n\n### Upgrade Behavior\n- Upgrades may behave differently from fresh installations\n- Component deletion has special considerations\n- Some customizations may be preserved during upgrades\n\n### Org Dependency\n- Package functionality may depend on org-specific settings\n- Features may work differently across different org types\n- Edition-specific limitations can affect functionality\n\n### Versioning Constraints\n- Once released, package versions cannot be modified\n- Patch versions have limited modification capabilities\n- Semantic versioning requirements can be restrictive\n\n## Workarounds and Solutions\n\n### For Package Development\n1. Implement automated package creation pipelines\n2. Document dependencies comprehensively\n3. Create smaller, focused packages instead of monolithic ones\n4. Use scripts to verify package content before creation\n\n### For CI/CD Challenges\n1. Implement token refresh mechanisms\n2. Break deployment into smaller, manageable units\n3. Create specialized validation scripts\n4. Use parallel testing to reduce execution time\n\n### For Unlocked Package Issues\n1. Test package installations in various environments\n2. Document known limitations and org dependencies\n3. Implement post-installation configuration scripts\n4. Create comprehensive upgrade testing processes\n\n## Best Practices\n\n1. Automate package creation and installation\n2. Implement comprehensive testing at multiple stages\n3. Document environment-specific configurations\n4. Create deployment validation checks\n5. Design packages with clear boundaries and minimal dependencies\n6. Implement incremental deployment strategies\n7. Plan for disaster recovery and rollback scenarios\n\n## Further Reading\n- [Second-Generation Packaging](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_dev2gp.htm)\n- [Continuous Integration with Salesforce DX](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ci.htm)\n- [Unlocked Package Development](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_unlocked_pkg_intro.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/limitations/packaging_and_cicd_limitations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/limitations/scratch_org_limitations.md",
      "content": "---\ndescription: Understanding the limitations of Scratch Orgs in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding the limitations of Scratch Orgs in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Scratch Org Limitations in Salesforce DX\n\n## Overview\nScratch orgs are ephemeral Salesforce environments that serve as development and testing spaces. While they're powerful, they have several limitations that developers need to understand to use them effectively.\n\n## Time and Allocation Limitations\n\n### Scratch Org Lifespan\n- Default lifespan is 7 days (configurable up to 30 days)\n- Once expired, scratch orgs are deleted and cannot be recovered\n- Snapshots must be created to preserve configurations\n\n### Dev Hub Allocations\n- Limited number of active scratch orgs per Dev Hub (varies by license)\n- Enterprise Edition: Default 40 active scratch orgs\n- Developer Edition: Default 6 active scratch orgs\n- Expired orgs count toward your allocation until they're deleted\n\n## Feature and Configuration Limitations\n\n### Edition Differences\n- Not all Salesforce features are available in all scratch org editions\n- Some Enterprise/Unlimited Edition features are not available in Developer Edition scratch orgs\n- Edition-specific limits apply (records, custom objects, etc.)\n\n### Configuration Constraints\n- Some features cannot be enabled via the scratch org definition file\n- Certain org settings require manual configuration after creation\n- Some features have dependencies that must be configured in the right order\n\n### Performance Differences\n- Scratch orgs may have different performance characteristics than sandboxes/production\n- Resource allocation may vary based on Salesforce infrastructure\n- Batch processes and integrations may behave differently\n\n## Data and Integration Limitations\n\n### Data Volume\n- Not suitable for large data volume testing\n- Data import operations have performance limitations\n- Some data-intensive operations may fail or time out\n\n### External System Integration\n- External system connections must be reconfigured for each new scratch org\n- OAuth tokens are specific to each scratch org\n- IP whitelisting may be required for each new org\n\n### Connected App Limitations\n- Connected apps need to be recreated or configured for each scratch org\n- OAuth callback URLs may need to be updated\n- Consumer keys/secrets need to be managed for each org\n\n## Workarounds and Solutions\n\n### For Lifespan Limitations\n1. Use the maximum lifespan setting for complex projects\n2. Implement automated recreation scripts\n3. Create and use scratch org snapshots to preserve configurations\n4. Automate deployment of source code and configuration\n\n### For Feature Limitations\n1. Document which features are available in which scratch org types\n2. Use post-creation scripts to configure features not supported in definition files\n3. Consider using sandboxes for testing features not available in scratch orgs\n\n### For Data Limitations\n1. Create synthetic data generation scripts\n2. Use data factories in Apex for test data\n3. Implement data minimization strategies for testing\n\n## Best Practices\n\n1. Automate scratch org creation and setup\n2. Create comprehensive scratch org definition files\n3. Document known limitations for your specific project\n4. Implement CI/CD pipelines that create fresh scratch orgs\n5. Use scratch org snapshots for complex configurations\n6. Maintain separate scratch orgs for different feature development\n7. Implement regular pull/push cycles to avoid losing work\n\n## Further Reading\n- [Scratch Org Limits and Allocations](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_editions_allocations.htm)\n- [Scratch Org Definition File](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_def_file.htm)\n- [Scratch Org Features](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_def_file_config_values.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/limitations/scratch_org_limitations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/limitations/source_tracking_limitations.md",
      "content": "---\ndescription: Understanding the limitations of source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding the limitations of source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Source Tracking Limitations in Salesforce DX\n\n## Overview\nSource tracking is a key feature of Salesforce DX that tracks changes between your local project and your Salesforce orgs. However, it has several limitations that can impact your development workflow.\n\n## Performance Limitations\n\n### Large Metadata Volume\n- Source tracking may become slow in orgs with large amounts of metadata\n- Pull and push operations can time out for complex or large-scale changes\n- Initial tracking setup can be time-consuming for large orgs\n\n### Response Time\n- Source tracking operations may be slower than direct deployments\n- Status tracking queries can experience delays\n- Performance degrades as org complexity increases\n\n### Concurrent Operations\n- Multiple developers working on the same components can cause conflicts\n- Concurrent push/pull operations may interfere with each other\n- Conflict resolution may require manual intervention\n\n## Tracking Coverage Limitations\n\n### Not All Changes Are Tracked\n- Some metadata types are not fully supported by source tracking\n- UI-based customizations may not be properly tracked\n- Some AppExchange package modifications aren't tracked\n\n### Profile and Permission Changes\n- Profile changes often require special handling\n- Permission assignments may not be fully tracked\n- Custom field permissions require careful attention\n\n### Complex Metadata Relationships\n- Interdependent metadata may not track correctly\n- Component relationships might not be properly preserved\n- Some delete operations aren't properly tracked\n\n## Functional Limitations\n\n### Merge Conflicts\n- Limited built-in tooling for resolving complex merge conflicts\n- Manual resolution often required for complex changes\n- No visual diff tools in CLI\n\n### Deployment Validation\n- Limited pre-deployment validation for source tracked changes\n- No automatic dependency checking before deployment\n- Failures may occur late in the deployment process\n\n### Sandbox Limitations\n- Source tracking in sandboxes may behave differently than in scratch orgs\n- Refresh operations can break source tracking\n- Metadata API version differences can affect tracking\n\n## Workarounds and Solutions\n\n### For Performance Issues\n1. Segment projects into smaller, focused packages\n2. Use targeted pulls and pushes instead of org-wide operations\n3. Implement timeouts and retry mechanisms for large operations\n\n### For Tracking Gaps\n1. Document which changes must be manually managed\n2. Create post-deployment scripts for untracked configurations\n3. Develop custom tooling for special metadata types\n\n### For Conflict Management\n1. Establish team workflows to minimize conflicts\n2. Use source control branching strategies effectively\n3. Create specialized merge resolution processes\n\n## Best Practices\n\n1. Pull changes frequently to minimize drift\n2. Don't modify the same components in multiple environments simultaneously\n3. Use source control as the source of truth, not the org\n4. Implement regular synchronization cycles\n5. Document known tracking issues for your specific metadata\n6. Create validation scripts to verify successful tracking\n7. Train team members on proper source tracking workflows\n\n## Further Reading\n- [Source Tracking in Salesforce DX](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_source_tracking.htm)\n- [Managing Source-Tracked Projects](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_develop_source_tracked_orgs.htm)\n- [Resolving Conflicts](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_push_md_to_scratch_org.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/limitations/source_tracking_limitations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/metadata_coverage/metadata_api_versions.md",
      "content": "---\ndescription: Understanding Metadata API versions and their impact on metadata coverage\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding Metadata API versions and their impact on metadata coverage\nglobs: \nalwaysApply: false\n---\n# Metadata API Versions\n\n## Overview\nSalesforce releases new API versions three times a year, and each version may introduce new metadata types, modify existing ones, or deprecate others. Understanding how API versions affect metadata coverage is crucial for effective Salesforce DX development. This rule explains how to work with different Metadata API versions and their impact on your projects.\n\n## API Version Basics\n\n### Release Cycle\n- Three releases per year (Spring, Summer, Winter)\n- New API version with each release\n- Version format: `XX.0` (e.g., `58.0` for Summer '23)\n\n### Version Impacts\n- New metadata types may be introduced\n- Existing metadata fields may be added or modified\n- Behavior of existing metadata types may change\n- Certain metadata types may be deprecated\n\n## Setting API Versions\n\n### In sfdx-project.json\nSet the default API version for your project:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n### In CLI Commands\nSpecify API version in CLI commands:\n\n```bash\n# Deploy with a specific API version\nsf project deploy start --source-dir force-app --api-version 58.0\n\n# Retrieve with a specific API version\nsf project retrieve start --source-dir force-app --api-version 58.0\n```\n\n### In Component Files\nIndividual components may specify their API version:\n\n```xml\n<!-- In Apex class metadata -->\n<ApexClass xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <apiVersion>58.0</apiVersion>\n    <status>Active</status>\n</ApexClass>\n```\n\n## API Version Strategy\n\n### Choosing the Right Version\nFactors to consider when selecting an API version:\n\n1. **Org Compatibility**: Ensure all target orgs support your chosen version\n2. **Feature Requirements**: Choose a version that supports needed features\n3. **Stability**: Older versions may be more stable but lack new features\n4. **Support Timeline**: Consider Salesforce's version support policy\n\n### Version Alignment\nKeep API versions aligned across:\n- Project configuration\n- Individual components\n- CI/CD pipelines\n- Development environments\n\n```bash\n# Update API version in multiple files\nfind force-app -name \"*.xml\" -type f -exec sed -i 's/<apiVersion>57.0<\\/apiVersion>/<apiVersion>58.0<\\/apiVersion>/g' {} \\;\n```\n\n## API Version and Metadata Coverage\n\n### Checking Coverage by Version\nThe Metadata Coverage Report allows filtering by API version:\n\n```bash\n# Check coverage for a specific version\nsf open metadata:coverage --api-version 58.0\n```\n\n### Version-Specific Coverage Issues\n\n#### New Metadata Types\nNew metadata types are typically only available in newer API versions:\n\n```bash\n# Check if a new type is available in your version\nsf open metadata:coverage --metadata-type NewFeatureType --api-version 58.0\n```\n\n#### Modified Metadata\nExisting metadata may gain new fields or behavior:\n\n```bash\n# Deploy with a newer version to access new fields\nsf project deploy start --source-dir force-app --api-version 58.0\n```\n\n#### Deprecated Metadata\nSome metadata may be deprecated in newer versions:\n\n```bash\n# Use an older version if needed for deprecated features\nsf project deploy start --source-dir force-app --api-version 54.0\n```\n\n## Upgrading API Versions\n\n### Incremental Approach\nTake an incremental approach to version upgrades:\n\n1. Test in sandbox environments first\n2. Identify and resolve any compatibility issues\n3. Update all component API versions\n4. Update project configuration\n\n### Upgrade Process\n```bash\n# Update project configuration\nsed -i 's/\"sourceApiVersion\": \"57.0\"/\"sourceApiVersion\": \"58.0\"/g' sfdx-project.json\n\n# Update component API versions\nfind force-app -name \"*.xml\" -type f -exec sed -i 's/<apiVersion>57.0<\\/apiVersion>/<apiVersion>58.0<\\/apiVersion>/g' {} \\;\n\n# Test deployment with new version\nsf project deploy start --source-dir force-app --check-only\n```\n\n### Testing After Upgrade\nTest thoroughly after upgrading API version:\n\n```bash\n# Run all tests\nsf apex run test --target-org DevSandbox --code-coverage --test-level RunLocalTests\n```\n\n## API Version Best Practices\n\n1. **Standardize Versions**: Use the same API version across your project\n2. **Document Version Choice**: Document why a specific version was chosen\n3. **Regular Reviews**: Review API version strategy with each Salesforce release\n4. **Version Control**: Include API version changes in version control\n5. **Test Coverage**: Test thoroughly when changing API versions\n\n## Troubleshooting Version Issues\n\n### Common Issues\n1. **Missing Features**: Newer features not available in older versions\n2. **Behavior Changes**: Different behavior between versions\n3. **Deployment Failures**: Errors when deploying between orgs with different versions\n\n### Resolution Strategies\n1. Check the [Salesforce Release Notes](mdc:https:/help.salesforce.com/s/articleView?id=release-notes.salesforce_release_notes.htm) for version-specific changes\n2. Test deployments with the target org's API version\n3. Consider using feature detection instead of version checks in code\n\n## Further Reading\nFor more information about API versions and metadata coverage, see the [Metadata API Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_api_version.htm) and [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_api_version.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/metadata_coverage/metadata_api_versions.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/metadata_coverage/metadata_coverage_overview.md",
      "content": "---\ndescription: Understanding Salesforce DX metadata coverage and how to check component support\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding Salesforce DX metadata coverage and how to check component support\nglobs: \nalwaysApply: false\n---\n# Metadata Coverage Overview\n\n## Overview\nMetadata coverage refers to which Salesforce metadata components can be used with different Salesforce tools and features. The coverage varies across different deployment methods, packaging types, and development tools. This rule explains how to determine metadata coverage and use the Metadata Coverage Report.\n\n## Key Concepts\n\n- **Metadata Coverage**: Indicates whether a specific metadata type is supported by a particular Salesforce feature\n- **Source Tracking**: Ability to track changes to metadata in source format\n- **Packaging Types**: Different package formats (unlocked, 2GP, 1GP) support different metadata types\n- **Deployment Methods**: Change sets, Metadata API, and Salesforce DX CLI may have different metadata support\n\n## Understanding the Metadata Coverage Report\n\n### Accessing the Report\nThe Metadata Coverage Report is the official source of truth for metadata support:\n\n```bash\n# Open the Metadata Coverage Report in a browser\nsf open metadata:coverage\n```\n\nAlternatively, visit: [Metadata Coverage Report](mdc:https:/developer.salesforce.com/docs/metadata-coverage)\n\n### Using the Report\nThe Metadata Coverage Report provides information on:\n\n1. **Metadata API**: Can the component be deployed using Metadata API?\n2. **Source Tracking**: Is the component tracked in scratch orgs?\n3. **Unlocked Packaging**: Can the component be included in unlocked packages?\n4. **2GP Managed Packaging**: Can the component be included in second-generation managed packages?\n5. **1GP Managed Packaging**: Can the component be included in first-generation managed packages?\n6. **Change Sets**: Can the component be included in change sets?\n7. **Apex Metadata API**: Can the component be accessed via Apex Metadata API?\n\n### Filtering the Report\nThe report can be filtered by:\n- Metadata type name\n- API version\n- Support status for different features\n\n## Handling Unsupported Metadata\n\n### When Metadata Is Not Supported\nIf a metadata type is unsupported for your chosen deployment method:\n\n1. **Manual Deployment**: Deploy the component manually in the target org\n2. **Alternative Methods**: Use a supported deployment method for that component\n3. **Custom Solutions**: Create automation using the UI API or other APIs\n\n### Common Unsupported Metadata Types\nSome metadata types have limited support across features:\n- Certain Einstein features\n- Some Experience Cloud components\n- Enterprise Territory Management\n- Certain Knowledge settings\n- Multi-currency settings\n\n## Working with Partially Supported Metadata\n\n### Handling Partial Support\nSome metadata components have partial support:\n\n```bash\n# Check details for a specific component\nsf open metadata:coverage --metadata-type CustomObject\n```\n\nFor partially supported types:\n1. Check which aspects are supported\n2. Deploy supported elements through automation\n3. Document manual steps for unsupported elements\n\n## Best Practices\n\n1. **Check Before Development**: Verify metadata coverage before starting development\n2. **Keep API Versions Updated**: Newer API versions often support more metadata types\n3. **Plan Deployment Strategy**: Consider metadata coverage when choosing deployment methods\n4. **Document Manual Steps**: For unsupported components, document manual configuration steps\n5. **Test in Sandboxes**: Validate metadata deployment in sandbox environments first\n\n## Further Reading\nFor more information about metadata coverage, see the [Salesforce Metadata Coverage Report](mdc:https:/developer.salesforce.com/docs/metadata-coverage) and the [Metadata API Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_types_list.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/metadata_coverage/metadata_coverage_overview.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/metadata_coverage/special_deployment_behavior.md",
      "content": "---\ndescription: Understanding special behavior and considerations during metadata deployments\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding special behavior and considerations during metadata deployments\nglobs: \nalwaysApply: false\n---\n# Special Behavior in Metadata Deployments\n\n## Overview\nCertain metadata types exhibit special behavior during deployment through Salesforce DX and the Metadata API. Understanding these behaviors is essential for successful deployments and avoiding common pitfalls. This rule explains the special considerations for different metadata types during deployment.\n\n## Metadata Types with Special Behavior\n\n### Profiles and Permission Sets\n\n#### Special Behavior\n- Not all permissions can be deployed\n- Some permissions are environment-specific\n- References to non-existent components are silently ignored\n\n#### Handling Strategy\n```bash\n# Deploy profiles after all other components\nsf project deploy start --metadata Profile:Admin\n```\n\nBest practices:\n1. Deploy profiles last, after all other components\n2. Consider using permission sets instead of profiles when possible\n3. Use minimal profiles with permission sets for granular control\n\n### Custom Objects and Fields\n\n#### Special Behavior\n- Dependencies must be deployed in the correct order\n- Field deletions require special handling\n- Master-detail relationships have specific requirements\n\n#### Handling Strategy\n```bash\n# Deploy objects before relationships\nsf project deploy start --metadata \"CustomObject:Account,CustomObject:Contact\"\n\n# Then deploy relationships\nsf project deploy start --metadata CustomField:Contact.AccountId\n```\n\nBest practices:\n1. Deploy parent objects before child objects\n2. Handle picklist values carefully\n3. Be cautious with field type changes\n\n### Apex Classes and Triggers\n\n#### Special Behavior\n- Test coverage requirements (75% coverage for production)\n- Code dependencies must be resolved\n- Trigger order can affect behavior\n\n#### Handling Strategy\n```bash\n# Deploy with test execution\nsf project deploy start --metadata ApexClass --test-level RunLocalTests\n```\n\nBest practices:\n1. Include test classes in deployments\n2. Handle code dependencies explicitly\n3. Be aware of test data requirements\n\n## Destructive Changes\n\n### Special Considerations\n- Deleting components can have cascading effects\n- Some deletions require special permissions\n- Order of deletion matters\n\n### Handling Strategy\n```bash\n# Create a destructiveChanges.xml file\necho '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Package xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <types>\n        <members>OldClass</members>\n        <name>ApexClass</name>\n    </types>\n</Package>' > destructiveChanges.xml\n\n# Deploy with destructive changes\nsf project deploy start --metadata-dir your_metadata_dir --pre-destructive-changes destructiveChanges.xml\n```\n\nBest practices:\n1. Document dependencies before deletion\n2. Deploy destructive changes in phases\n3. Test deletions in sandbox environments first\n\n## Metadata Deployment Ordering\n\n### Natural Deployment Order\nThe Metadata API attempts to deploy components in a logical order:\n\n1. Custom objects\n2. Custom fields\n3. Validation rules\n4. Page layouts\n5. Workflows\n6. Apex classes\n7. Visualforce components\n8. Visualforce pages\n9. Profiles\n\n### Handling Order Issues\nSometimes you need to control deployment order:\n\n```bash\n# Deploy in multiple steps\nsf project deploy start --metadata CustomObject\nsf project deploy start --metadata CustomField\nsf project deploy start --metadata ValidationRule\n```\n\n## Package.xml Considerations\n\n### Wildcard Behaviors\nWildcards (`*`) behave differently for different metadata types:\n\n```xml\n<!-- This includes all custom fields on Account -->\n<types>\n    <members>Account.*</members>\n    <name>CustomField</name>\n</types>\n\n<!-- This includes all Apex classes -->\n<types>\n    <members>*</members>\n    <name>ApexClass</name>\n</types>\n```\n\n### Handling Package.xml\n```bash\n# Create specialized package.xml files for different deployment phases\ncp package.xml package-phase1.xml\ncp package.xml package-phase2.xml\n\n# Edit each file to include appropriate components\n\n# Deploy in phases\nsf project deploy start --manifest package-phase1.xml\nsf project deploy start --manifest package-phase2.xml\n```\n\n## Partial Deployments\n\n### Validation-Only Deployments\nValidate deployments before executing them:\n\n```bash\n# Validate deployment without making changes\nsf project deploy start --metadata CustomObject:Account --check-only\n```\n\n### Quick Deployments\nAfter validation, deploy without running tests again:\n\n```bash\n# Deploy using a previously validated deployment ID\nsf project deploy start --validation-id 0Af0x00000123ABC\n```\n\n## Best Practices\n\n1. **Test Deployments**: Always test deployments in sandbox environments first\n2. **Understand Dependencies**: Map component dependencies before deployment\n3. **Use Versioning**: Include API versions for all deployments\n4. **Incremental Deployments**: Deploy changes in small, incremental batches\n5. **Monitor Logs**: Review deployment logs for warning messages\n6. **Rollback Strategy**: Always have a rollback plan for failed deployments\n\n## Further Reading\nFor more information about special behavior in metadata deployments, see the [Metadata API Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deploy_considerations.htm) and [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_deploy.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/metadata_coverage/special_deployment_behavior.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/metadata_coverage/unsupported_metadata_types.md",
      "content": "---\ndescription:  Understanding metadata types that are not supported in Salesforce DX deployments\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding metadata types that are not supported in Salesforce DX deployments\nglobs: \nalwaysApply: false\n---\n# Unsupported Metadata Types\n\n## Overview\nWhile Salesforce DX and the Metadata API support many metadata components, some Salesforce features cannot be retrieved or deployed programmatically. This rule explains which metadata types are unsupported, why they're unsupported, and strategies for handling them in your development lifecycle.\n\n## Common Unsupported Metadata Types\n\n### Organization Settings\nSome organization-wide settings cannot be deployed via Metadata API:\n- Multi-currency settings\n- Fiscal year settings\n- Company information\n- Business hours\n- Certain security settings\n\n### Feature-Specific Settings\nCertain feature settings have limited or no API support:\n- Some Einstein Analytics/Tableau CRM settings\n- Experience Cloud template choices\n- Certain Knowledge settings\n- Data category group assignments\n- Some Lightning App Builder elements\n\n### User-Related Settings\nSettings specific to users often cannot be deployed:\n- Personal email templates\n- Private reports and dashboards\n- Individual user settings and preferences\n- Personal folders\n\n## Reasons for Lack of Support\n\n### Technical Limitations\n- Complex dependencies on other metadata\n- Customizations that are too specific to an organization\n- Features that require live connections to third-party systems\n\n### Security Considerations\n- Settings that could compromise security if deployed programmatically\n- Sensitive configuration that requires manual verification\n- Settings requiring explicit user consent\n\n### Product Lifecycle\n- Recently released features often gain API support in later releases\n- Beta features may not have API support until GA\n- Legacy features might never receive API support\n\n## Strategies for Handling Unsupported Metadata\n\n### Documentation\nDocument unsupported metadata components in your project:\n\n```bash\n# Create a deployment guide that includes manual steps\necho \"# Deployment Guide: Manual Steps\" > deployment-guide.md\necho \"The following components must be configured manually:\" >> deployment-guide.md\necho \"1. Multi-currency settings\" >> deployment-guide.md\necho \"2. Business hours\" >> deployment-guide.md\n```\n\n### Alternative Approaches\n1. **UI Automation**: Use Selenium or similar tools to automate UI configuration\n2. **Step-by-Step Guides**: Create detailed guides with screenshots for manual configuration\n3. **Salesforce Inspector**: Use tools like Salesforce Inspector to copy settings between orgs\n4. **Configuration Snapshots**: Take before/after snapshots of settings for reference\n\n### Continuous Verification\nBuild verification steps into your CI/CD process:\n\n```bash\n# Example verification script\nsf org open --target-org production\necho \"Please verify the following manual configurations have been completed:\"\necho \"1. Multi-currency settings\"\necho \"2. Business hours\"\n```\n\n## Working with Partially Supported Types\n\nSome metadata types are partially supported, meaning some aspects can be deployed while others cannot:\n\n### Profiles and Permission Sets\n- Structure can be deployed, but some permissions might be ignored\n- References to unsupported metadata are ignored during deployment\n\n### Custom Objects\n- Basic structure can be deployed, but some advanced settings might require manual configuration\n- Data sharing settings might need manual adjustment\n\n## Best Practices\n\n1. **Check Coverage Early**: Identify unsupported metadata types at the beginning of your project\n2. **Create Checklists**: Maintain checklists of manual steps for each environment\n3. **Environment Parity**: Keep development environments as similar as possible to reduce configuration drift\n4. **Regular Reviews**: Regularly check the Metadata Coverage Report for newly supported types\n5. **Feedback to Salesforce**: Submit feedback for unsupported types that are critical to your workflow\n\n## Further Reading\nFor more information about unsupported metadata types, see the [Metadata API Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_unsupported_types.htm) and [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_unsupported_metadata.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/metadata_coverage/unsupported_metadata_types.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/metadata_coverage/working_with_custom_metadata.md",
      "content": "---\ndescription: How to work with custom metadata types in Salesforce DX development\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to work with custom metadata types in Salesforce DX development\nglobs: \nalwaysApply: false\n---\n# Working with Custom Metadata\n\n## Overview\nCustom Metadata Types (CMT) provide a powerful way to create application configuration that can be easily deployed between environments. Unlike custom settings, custom metadata can be included in packages and deployed through the Metadata API. This rule explains how to work with custom metadata types in Salesforce DX projects.\n\n## Custom Metadata Concepts\n\n### What is Custom Metadata?\n- App configuration data that can be packaged and deployed\n- Similar to custom objects but designed for metadata (not records)\n- Deployable through all standard deployment tools\n- Accessible in Apex, formulas, and validation rules\n\n### Benefits of Custom Metadata\n- Deployable through Metadata API (unlike custom settings)\n- Packageable (both records and type definitions)\n- Environment-specific configurations\n- No SOQL limits when querying\n- Protected in managed packages\n\n## Working with Custom Metadata in Salesforce DX\n\n### Structure in Source Format\nCustom metadata is represented in two parts:\n1. **Type definition** (similar to custom object definition)\n2. **Records** (the actual configuration values)\n\n```\nforce-app/main/default/\n  ├── objects/\n  │   └── MySettings__mdt/                      # Custom metadata type\n  │       ├── MySettings__mdt.object-meta.xml   # Type definition\n  │       └── fields/                           # Fields\n  │           ├── Value__c.field-meta.xml\n  │           └── Description__c.field-meta.xml\n  └── customMetadata/                          # Records\n      ├── MySettings__mdt.Setting1.md-meta.xml\n      └── MySettings__mdt.Setting2.md-meta.xml\n```\n\n### Creating Custom Metadata Types\n\n1. **Via UI**: Create in Setup, then retrieve\n```bash\n# Retrieve custom metadata type\nsf project retrieve start --metadata \"CustomObject:MySettings__mdt\"\n```\n\n2. **Via Source**: Create metadata files directly\n```xml\n<!-- MySettings__mdt.object-meta.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CustomObject xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <label>My Settings</label>\n    <pluralLabel>My Settings</pluralLabel>\n    <visibility>Public</visibility>\n</CustomObject>\n\n<!-- Value__c.field-meta.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CustomField xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <fullName>Value__c</fullName>\n    <externalId>false</externalId>\n    <fieldManageability>DeveloperControlled</fieldManageability>\n    <label>Value</label>\n    <length>255</length>\n    <required>false</required>\n    <type>Text</type>\n    <unique>false</unique>\n</CustomField>\n```\n\n### Creating Custom Metadata Records\n\n1. **Via UI**: Create records in Setup, then retrieve\n```bash\n# Retrieve custom metadata records\nsf project retrieve start --metadata \"CustomMetadata:MySettings__mdt.Setting1\"\n```\n\n2. **Via Source**: Create record files directly\n```xml\n<!-- MySettings__mdt.Setting1.md-meta.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CustomMetadata xmlns=\"http://soap.sforce.com/2006/04/metadata\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    <label>Setting 1</label>\n    <protected>false</protected>\n    <values>\n        <field>Value__c</field>\n        <value xsi:type=\"xsd:string\">Some configuration value</value>\n    </values>\n    <values>\n        <field>Description__c</field>\n        <value xsi:type=\"xsd:string\">Description for Setting 1</value>\n    </values>\n</CustomMetadata>\n```\n\n### Deploying Custom Metadata\n\nDeploy both the type and records:\n\n```bash\n# Deploy custom metadata type and records\nsf project deploy start --source-dir force-app\n\n# Deploy specific records only\nsf project deploy start --metadata \"CustomMetadata:MySettings__mdt.Setting1\"\n```\n\n## Environment-Specific Configuration\n\n### Using Custom Metadata for Multi-Environment Setup\n\n1. Create environment-specific record files:\n\n```\nforce-app/main/default/customMetadata/\n  ├── MySettings__mdt.Dev.md-meta.xml\n  ├── MySettings__mdt.QA.md-meta.xml\n  ├── MySettings__mdt.UAT.md-meta.xml\n  └── MySettings__mdt.Prod.md-meta.xml\n```\n\n2. Add environment detection logic in Apex:\n\n```java\npublic class ConfigService {\n    public static String getEnvironmentSpecificValue(String settingName) {\n        String environment = getCurrentEnvironment();\n        MySettings__mdt setting = [\n            SELECT Value__c FROM MySettings__mdt \n            WHERE DeveloperName = :environment\n            LIMIT 1\n        ];\n        return setting.Value__c;\n    }\n    \n    private static String getCurrentEnvironment() {\n        // Logic to determine current environment\n        // Could be based on domain, custom setting, etc.\n        return 'Dev';\n    }\n}\n```\n\n## Best Practices for Custom Metadata\n\n### Naming Conventions\n- Use descriptive names for types and records\n- Add `__mdt` suffix to easily identify custom metadata types\n- Use consistent naming for related records\n\n### Field Manageability\nChoose appropriate field manageability:\n- **DeveloperControlled**: Only developers can change values (in metadata)\n- **SubscriberControlled**: Subscribers can change values (in their org)\n- **Locked**: Values cannot be changed after release\n\n```xml\n<CustomField xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <fullName>Value__c</fullName>\n    <fieldManageability>DeveloperControlled</fieldManageability>\n    <!-- other properties -->\n</CustomField>\n```\n\n### Organizing Related Metadata\nGroup related settings by type:\n\n```\nMyApp_Settings__mdt       # General settings\nMyApp_UISettings__mdt     # UI configuration\nMyApp_IntegSettings__mdt  # Integration settings\n```\n\n### Protected Custom Metadata\nFor sensitive settings, use the protected flag:\n\n```xml\n<CustomMetadata xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <label>API Key Setting</label>\n    <protected>true</protected>\n    <!-- values -->\n</CustomMetadata>\n```\n\n## Troubleshooting\n\n### Common Issues\n1. **Deployment Failures**: Ensure referenced fields exist\n2. **Access Issues**: Check field manageability settings\n3. **Integration Issues**: Verify data types match expected values\n\n### Resolution Strategies\n1. Deploy custom metadata type before records\n2. Validate XML format for custom metadata records\n3. Check for field type mismatches in record values\n\n## Further Reading\nFor more information about working with custom metadata types, see the [Custom Metadata Types Implementation Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/custommetadata_overview.htm) and [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_develop.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/metadata_coverage/working_with_custom_metadata.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/convert_metadata_to_source.md",
      "content": "---\ndescription: How to convert files in Metadata API format to Salesforce DX source format\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to convert files in Metadata API format to Salesforce DX source format\nglobs: \nalwaysApply: false\n---\n# Convert Files in Metadata Format to Source Format\n\n## Overview\nSalesforce DX introduces a new, more granular file format known as \"source format\" that improves team development and version control. This rule outlines the process for converting traditional Metadata API format files to the Salesforce DX source format.\n\n## Understanding the Formats\n\n### Metadata API Format\n- Monolithic XML files grouped by metadata type\n- Used by traditional Salesforce development tools (ANT Migration Tool, Workbench, etc.)\n- Located in directories named after metadata types (`classes/`, `objects/`, etc.)\n\n### Source Format\n- Decomposed into smaller, component-based files\n- Optimized for version control and team development\n- Files have `-meta.xml` suffix and are organized in typed directories\n- Custom objects and fields are broken down into individual files\n\n## Conversion Process\n\n### Using the Salesforce CLI\n\nThe basic command for conversion is:\n\n```bash\nsf project convert source:mdapi --root-dir <mdapi-dir> --output-dir <source-dir>\n```\n\n#### Example Workflow:\n\n1. Create a directory for your Metadata API format files:\n```bash\nmkdir mdapi_source\n```\n\n2. Add your Metadata API files to this directory (manually or retrieve them)\n\n3. Convert to source format:\n```bash\nsf project convert source:mdapi --root-dir mdapi_source --output-dir force-app\n```\n\n### Converting Retrieved Metadata\n\nIf you need to retrieve metadata first:\n\n1. Authorize the source org:\n```bash\nsf org login web --alias sourceOrg\n```\n\n2. Retrieve metadata into a directory:\n```bash\nsf project retrieve start --target-org sourceOrg --retrievetargetdir mdapi_source\n```\n\n3. Convert the retrieved metadata:\n```bash\nsf project convert source:mdapi --root-dir mdapi_source --output-dir force-app\n```\n\n### Batch Conversion for Large Metadata Sets\n\nFor very large orgs, convert in batches:\n\n```bash\n# Step 1: Retrieve specific metadata types\nsf project retrieve start --target-org sourceOrg --retrievetargetdir mdapi_batch1 -m \"CustomObject\"\n\n# Step 2: Convert just that batch\nsf project convert source:mdapi --root-dir mdapi_batch1 --output-dir force-app\n\n# Repeat for other types\nsf project retrieve start --target-org sourceOrg --retrievetargetdir mdapi_batch2 -m \"ApexClass,ApexTrigger\"\nsf project convert source:mdapi --root-dir mdapi_batch2 --output-dir force-app\n```\n\n## Handling Special Conversion Cases\n\n### Package.xml File\nThe Package.xml file isn't needed in source format but can be used for deployments:\n\n```bash\n# Convert but keep package.xml for future use\nsf project convert source:mdapi --root-dir mdapi_source --output-dir force-app --preserve-package-xml\n```\n\n### Profiles and Permission Sets\nProfiles and permission sets may need special attention:\n\n```bash\n# Convert just profiles\nsf project convert source:mdapi --root-dir mdapi_profiles --output-dir force-app -m \"Profile\"\n```\n\n### Handling Destructive Changes\nTo handle destructive changes:\n\n```bash\n# Place your destructiveChanges.xml file in the mdapi directory\n# Then convert with the preserve flag\nsf project convert source:mdapi --root-dir mdapi_with_destructive --output-dir force-app --preserve-package-xml\n```\n\n## Post-Conversion Steps\n\n### Review Converted Files\nAfter conversion, review the structure to ensure everything converted properly:\n\n```bash\n# List source directory structure\nfind force-app -type f | sort\n```\n\n### Validate in a Scratch Org\nDeploy the converted source to a scratch org to validate:\n\n```bash\n# Create a scratch org\nsf org create scratch --definition-file config/project-scratch-def.json --alias validateOrg\n\n# Deploy converted source\nsf project deploy start --target-org validateOrg\n```\n\n### Update Project Configuration\nUpdate your `sfdx-project.json` with appropriate values:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n## Converting Back to Metadata Format\n\nIf you need to convert source format back to Metadata API format:\n\n```bash\nsf project convert source:mdapi --root-dir force-app --output-dir mdapi_output\n```\n\nThis is useful for:\n- Deploying to orgs that don't support source format\n- Working with legacy tools\n- Creating migration packages\n\n## Troubleshooting\n\n### Common Conversion Issues\n\n1. **Missing Files After Conversion**: Check for files with special characters:\n```bash\n# Find files with special characters\nfind mdapi_source -name '*[^a-zA-Z0-9._-]*' -print\n```\n\n2. **Conversion Errors**: Enable debug logging:\n```bash\nsf config set logLevel=debug --global\nsf project convert source:mdapi --root-dir mdapi_source --output-dir force-app\n```\n\n3. **Large File Sets**: Break down into smaller batches by metadata type\n\n### Handling Specific Errors\n\nFor \"Entity name must immediately follow the '&' in the entity reference\" errors:\n```bash\n# Use a text tool to fix XML special characters in the source files\nsed -i 's/&/&amp;/g' mdapi_source/**/*.xml\n```\n\n## Best Practices\n\n1. **Commit After Conversion**: Create a Git commit immediately after successful conversion\n2. **Keep Original Metadata**: Maintain a copy of the original metadata for reference\n3. **Convert in Batches**: For large orgs, convert metadata types in logical groups\n4. **Test After Conversion**: Deploy to a scratch org to ensure everything works\n5. **Use Source Format Going Forward**: Once converted, maintain the source format for all future work\n\n## Further Reading\nFor more information about converting Metadata API format to source format, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_convert_mdapi.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/convert_metadata_to_source.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/create_project_from_existing_source.md",
      "content": "---\ndescription: How to create a Salesforce DX project from existing source code\nglobs: \nalwaysApply: false\n---\n# Create a Salesforce DX Project from Existing Source\n\n## Overview\nWhen migrating from traditional Salesforce development to Salesforce DX, you often need to create a Salesforce DX project from existing source code. This rule outlines the process for converting your existing metadata into a source-tracked Salesforce DX project.\n\n## Prerequisites\n- Salesforce CLI installed and updated\n- Appropriate permissions to access the source org\n- Git installed (for version control)\n\n## Project Creation Process\n\n### 1. Create a New SFDX Project\nFirst, create a new Salesforce DX project as a foundation:\n\n```bash\nsf project generate --name ExistingSourceProject\ncd ExistingSourceProject\n```\n\n### 2. Options for Getting the Metadata\n\n#### Option A: Retrieve directly from an org to source format\n\n1. Authorize the org that contains your existing metadata:\n```bash\nsf org login web --alias sourceOrg\n```\n\n2. Retrieve the metadata directly into your project's source format:\n```bash\n# Retrieve specific metadata types\nsf project retrieve start --target-org sourceOrg --metadata-path force-app -m \"CustomObject,ApexClass,CustomTab,Layout\"\n\n# Or retrieve all metadata\nsf project retrieve start --target-org sourceOrg --metadata-path force-app\n```\n\n#### Option B: Convert from Metadata API format\n\n1. If your source is already in Metadata API format (e.g., from ANT Migration Tool or retrieved via Workbench):\n\n```bash\n# Create a directory for your metadata API-formatted files\nmkdir mdapi_source\n\n# Move your existing files into this directory\n# Then convert to source format\nsf project convert source:mdapi --root-dir mdapi_source --output-dir force-app\n```\n\n### 3. Update Project Configuration\n\nUpdate the `sfdx-project.json` file to reflect your project structure:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true,\n      \"package\": \"ExistingSourcePackage\",\n      \"versionName\": \"Version 1.0\",\n      \"versionNumber\": \"1.0.0.NEXT\"\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n## Working with Complex Existing Sources\n\n### Handling Package Dependencies\nIf your source has dependencies on managed packages:\n\n1. Document all package dependencies in your project configuration:\n\n```json\n\"packageAliases\": {\n  \"DependencyPackage\": \"04tXXXXXXXXXXXXXXXX\"\n}\n```\n\n2. Install dependencies when creating scratch orgs:\n\n```bash\nsf org create scratch --definition-file config/project-scratch-def.json --duration-days 30 --alias devScratch\nsf package install --package DependencyPackage --target-org devScratch\n```\n\n### Handling Large Source Code Bases\n\nFor very large code bases, consider:\n\n1. Retrieving metadata in batches:\n\n```bash\n# Retrieve core objects first\nsf project retrieve start --target-org sourceOrg --metadata-path force-app -m \"CustomObject:Account,CustomObject:Contact\"\n\n# Then retrieve classes\nsf project retrieve start --target-org sourceOrg --metadata-path force-app -m \"ApexClass\"\n\n# And so on for other metadata types\n```\n\n2. Using package development model to split source:\n\n```bash\n# Create multiple package directories in your project\nmkdir -p force-app/core\nmkdir -p force-app/features\n```\n\nThen update your `sfdx-project.json` accordingly.\n\n## Best Practices\n\n### Organize Source Code\nAfter retrieving metadata, organize it logically:\n\n```bash\n# Example organization by feature\nmkdir -p force-app/main/default/featureA\nmkdir -p force-app/main/default/featureB\n```\n\n### Initialize Git\nInitialize Git for version control:\n\n```bash\ngit init\ngit add .\ngit commit -m \"Initial commit from existing source\"\n```\n\n### Create a .gitignore File\nCreate a proper `.gitignore` file for Salesforce DX:\n\n```\n# Standard .gitignore entries for Salesforce DX\n.sfdx/\n.sf/\n.vscode/\n.idea/\nIlluminatedCloud/\nnode_modules/\n*.sublime-*\n```\n\n### Validate the Project\nValidate that your project works correctly:\n\n```bash\n# Create a scratch org\nsf org create scratch --definition-file config/project-scratch-def.json --alias testorg\n\n# Deploy to scratch org\nsf project deploy start --target-org testorg\n\n# Run tests\nsf apex run test --target-org testorg --code-coverage --synchronous\n```\n\n## Troubleshooting\n\n### Common Issues\n1. **Profile Errors**: Profiles often contain references to components that don't exist in the project. Consider using permission sets instead.\n\n```bash\n# Retrieve just the permission sets\nsf project retrieve start --target-org sourceOrg --metadata-path force-app -m \"PermissionSet\"\n```\n\n2. **Missing Dependencies**: Install required packages before deploying:\n\n```bash\nsf package install --package packageId --target-org orgAlias\n```\n\n3. **API Version Mismatches**: Ensure consistent API versions:\n\n```bash\n# Update project's API version in sfdx-project.json\n\"sourceApiVersion\": \"58.0\"\n```\n\n## Further Reading\nFor more information about creating a Salesforce DX project from existing source, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_convert_mdapi.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/create_project_from_existing_source.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/create_salesforce_dx_project.md",
      "content": "---\ndescription: Create a new Salesforce DX Project\nglobs: \nalwaysApply: false\n---\nCreate a Salesforce DX Project\n\nA Salesforce DX project has a specific structure and a configuration file that identifies the directory as a Salesforce DX project.\n\nChange to the directory where you want the DX project located.\nCreate the DX project.\n\n`sf project generate --name MyProject`\n\nIf you don’t specify an output directory with the --output-dir flag, the project directory is created in the current location. You can also use the --default-package-dir flag to specify the default package directory to target when syncing source to and from the org. If you don’t indicate a default package directory, this command creates a default package directory, force-app.\n\nUse the --template flag to specify what your project initially looks like. Each template provides a complete directory structure that takes the guesswork out of where to put your source. If you choose --template empty, your project contains these sample configuration files to get you started.\n\n.forceignore\nconfig/project-scratch-def.json\nsfdx-project.json\npackage.json\n\nIf you choose --template standard, your project also contains these files that are especially helpful when using Salesforce Extensions for VS Code. If you don’t specify the --template flag, the project generate command uses the standard template.\n\n.gitignore: Makes it easier to start using Git for version control.\n.prettierrc and .prettierignore: Make it easier to start using Prettier to format your Aura components.\n.vscode/extensions.json: Causes Visual Studio Code, when launched, to prompt you to install the recommended extensions for your project.\n.vscode/launch.json: Configures Replay Debugger, making it more discoverable and easier to use.\n.vscode/settings.json: By default, this file has one setting for excluding certain files and folders in searches and quick open. You can change this value or add other settings.\n\nIf you choose --template analytics, you get all the helpful basic and VS Code files. But the default package directory contains fewer directories, such as for storing Analytics template bundles. /force-app/main/default/waveTemplates) and a few other metadata types, such as Apex classes and LWC components.\n\nSource:\nhttps://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_create_new.htm",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/create_salesforce_dx_project.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/decomposed_metadata_types.md",
      "content": "---\ndescription: Understanding decomposed metadata types in Salesforce DX source format\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding decomposed metadata types in Salesforce DX source format\nglobs: \nalwaysApply: false\n---\n# Decomposed Metadata Types\n\n## Overview\nIn Salesforce DX, metadata types are \"decomposed\" into smaller, more manageable components in the source format. This decomposition allows for better version control and more granular deployments. This rule explains how metadata types are broken down in the source format.\n\n## Understanding Decomposition\n\n### Metadata API vs. Source Format\n- **Metadata API Format**: Stores most metadata in large XML files (e.g., one file for all fields of an object)\n- **Source Format**: Breaks down metadata into individual files and directories (e.g., one file per field)\n\n### Benefits of Decomposition\n- More granular version control\n- Easier merge conflict resolution\n- More precise deployments\n- Better organization of source files\n- Improved developer collaboration\n\n## Common Decomposed Metadata Types\n\n### Custom Objects\nCustom objects are decomposed into:\n\n```\nforce-app/main/default/objects/MyObject__c/\n  ├── MyObject__c.object-meta.xml       # Object definition\n  ├── fields/                           # Fields directory\n  │   ├── Field1__c.field-meta.xml\n  │   └── Field2__c.field-meta.xml\n  ├── listViews/                        # List Views directory\n  │   ├── All.listView-meta.xml\n  │   └── Recent.listView-meta.xml\n  ├── validationRules/                  # Validation Rules directory\n  │   └── Rule1.validationRule-meta.xml\n  ├── webLinks/                         # Web Links directory\n  │   └── Link1.webLink-meta.xml\n  ├── compactLayouts/                   # Compact Layouts directory\n  │   └── Layout1.compactLayout-meta.xml\n  └── recordTypes/                      # Record Types directory\n      └── Type1.recordType-meta.xml\n```\n\n### Profiles\nProfiles are optionally decomposed:\n\n```\nforce-app/main/default/profiles/\n  └── Admin.profile-meta.xml            # Full profile in one file (standard format)\n\n# OR decomposed format\nforce-app/main/default/profiles/Admin/\n  ├── layout.profile-meta.xml           # Layout settings for the profile\n  ├── objectPermissions.profile-meta.xml # Object permissions\n  └── fieldPermissions.profile-meta.xml  # Field permissions\n```\n\n### Permission Sets\nPermission sets are decomposed similar to profiles:\n\n```\nforce-app/main/default/permissionsets/\n  └── MyPermSet.permissionset-meta.xml   # Standard format\n\n# OR decomposed format\nforce-app/main/default/permissionsets/MyPermSet/\n  ├── layout.permissionset-meta.xml\n  ├── objectPermissions.permissionset-meta.xml\n  └── fieldPermissions.permissionset-meta.xml\n```\n\n## Working with Decomposed Metadata\n\n### Retrieving Decomposed Metadata\nWhen retrieving metadata from an org, it's automatically decomposed:\n\n```bash\n# Retrieve a custom object - will be decomposed\nsf project retrieve start -m \"CustomObject:Account\"\n```\n\n### Deploying Decomposed Metadata\nWhen deploying, Salesforce DX automatically handles the decomposed structure:\n\n```bash\n# Deploy all components of an object\nsf project deploy start -p force-app/main/default/objects/MyObject__c\n```\n\n### Best Practices for Version Control\n1. Commit each metadata component separately when possible\n2. Create pull requests that focus on related metadata changes\n3. Review changes at the component level for better precision\n\n## Handling Special Cases\n\n### Bundle Types\nSome metadata types are stored as bundles:\n\n```\nforce-app/main/default/lwc/myComponent/     # LWC bundle\n  ├── myComponent.html\n  ├── myComponent.js\n  └── myComponent.js-meta.xml\n\nforce-app/main/default/aura/myComponent/    # Aura bundle\n  ├── myComponent.cmp\n  ├── myComponentController.js\n  ├── myComponentHelper.js\n  └── myComponent.cmp-meta.xml\n```\n\n### Partial Decomposition\nSome metadata types are only partially decomposed:\n\n```\nforce-app/main/default/layouts/\n  └── Account-Account Layout.layout-meta.xml  # Not decomposed\n\nforce-app/main/default/objects/Account/layouts/  # Alternative location (when decomposed)\n  └── Account_Layout.layout-meta.xml\n```\n\n## Converting Between Formats\n\n### Convert from Metadata API to Source Format\n```bash\n# Convert metadata API format to source format\nsf project convert mdapi:source -r mdapioutput/ -d force-app/\n```\n\n### Convert from Source Format to Metadata API\n```bash\n# Convert source format to metadata API format\nsf project convert source:mdapi -r force-app/ -d mdapioutput/\n```\n\n## Troubleshooting\n\n### Common Issues\n1. **Missing Components**: Check if components are stored in unexpected locations\n2. **Deployment Errors**: Ensure all dependent components are included in deployment\n3. **Merge Conflicts**: Handle conflicts at the component level, not the file level\n\n### Resolution Strategies\n1. Use `sf project retrieve start` to see how Salesforce organizes components\n2. Reference the [Metadata Coverage Report](mdc:https:/developer.salesforce.com/docs/metadata-coverage) for supported types\n3. Check both standard and decomposed locations for components\n\n## Further Reading\nFor more information about decomposed metadata types, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_source_file_format.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/decomposed_metadata_types.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/exclude_source_when_syncing.md",
      "content": "---\ndescription: \nglobs: \nalwaysApply: false\n---\n# Exclude Source When Syncing with Salesforce DX\n\n## Overview\nThe `.forceignore` file lets you exclude source files and directories from syncing operations between your local project and Salesforce orgs. This rule defines best practices for using `.forceignore` in Salesforce DX projects.\n\n## File Location\n- Place the `.forceignore` file in the root of your Salesforce DX project\n- You can also place additional `.forceignore` files in subdirectories to apply specific ignores to those directories\n\n## Format and Syntax\n- Uses same format as `.gitignore`\n- Each line contains a pattern for files to ignore\n- Blank lines are ignored\n- Lines starting with # are comments\n- Use ! to negate a previously defined pattern\n\n## Examples\n\n### Basic patterns\n```\n# Ignore specific files\n**/jsconfig.json\n**/.eslintrc.json\n\n# Ignore directories\n**/.sfdx\n**/node_modules\n\n# Ignore specific metadata type\n**/profiles\n\n# Exclude all Apex classes\n**/*.cls\n\n# But don't ignore the Test classes\n!**/*Test.cls\n```\n\n### Exclude Remote Changes\nTo prevent retrieving certain components, use the `-r` flag in your `.forceignore` file:\n```\n# Ignore in both directions\n**/profiles\n\n# Ignore only when retrieving from an org\n-r **/objects/Account\n```\n\n### Excluding MetadataWithContent Types\nFor metadata with content (like StaticResource, Document, ContentAsset):\n```\n# Ignore both metadata and content\n**/staticresources/MyResource.resource\n**/staticresources/MyResource.resource-meta.xml\n\n# Using wildcard\n**/staticresources/MyResource*\n```\n\n### Excluding Bundles\nFor bundles (like Aura, LWC, Experience):\n```\n# Ignore entire bundle\n**/aura/myComponent\n\n# Ignore specific files in bundle\n**/lwc/myComponent/myComponent.js\n**/lwc/myComponent/myComponent.html\n```\n\n### Handling Special Characters\nFor metadata with special characters in names:\n```\n# Escape special characters\n**/objects/My\\%Object__c\n```\n\n## Tips\n1. To view which files are ignored, use: `sf project ignore list`\n2. When in doubt about a file path, use `sf project retrieve` or `sf project deploy` with the `-n` flag to see which files would be included without performing the operation\n3. By default, `.git`, `.sf`, `.sfdx`, and `.sf/config/` are automatically ignored\n\n## Determining Exact File Paths\nTo identify the exact path of components to exclude:\n1. Use command: `sf project retrieve start -m \"YourMetadata\" -x manifest/package.xml`\n2. Look at retrieved files in the source directory\n3. Copy the file path relative to project root into `.forceignore`\n\n## Further Reading\nCheck [official documentation](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_exclude_source.htm) for additional details.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/exclude_source_when_syncing.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/link_namespace_to_dev_hub.md",
      "content": "---\ndescription: How to link a namespace to a Dev Hub org in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to link a namespace to a Dev Hub org in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Link a Namespace to a Dev Hub Org\n\n## Overview\nIn Salesforce DX, you can develop packages using namespaces to create unique identifiers across packages. This rule explains how to link an existing namespace to your Dev Hub org, which allows you to create and manage namespaced scratch orgs and second-generation packages.\n\n## Prerequisites\n- A Salesforce Dev Hub org\n- An existing namespace registered in a packaging org\n- Salesforce CLI installed\n- Admin access to both the Dev Hub org and the namespace org\n\n## Namespace Concepts\n\n### What is a Namespace?\n- A namespace is a unique identifier that differentiates your package and its components from other developers' packages\n- It appears as a prefix in component names, e.g., `namespace__CustomObject__c`\n- Required for managed packages but optional for unlocked packages\n- Can only be registered once and cannot be changed after registration\n\n### Types of Namespace Orgs\n1. **Packaging Org**: Contains your registered namespace\n2. **Dev Hub Org**: Used to create scratch orgs and packages\n3. **Linked Namespace Org**: When your namespace org is linked to your Dev Hub org\n\n## Linking a Namespace\n\n### Link Namespace Process\nLinking a namespace to your Dev Hub involves these steps:\n\n1. Authorize your Dev Hub org:\n```bash\nsf org login web --set-default-dev-hub --alias DevHub\n```\n\n2. Authorize your namespace org:\n```bash\nsf org login web --alias NamespaceOrg\n```\n\n3. Link the namespace to Dev Hub:\n```bash\nsf org link namespace --target-dev-hub DevHub --namespace YOUR_NAMESPACE --org NamespaceOrg\n```\n\n4. Verify the link:\n```bash\nsf org list namespace --target-dev-hub DevHub\n```\n\n### Understanding the Connection\n- The link is a one-to-one relationship\n- Each namespace can only be linked to one Dev Hub\n- A single Dev Hub can have multiple namespaces linked to it\n\n## Using a Linked Namespace\n\n### Create a Namespaced Scratch Org\nOnce linked, you can create scratch orgs with your namespace:\n\n```bash\nsf org create scratch --definition-file config/project-scratch-def.json --namespace YOUR_NAMESPACE --alias NamespacedScratch\n```\n\n### Create a Namespaced Package\nYou can create a second-generation package with your namespace:\n\n```bash\n# Define a package with namespace in sfdx-project.json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"package\": \"MyPackage\",\n      \"versionName\": \"Version 1.0\",\n      \"versionNumber\": \"1.0.0.NEXT\",\n      \"default\": true\n    }\n  ],\n  \"namespace\": \"YOUR_NAMESPACE\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n```bash\n# Create the package\nsf package create --name \"My Namespaced Package\" --description \"Package with namespace\" --package-type Managed --path force-app\n```\n\n### Working with Namespaced Components\nComponents in a namespaced org will automatically get the namespace prefix:\n\n```xml\n<!-- Creating a custom field in a namespaced scratch org -->\n<!-- Will be available as YOUR_NAMESPACE__CustomField__c -->\n<CustomField xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n    <fullName>CustomField__c</fullName>\n    <label>Custom Field</label>\n    <type>Text</type>\n</CustomField>\n```\n\n## Managing Namespace Links\n\n### List Linked Namespaces\nView namespaces linked to your Dev Hub:\n\n```bash\nsf org list namespace --target-dev-hub DevHub\n```\n\n### Remove a Namespace Link\nIf needed, remove the namespace link:\n\n```bash\nsf org unlink namespace --target-dev-hub DevHub --namespace YOUR_NAMESPACE\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **\"This namespace is already linked to another Dev Hub org\"**:\n   - A namespace can only be linked to one Dev Hub at a time\n   - Unlink from the existing Dev Hub first\n\n2. **\"You don't have permission to link this namespace\"**:\n   - Ensure you have admin rights in both orgs\n   - Check that you're using the correct namespace org\n\n3. **Permission Issues**:\n   - \"Namespace registry\" permission must be enabled in the Dev Hub\n   - \"Packaging\" permission must be enabled in the namespace org\n\n### Resolution Steps\n1. Verify permissions in both orgs\n2. Check that you're authenticated to both orgs\n3. Ensure the namespace exists in the org you're linking from\n\n## Best Practices\n\n1. **Use One Dev Hub**: Consolidate package development under a single Dev Hub org\n2. **Document Namespace Links**: Track which namespaces are linked to which Dev Hub\n3. **Named Credentials**: Use named credentials for service integrations to maintain namespace separation\n4. **Unique Package Names**: Use unique package names even across different namespaces\n5. **Naming Conventions**: Establish naming conventions that work well with namespace prefixes\n\n## Further Reading\nFor more information about linking namespaces to Dev Hub orgs, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_dev2gp_namespace_registry.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/link_namespace_to_dev_hub.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/manage_environments_config_variables.md",
      "content": "---\ndescription: Managing environment-specific configuration and variables in Salesforce DX projects\nglobs: \nalwaysApply: false\n---\n# Managing Environment Configuration and Variables\n\n## Overview\nWhen working with multiple environments in Salesforce DX, you need to manage different configurations for each environment. Salesforce DX provides tools to handle environment-specific variables and settings.\n\n## Configuration Files\n\n### 1. Project Configuration File\nThe `sfdx-project.json` file contains project-wide settings:\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n### 2. Scratch Org Definition Files\nStored in `config/` directory, these files define scratch org settings:\n```json\n// config/project-scratch-def.json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Developer\",\n  \"features\": [\"EnableSetPasswordInApi\"],\n  \"settings\": {\n    \"lightningExperienceSettings\": {\n      \"enableS1DesktopEnabled\": true\n    }\n  }\n}\n```\n\nCreate environment-specific definition files:\n- `config/project-scratch-def.json` (default)\n- `config/dev-scratch-def.json` (development)\n- `config/qa-scratch-def.json` (QA)\n\n## Environment Variables\n\n### Using Environment Variables\nSalesforce CLI supports environment variables for sensitive information and environment-specific settings.\n\n1. Set environment variables:\n```bash\n# Unix/Linux/macOS\nexport SFDX_DEV_HUB_AUTH_URL=myDevHubAuthUrl\n\n# Windows (Command Prompt)\nset SFDX_DEV_HUB_AUTH_URL=myDevHubAuthUrl\n\n# Windows (PowerShell)\n$env:SFDX_DEV_HUB_AUTH_URL=\"myDevHubAuthUrl\"\n```\n\n2. Use environment variables in scripts:\n```bash\nsf org login web --instance-url $SFDX_INSTANCE_URL\n```\n\n### Common Environment Variables\n- `SF_LOG_LEVEL`: Controls CLI logging level\n- `SF_TARGET_ORG`: Default username or alias for commands\n- `SF_INSTANCE_URL`: Default Salesforce instance URL\n- `SF_DEV_HUB`: Default Dev Hub org\n\n## Configuration Files for CI/CD\n\n### Environment-Specific Config\nCreate configuration files for different environments:\n\n```\nmyproject/\n  ├── config/\n  │   ├── project-scratch-def.json\n  │   ├── dev-settings.json\n  │   ├── staging-settings.json\n  │   └── prod-settings.json\n  └── scripts/\n      └── deploy.sh\n```\n\n### Sample Deployment Script\n```bash\n#!/bin/bash\nENVIRONMENT=$1\nCONFIG_FILE=\"./config/${ENVIRONMENT}-settings.json\"\n\nif [ -f \"$CONFIG_FILE\" ]; then\n  echo \"Deploying to $ENVIRONMENT using $CONFIG_FILE\"\n  # Use configuration file in deployment\n  sf project deploy start --source-dir force-app --target-org $ENVIRONMENT\nelse\n  echo \"Configuration for $ENVIRONMENT not found\"\n  exit 1\nfi\n```\n\n## Managing Secrets\n\n### Secure Handling of Credentials\n1. Store secrets in environment variables\n2. Use CI/CD platform's secret management\n3. Never commit secrets to version control\n\nExample GitHub Actions secret usage:\n```yaml\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: 'Deploy to Org'\n        run: sf project deploy start --target-org ${{ secrets.SF_TARGET_ORG }}\n        env:\n          SFDX_CLIENT_ID: ${{ secrets.SFDX_CLIENT_ID }}\n          SFDX_CLIENT_SECRET: ${{ secrets.SFDX_CLIENT_SECRET }}\n```\n\n## Best Practices\n1. Use environment variables for sensitive information\n2. Create environment-specific configuration files\n3. Parameterize deployment scripts\n4. Use CI/CD platform's secret management\n5. Document required variables for each environment\n6. Keep consistent naming conventions across environments\n7. Validate configurations before deployment\n\n## Further Reading\nFor more information, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_env_variables.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/manage_environments_config_variables.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/multiple_package_directories.md",
      "content": "---\ndescription: How to work with multiple package directories in Salesforce DX projects\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to work with multiple package directories in Salesforce DX projects\nglobs: \nalwaysApply: false\n---\n# Multiple Package Directories\n\n## Overview\nSalesforce DX supports organizing your project into multiple package directories, allowing for modular development, easier dependency management, and improved team collaboration. This rule explains how to configure and work with multiple package directories in your Salesforce DX project.\n\n## Understanding Package Directories\n\n### What is a Package Directory?\n- A directory in your project that contains source files for a package\n- Defined in the `packageDirectories` array in `sfdx-project.json`\n- Can represent a standalone package or a module of a larger application\n- Each directory can be deployed independently or as part of a larger project\n\n### Benefits of Multiple Package Directories\n- **Modular Development**: Separate your application into logical modules\n- **Dependency Management**: Define explicit dependencies between components\n- **Team Collaboration**: Different teams can work on different packages\n- **Release Management**: Release packages independently or together\n- **Code Reuse**: Share common components across multiple packages\n\n## Configuring Multiple Package Directories\n\n### Basic Configuration\nTo define multiple package directories, edit your `sfdx-project.json` file:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"core-app\",\n      \"default\": true,\n      \"package\": \"Core\",\n      \"versionName\": \"Core v1.0\",\n      \"versionNumber\": \"1.0.0.NEXT\"\n    },\n    {\n      \"path\": \"feature-module\",\n      \"package\": \"Feature\",\n      \"versionName\": \"Feature v1.0\",\n      \"versionNumber\": \"1.0.0.NEXT\",\n      \"dependencies\": [\n        {\n          \"package\": \"Core\",\n          \"versionNumber\": \"1.0.0.LATEST\"\n        }\n      ]\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n### Directory Structure\nExample project structure with multiple package directories:\n\n```\nmy-sfdx-project/\n├── core-app/                 # Core package directory\n│   └── main/\n│       └── default/\n│           ├── classes/\n│           └── objects/\n├── feature-module/           # Feature package directory\n│   └── main/\n│       └── default/\n│           ├── classes/\n│           └── lwc/\n├── config/                   # Project configuration\n│   └── project-scratch-def.json\n└── sfdx-project.json         # Project definition\n```\n\n### Setting the Default Package Directory\nThe `default` property determines which directory is used when no directory is specified:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"core-app\",\n      \"default\": true\n    },\n    {\n      \"path\": \"feature-module\"\n    }\n  ]\n}\n```\n\n## Working with Multiple Package Directories\n\n### Creating Source in Different Directories\nTo create a source file in a specific directory:\n\n```bash\n# Create an Apex class in the core-app directory\nsf apex generate class --class-name CoreClass --output-dir core-app/main/default/classes\n\n# Create an Apex class in the feature-module directory\nsf apex generate class --class-name FeatureClass --output-dir feature-module/main/default/classes\n```\n\n### Deploying Specific Directories\nDeploy directories individually or together:\n\n```bash\n# Deploy just the core-app directory\nsf project deploy start --source-dir core-app\n\n# Deploy just the feature-module directory\nsf project deploy start --source-dir feature-module\n\n# Deploy both directories\nsf project deploy start --source-dir core-app,feature-module\n```\n\n### Retrieving to Specific Directories\nRetrieve metadata to a specific directory:\n\n```bash\n# Retrieve to the core-app directory\nsf project retrieve start --source-dir core-app -m \"CustomObject:Account\"\n\n# Retrieve to the feature-module directory\nsf project retrieve start --source-dir feature-module -m \"LightningComponentBundle:myComponent\"\n```\n\n## Package Directory Dependencies\n\n### Defining Dependencies\nSpecify dependencies between packages:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"core-app\",\n      \"package\": \"CorePackage\",\n      \"versionNumber\": \"1.0.0.NEXT\",\n      \"default\": true\n    },\n    {\n      \"path\": \"feature-module\",\n      \"package\": \"FeaturePackage\",\n      \"versionNumber\": \"1.0.0.NEXT\",\n      \"dependencies\": [\n        {\n          \"package\": \"CorePackage\",\n          \"versionNumber\": \"1.0.0.LATEST\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Installing Package Dependencies\nInstall dependencies when creating scratch orgs:\n\n```bash\n# Create a scratch org\nsf org create scratch --definition-file config/project-scratch-def.json --alias MyScratchOrg\n\n# Install the core package\nsf package install --package CorePackage@1.0.0.1 --target-org MyScratchOrg\n\n# Then install the feature package\nsf package install --package FeaturePackage@1.0.0.1 --target-org MyScratchOrg\n```\n\n## Common Use Cases\n\n### Shared Library Pattern\nCreate a shared library of components that multiple packages can use:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"shared-lib\",\n      \"package\": \"SharedLib\",\n      \"versionNumber\": \"1.0.0.NEXT\"\n    },\n    {\n      \"path\": \"app-one\",\n      \"dependencies\": [\n        {\n          \"package\": \"SharedLib\",\n          \"versionNumber\": \"1.0.0.LATEST\"\n        }\n      ]\n    },\n    {\n      \"path\": \"app-two\",\n      \"dependencies\": [\n        {\n          \"package\": \"SharedLib\",\n          \"versionNumber\": \"1.0.0.LATEST\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Feature Branch Development\nUse different directories for feature branches:\n\n```\nmy-sfdx-project/\n├── core-app/                  # Core functionality\n├── feature-branch-a/          # Feature A development\n├── feature-branch-b/          # Feature B development\n└── sfdx-project.json\n```\n\n### Environment-Specific Configuration\nSeparate environment-specific configurations:\n\n```\nmy-sfdx-project/\n├── base-app/                  # Base application\n├── dev-config/                # Development-specific configurations\n├── test-config/               # Test-specific configurations\n├── prod-config/               # Production-specific configurations\n└── sfdx-project.json\n```\n\n## Best Practices\n\n1. **Logical Separation**: Divide your project into logically related components\n2. **Minimize Dependencies**: Keep dependencies between packages to a minimum\n3. **Consistent Structure**: Use consistent directory structures across packages\n4. **Document Dependencies**: Clearly document package dependencies\n5. **Version Control**: Consider using Git submodules for shared packages\n\n### Recommended Package Structure\nFor each package directory:\n\n```\npackage-directory/\n├── main/\n│   └── default/\n│       ├── classes/          # Apex classes\n│       ├── objects/          # Custom objects\n│       ├── lwc/              # Lightning Web Components\n│       ├── aura/             # Aura components\n│       └── ...\n├── README.md                 # Package documentation\n└── scripts/                  # Package-specific scripts\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Deployment Order Issues**:\n   - Deploy packages in the correct order based on dependencies\n   - Use `sf project deploy start --source-dir dir1,dir2 --test-level RunLocalTests`\n\n2. **Dependency Conflicts**:\n   - Ensure package versions are compatible\n   - Check for duplicate component names across packages\n\n3. **Package Version Issues**:\n   - Use explicit version numbers for stable dependencies\n   - Use `LATEST` only for development\n\n### Validation Command\nValidate your package configuration:\n\n```bash\n# Validate project configuration\nsf project validate\n```\n\n## Further Reading\nFor more information about working with multiple package directories, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_create_pkg.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/multiple_package_directories.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/project_configuration_file.md",
      "content": "---\ndescription: Understanding and configuring the Salesforce DX Project Configuration File (sfdx-project.json)\nglobs: \nalwaysApply: false\n---\n# Salesforce DX Project Configuration File\n\n## Overview\nThe `sfdx-project.json` file is a key configuration file that defines project settings for Salesforce DX development. It contains information about your package directories, namespace, and other project-specific configurations.\n\n## File Location\n- Always located in the root directory of your Salesforce DX project\n\n## Basic Structure\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n## Key Elements\n\n### Package Directories\n- Defines the directories that contain your package source\n- The `default` attribute identifies the default directory for source operations\n- You can include multiple package directories for modular development\n\n```json\n\"packageDirectories\": [\n  {\n    \"path\": \"force-app\",\n    \"default\": true,\n    \"package\": \"MyPackage\",\n    \"versionName\": \"Version 1.0\",\n    \"versionNumber\": \"1.0.0.NEXT\"\n  },\n  {\n    \"path\": \"my-feature\",\n    \"default\": false\n  }\n]\n```\n\n### Namespace\n- Specifies the namespace prefix for your package\n- Leave blank for projects without a namespace\n\n### Source API Version\n- Specifies the Salesforce API version to use for source operations\n- Should be updated when you want to use features from newer API versions\n\n### Login URL\n- Specifies the default login URL\n- Can be set to different values for production (`https://login.salesforce.com`) or sandbox (`https://test.salesforce.com`)\n\n## Package Configuration\nFor package development, additional configuration is required:\n\n```json\n\"packageDirectories\": [\n  {\n    \"path\": \"force-app\",\n    \"default\": true,\n    \"package\": \"MyPackage\",\n    \"versionName\": \"Version 1.0\",\n    \"versionNumber\": \"1.0.0.NEXT\",\n    \"ancestorVersion\": \"1.0.0.LATEST\",\n    \"unpackagedMetadata\": {\n      \"path\": \"unpackaged\"\n    }\n  }\n]\n```\n\n## CLI Commands for Project Configuration\n- View project details: `sf project display`\n- Update API version: `sf project update api`\n\n## Best Practices\n1. Keep the configuration file in version control\n2. Update the API version regularly to access new features\n3. Use meaningful package and version names\n4. For multi-package projects, clearly organize package directories \n\n## Further Reading\nFor detailed information, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_config.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/project_configuration_file.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/replace_strings_in_code.md",
      "content": "---\ndescription: How to replace strings in code before deploying or packaging in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to replace strings in code before deploying or packaging in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Replace Strings in Code Before Deploying or Packaging\n\n## Overview\nSalesforce DX allows you to define string replacements in your `sfdx-project.json` file. These replacements are applied when you deploy or create package versions, enabling you to use environment-specific values without hardcoding them in your source files. This rule explains how to configure and use string replacements in your Salesforce DX projects.\n\n## String Replacement Concepts\n\n### Use Cases for String Replacements\n- Different API endpoints for development vs. production\n- Environment-specific URLs\n- Org-specific IDs or settings\n- Feature toggles\n- Version-specific values\n- Adapting code to different customer installations\n\n### How String Replacements Work\n- Defined in the `sfdx-project.json` file\n- Applied at deployment time or when creating package versions\n- Original source files remain unchanged\n- Replacements occur in-memory during deployment/packaging\n\n## Configuring String Replacements\n\n### Basic Configuration\nAdd a `replacements` section to your package directory in `sfdx-project.json`:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true,\n      \"package\": \"MyPackage\",\n      \"versionName\": \"Version 1.0\",\n      \"versionNumber\": \"1.0.0.NEXT\",\n      \"replacements\": [\n        {\n          \"filename\": \"classes/*.cls\",\n          \"stringToReplace\": \"@API_VERSION@\",\n          \"replaceWithString\": \"58.0\"\n        }\n      ]\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\"\n}\n```\n\n### Multiple Replacements\nYou can define multiple replacements:\n\n```json\n\"replacements\": [\n  {\n    \"filename\": \"classes/*.cls\",\n    \"stringToReplace\": \"@API_URL@\",\n    \"replaceWithString\": \"https://api.example.com/v1\"\n  },\n  {\n    \"filename\": \"classes/Constants.cls\",\n    \"stringToReplace\": \"@MAX_RECORDS@\",\n    \"replaceWithString\": \"100\"\n  },\n  {\n    \"filename\": \"lwc/**/*.js\",\n    \"stringToReplace\": \"@ENVIRONMENT@\",\n    \"replaceWithString\": \"PRODUCTION\"\n  }\n]\n```\n\n### Using File Patterns\nThe `filename` property supports glob patterns:\n\n- `classes/*.cls` - All Apex classes\n- `lwc/**/*.js` - All JavaScript files in LWC components\n- `**/Constants.*` - All files named Constants\n- `**/*Settings*.*` - All files with \"Settings\" in the name\n\n## Implementation Examples\n\n### Example: API Endpoint Configuration\nIn your source code (`ApiService.cls`):\n\n```java\npublic class ApiService {\n    private static final String API_ENDPOINT = '@API_ENDPOINT@';\n    \n    public static HttpResponse makeRequest() {\n        HttpRequest req = new HttpRequest();\n        req.setEndpoint(API_ENDPOINT + '/resource');\n        // Rest of the code\n    }\n}\n```\n\nIn your `sfdx-project.json`:\n\n```json\n\"replacements\": [\n  {\n    \"filename\": \"classes/ApiService.cls\",\n    \"stringToReplace\": \"@API_ENDPOINT@\",\n    \"replaceWithString\": \"https://api.example.com/v1\"\n  }\n]\n```\n\n### Example: Feature Flags\nIn your source code (`FeatureManager.cls`):\n\n```java\npublic class FeatureManager {\n    private static final Boolean ENABLE_NEW_FEATURE = @ENABLE_NEW_FEATURE@;\n    \n    public static Boolean isFeatureEnabled() {\n        return ENABLE_NEW_FEATURE;\n    }\n}\n```\n\nIn your `sfdx-project.json`:\n\n```json\n\"replacements\": [\n  {\n    \"filename\": \"classes/FeatureManager.cls\",\n    \"stringToReplace\": \"@ENABLE_NEW_FEATURE@\",\n    \"replaceWithString\": \"true\"\n  }\n]\n```\n\n### Example: LWC Configuration\nIn your source code (`config.js`):\n\n```javascript\nexport const CONFIG = {\n    apiVersion: '@API_VERSION@',\n    maxRecords: @MAX_RECORDS@,\n    environment: '@ENVIRONMENT@'\n};\n```\n\nIn your `sfdx-project.json`:\n\n```json\n\"replacements\": [\n  {\n    \"filename\": \"lwc/**/config.js\",\n    \"stringToReplace\": \"@API_VERSION@\",\n    \"replaceWithString\": \"58.0\"\n  },\n  {\n    \"filename\": \"lwc/**/config.js\",\n    \"stringToReplace\": \"@MAX_RECORDS@\",\n    \"replaceWithString\": \"50\"\n  },\n  {\n    \"filename\": \"lwc/**/config.js\",\n    \"stringToReplace\": \"@ENVIRONMENT@\",\n    \"replaceWithString\": \"PRODUCTION\"\n  }\n]\n```\n\n## Best Practices\n\n### Naming Conventions\nUse a consistent pattern for replacement tokens:\n\n- `@TOKEN_NAME@` - Makes tokens easily identifiable\n- `${TOKEN_NAME}` - Similar to environment variable syntax\n- `%%TOKEN_NAME%%` - Clearly distinguishes from regular text\n\n### Organize by Environment\nConsider organizing replacements by environment:\n\n```json\n\"replacements\": [\n  {\n    \"environment\": \"development\",\n    \"replacements\": [\n      {\n        \"filename\": \"classes/Config.cls\",\n        \"stringToReplace\": \"@ENV@\",\n        \"replaceWithString\": \"DEV\"\n      }\n    ]\n  },\n  {\n    \"environment\": \"production\",\n    \"replacements\": [\n      {\n        \"filename\": \"classes/Config.cls\",\n        \"stringToReplace\": \"@ENV@\",\n        \"replaceWithString\": \"PROD\"\n      }\n    ]\n  }\n]\n```\n\n### Documentation\nDocument your replacements and their purpose:\n\n```json\n\"replacements\": [\n  {\n    \"description\": \"API endpoint for integration\",\n    \"filename\": \"classes/ApiService.cls\",\n    \"stringToReplace\": \"@API_ENDPOINT@\",\n    \"replaceWithString\": \"https://api.example.com/v1\"\n  }\n]\n```\n\n### Security Considerations\n- Don't use replacements for secrets or credentials\n- Be cautious with sensitive values like API keys\n- Consider using named credentials instead for secure endpoints\n\n## Deployment with Replacements\n\n### Deploying to a Scratch Org\nWhen deploying to a scratch org, replacements are automatically applied:\n\n```bash\nsf project deploy start --source-dir force-app\n```\n\n### Creating Package Versions\nWhen creating package versions, replacements are applied:\n\n```bash\nsf package version create --package \"MyPackage\" --installation-key test1234 --wait 10\n```\n\n### Verifying Replacements\nTo test your replacements:\n\n1. Deploy to a scratch org\n2. View the deployed files in the Developer Console\n3. Verify the replacements were made correctly\n\n## Troubleshooting\n\n### Common Issues\n1. **Replacements Not Applied**:\n   - Check file patterns match your files\n   - Verify exact string match, including whitespace\n   - Ensure your project structure matches the paths\n\n2. **Incorrect Replacements**:\n   - Check for token name collisions\n   - Verify the replacement string doesn't contain unexpected characters\n\n3. **Package Version Issues**:\n   - Validate replacements before creating packages\n   - Test package installation in a scratch org\n\n### Debugging String Replacements\nTo debug string replacements:\n\n```bash\n# Enable trace logging\nsf config set logLevel=trace --global\n\n# Deploy to see detailed logs\nsf project deploy start --source-dir force-app\n```\n\n## Further Reading\nFor more information about replacing strings in code, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_build_string_replace.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/replace_strings_in_code.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/sample_repository_on_github.md",
      "content": "---\ndescription: How to use the sample Salesforce DX repositories on GitHub for learning and reference\nglobs: \nalwaysApply: false\n---\n---\ndescription: How to use the sample Salesforce DX repositories on GitHub for learning and reference\nglobs: \nalwaysApply: false\n---\n# Sample Repository on GitHub\n\n## Overview\nSalesforce provides sample repositories on GitHub that demonstrate best practices for Salesforce DX project setup and development workflows. These repositories serve as references and starting points for your own projects.\n\n## Key Sample Repositories\n\n### Salesforce DX Examples Repository\nThe official Salesforce DX examples repository contains sample applications and configurations:\n\n```bash\n# Clone the repository\ngit clone https://github.com/forcedotcom/sfdx-simple.git\ncd sfdx-simple\n```\n\nThis repository includes:\n- Basic project structure\n- Sample configuration files\n- CI/CD examples\n- Sample metadata\n\n### Dreamhouse Application\nThe Dreamhouse app is a comprehensive sample that demonstrates Salesforce DX capabilities:\n\n```bash\n# Clone the repository\ngit clone https://github.com/dreamhouseapp/dreamhouse-sfdx.git\ncd dreamhouse-sfdx\n```\n\nThis application includes:\n- Complete application with Lightning components\n- Apex classes and triggers\n- Permission sets and profiles\n- Sample data\n\n## Exploring a Sample Repository\n\n### 1. Review Project Structure\nExplore the repository structure to understand the standard organization:\n\n```bash\n# List the files in the repository\nls -la\n\n# Examine the configuration files\ncat sfdx-project.json\ncat config/project-scratch-def.json\n```\n\n### 2. Create a Scratch Org from the Sample\nTest the sample by creating a scratch org:\n\n```bash\n# Create a scratch org\nsf org create scratch -f config/project-scratch-def.json -a SampleOrg\n\n# Push the source to the scratch org\nsf project deploy start\n```\n\n### 3. Import Sample Data (if provided)\nSome repositories include sample data:\n\n```bash\n# Import data using data plan\nsf data import tree -p data/data-plan.json\n```\n\n## Using Samples as Templates\n\n### Create a New Project Based on a Sample\nYou can use a sample as a starting point for your own project:\n\n```bash\n# Clone the sample repository\ngit clone https://github.com/forcedotcom/sfdx-simple.git my-new-project\ncd my-new-project\n\n# Remove the original Git history\nrm -rf .git\n\n# Initialize a new Git repository\ngit init\ngit add .\ngit commit -m \"Initial commit based on sfdx-simple template\"\n```\n\n### Customize the Project Configuration\nModify the project configuration for your needs:\n\n1. Edit `sfdx-project.json` to update the name and package directories\n2. Modify `config/project-scratch-def.json` to match your requirements\n3. Update any sample code or metadata to match your project needs\n\n## Learning from Sample Implementation\n\n### Code Organization\nStudy how the samples organize their code:\n- Directory structure\n- Naming conventions\n- Metadata organization\n\n### Deploy and Development Workflow\nExamine the deployment scripts and workflows:\n- CI/CD configuration (in `.github` or similar directories)\n- Scratch org creation scripts\n- Data import/export utilities\n\n### Testing Approach\nReview testing patterns:\n- Test class organization\n- Test data setup\n- Mocking and test utilities\n\n## Best Practices from Samples\n\n1. Follow the organized directory structure for your metadata\n2. Adopt the naming conventions demonstrated in the samples\n3. Implement similar CI/CD approaches for your own projects\n4. Use the scratch org definition files as templates\n5. Leverage the data imown data\n\n## Further Reading\nFor more information about Salesforce DX samples and repositories, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_sample_app.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/sample_repository_on_github.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/setup_for_package_development.md",
      "content": "---\ndescription: Setting up your project for package development in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Setting Up for Package Development\n\n## Overview\nPackage development in Salesforce DX allows you to organize your code into modular, versioned packages. This approach supports modern application lifecycle management and enables better organizational practices.\n\n## Package Types\nSalesforce DX supports several package types:\n- **Unlocked Packages**: Upgradeable and not namespace-bound\n- **Second-Generation Managed Packages**: Upgradeable, namespace-bound, with IP protection\n- **First-Generation Managed Packages**: Legacy package type (not recommended for new development)\n\n## Prerequisites\nBefore setting up for package development:\n1. Enable Dev Hub in your production org\n2. Install Salesforce CLI\n3. Enable Package Development in Dev Hub (for 2GP)\n4. Optionally, register a namespace\n\n## Project Setup\n\n### 1. Create a Project with Package Configuration\n```bash\nsf project generate --name MyPackageProject\n```\n\n### 2. Configure the Project for Packaging\nEdit the `sfdx-project.json` file:\n\n```json\n{\n  \"packageDirectories\": [\n    {\n      \"path\": \"force-app\",\n      \"default\": true,\n      \"package\": \"MyPackage\",\n      \"versionName\": \"Version 1.0\",\n      \"versionNumber\": \"1.0.0.NEXT\"\n    }\n  ],\n  \"namespace\": \"\",\n  \"sfdcLoginUrl\": \"https://login.salesforce.com\",\n  \"sourceApiVersion\": \"58.0\",\n  \"packageAliases\": {}\n}\n```\n\n### 3. Create a Package\n```bash\nsf package create --name \"My Package\" --description \"My package description\" --package-type Unlocked --path force-app\n```\n\nThe command adds the package ID to the `packageAliases` section of your `sfdx-project.json` file.\n\n## Package Versioning\n\n### Create a Package Version\n```bash\nsf package version create --package \"My Package\" --installation-key password --wait 10\n```\n\n### List Package Versions\n```bash\nsf package version list\n```\n\n### Promote a Package Version\n```bash\nsf package version promote --package \"My Package@1.0.0-1\"\n```\n\n## Dependency Management\n\n### Adding Package Dependencies\nTo add a dependency on another package, modify the `sfdx-project.json`:\n\n```json\n\"packageDirectories\": [\n  {\n    \"path\": \"force-app\",\n    \"default\": true,\n    \"package\": \"MyPackage\",\n    \"versionName\": \"Version 1.0\",\n    \"versionNumber\": \"1.0.0.NEXT\",\n    \"dependencies\": [\n      {\n        \"package\": \"DependencyPackage\",\n        \"versionNumber\": \"1.0.0.LATEST\"\n      }\n    ]\n  }\n]\n```\n\n## Best Practices\n1. Plan your package structure before development\n2. Use a source control system for your project\n3. Create separate scratch orgs for development and testing\n4. Implement CI/CD for automated testing and deployment\n5. Follow semantic versioning for package versions\n6. Document dependencies and installation requirements\n7. Keep packages focused and modular\n\n## Common Commands\n- Create package: `sf package create`\n- Create package version: `sf package version create`\n- List packages: `sf package list`\n- Install package: `sf package install`\n- Uninstall package: `sf package uninstall`\n\n## Further Reading\nFor detailed information about package development, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_dev2gp.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/setup_for_package_development.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/source_driven_development.md",
      "content": "---\ndescription: Understanding source-driven development concepts and workflows in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Source-Driven Development in Salesforce DX\n\n## Overview\nSource-driven development is a core concept in Salesforce DX that shifts the source of truth from the org to your version control system. This approach improves team collaboration, release management, and overall development process.\n\n## Key Concepts\n\n### 1. Version Control as Source of Truth\n- Your version control system (Git, etc.) becomes the definitive source of truth\n- Changes are pushed to orgs rather than pulled from them\n- Promotes better collaboration and change tracking\n\n### 2. Source Format\n- Salesforce DX uses a specific file-based format for metadata\n- Source is organized hierarchically by metadata type\n- Includes both code and metadata in text format\n\n### 3. Source Tracking\n- Salesforce DX tracks changes between your local project and scratch orgs\n- Helps identify what has changed locally vs. in the org\n- Facilitates selective deployment of changes\n\n## Source-Driven Workflow\n\n### Development Flow\n1. **Clone repository**: Start with existing code from version control\n2. **Create scratch org**: Provision a fresh org for development\n3. **Push source**: Deploy local code to the scratch org\n4. **Make changes**: Develop and test in the scratch org\n5. **Pull changes**: Retrieve org changes to local project\n6. **Commit changes**: Save to version control\n7. **Create pull request**: Request code review\n8. **Merge and deploy**: Integrate and deploy to higher environments\n\n### Command Sequence\n```bash\n# Clone repository\ngit clone https://github.com/myuser/my-sfdc-project.git\ncd my-sfdc-project\n\n# Create scratch org\nsf org create scratch -f config/project-scratch-def.json -a DevOrg\n\n# Push source to scratch org\nsf project deploy start\n\n# Make changes in the org or locally\n\n# Pull changes from org to local project\nsf project retrieve start\n\n# Track changes\nsf project track\n\n# Commit changes\ngit add .\ngit commit -m \"Feature implementation\"\ngit push origin feature-branch\n```\n\n## Managing Source\n\n### Pushing Source\n- Deploy local source to an org:\n  ```bash\n  sf project deploy start\n  ```\n- Deploy specific components:\n  ```bash\n  sf project deploy start --source-dir force-app/main/default/classes\n  ```\n\n### Retrieving Source\n- Pull changes from an org:\n  ```bash\n  sf project retrieve start\n  ```\n- Retrieve specific components:\n  ```bash\n  sf project retrieve start --source-path force-app/main/default/classes\n  ```\n\n### Source Tracking\n- View tracked changes:\n  ```bash\n  sf project track\n  ```\n- View source status:\n  ```bash\n  sf project deploy preview\n  ```\n\n## Common Challenges and Solutions\n\n### Conflicts\n- When both local files and org have different changes:\n  1. Pull changes: `sf project retrieve start`\n  2. Resolve conflicts manually\n  3. Push resolved changes: `sf project deploy start`\n\n### Large Metadata Sets\n- For large or complex orgs:\n  1. Use package development model\n  2. Break metadata into smaller modules\n  3. Use .forceignore to exclude unnecessary files\n\n### Metadata Coverage Gaps\n- When some metadata types aren't supported in source format:\n  1. Use workarounds for specific metadata types\n  2. Leverage Metadata API for unsupported types\n  3. Check Metadata Coverage report: `sf doc metadata coverage report --output-file ./coverage.csv`\n\n## Best Practices\n1. Commit early and often to version control\n2. Use feature branches for development\n3. Create a fresh scratch org for each major feature\n4. Implement continuous integration for automated testing\n5. Use meaningful commit messages\n6. Leverage .forceignore to exclude unnecessary files\n7. Maintain a clean local workspace\n\n## Further Reading\nFor detailed information about source-driven development, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_develop.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/source_driven_development.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/source_format.md",
      "content": "---\ndescription: Understanding the Source Format in Salesforce DX projects\nglobs: \nalwaysApply: false\n---\n# Source Format in Salesforce DX\n\n## Overview\nSalesforce DX uses a source-driven development approach with a specific format for organizing metadata. Understanding this format is critical for effective development.\n\n## Source Format Structure\nThe source format is organized hierarchically:\n- Package directories (e.g., `force-app`)\n  - Main directory (usually `main`)\n    - Default directory (`default`)\n      - Metadata type directories (e.g., `classes`, `objects`, `lwc`)\n        - Individual metadata files and components\n\n## Standard Directory Structure\n```\nforce-app/\n  └── main/\n      └── default/\n          ├── applications/\n          ├── aura/\n          ├── classes/\n          ├── layouts/\n          ├── lwc/\n          ├── objects/\n          │   └── Account/\n          │       ├── Account.object-meta.xml\n          │       ├── fields/\n          │       ├── listViews/\n          │       └── validationRules/\n          ├── permissionsets/\n          ├── profiles/\n          ├── staticresources/\n          ├── tabs/\n          └── triggers/\n```\n\n## Metadata File Naming Conventions\n\n### Standard Metadata Files\n- Standard metadata files use the format: `<ComponentName>.<MetadataType>-meta.xml`\n- Example: `MyClass.cls-meta.xml` for Apex class metadata\n\n### Apex Classes\n- Apex class files have two parts:\n  - The class code: `MyClass.cls`\n  - The metadata file: `MyClass.cls-meta.xml`\n\n### Custom Objects\n- Object metadata: `CustomObject__c.object-meta.xml`\n- Fields: `CustomObject__c/fields/CustomField__c.field-meta.xml`\n- List Views: `CustomObject__c/listViews/MyView.listView-meta.xml`\n- Validation Rules: `CustomObject__c/validationRules/MyRule.validationRule-meta.xml`\n\n### Lightning Web Components\n- Lightning Web Components use a bundle structure:\n  ```\n  lwc/\n    └── myComponent/\n        ├── myComponent.html\n        ├── myComponent.js\n        ├── myComponent.js-meta.xml\n        ├── myComponent.css (optional)\n        └── myComponent.svg (optional)\n  ```\n\n### Aura Components\n- Aura components also use a bundle structure:\n  ```\n  aura/\n    └── myComponent/\n        ├── myComponent.cmp\n        ├── myComponent.cmp-meta.xml\n        ├── myComponentController.js\n        ├── myComponentHelper.js\n        ├── myComponent.css\n        ├── myComponent.design\n        └── myComponent.svg\n  ```\n\n## Working with Source Format\n\n### Convert from Metadata Format\n- To convert from metadata format to source format:\n  `sf project convert mdapi:source -r path/to/metadata -d path/to/source`\n\n### Convert to Metadata Format\n- To convert from source format to metadata format:\n  `sf project convert source:mdapi -r path/to/source -d path/to/metadata`\n\n## Source Tracking\n- Salesforce DX tracks changes to source files relative to the org\n- Use `sf project track` command to view tracked changes\n\n## Best Practices\n1. Adhere to the standard directory structure\n2. Keep metadata files and source files together\n3. Use conventional naming for clarity\n4. Organize large projects with multiple package directories\n5. Include only necessary metadata types in your project\n\n## Further Reading\nFor more details, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_source_file_format.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/source_format.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/test_string_replacements.md",
      "content": "---\ndescription: How to test string replacements in Salesforce DX code before deploying\nglobs: \nalwaysApply: false\n---\n# Test String Replacements\n\n## Overview\nAfter configuring string replacements in your Salesforce DX project, it's essential to test them before deploying to production environments. This rule outlines strategies and best practices for testing string replacements to ensure they're applied correctly and don't cause unexpected issues.\n\n## Why Test String Replacements?\n\n### Common String Replacement Issues\n- Incorrect replacements due to pattern matching errors\n- Syntax errors after replacement\n- Environment-specific bugs\n- Missing replacements\n- Performance issues with complex replacements\n- Compatibility issues across different org types\n\n### Benefits of Testing Replacements\n- Verify replacements work as expected\n- Catch issues before they reach production\n- Ensure compatibility across environments\n- Validate package behavior with replacements\n- Confirm correct file patterns are used\n\n## Local Testing Strategies\n\n### Using Scratch Orgs\nThe simplest way to test replacements is to deploy to a scratch org:\n\n```bash\n# Create a scratch org\nsf org create scratch --definition-file config/project-scratch-def.json --alias TestReplacements\n\n# Deploy source with replacements\nsf project deploy start --source-dir force-app --target-org TestReplacements\n```\n\nAfter deployment, check the deployed files:\n1. Use Developer Console to view deployed files\n2. Run tests in the scratch org\n3. Verify functionality that uses replaced values\n\n### Manual Verification\nManually validate deployed code:\n\n```bash\n# Deploy to scratch org\nsf project deploy start --source-dir force-app --target-org TestReplacements\n\n# Retrieve deployed code back to a different directory\nsf project retrieve start --source-dir deployed --target-org TestReplacements\n\n# Compare source and deployed files\n# Use diff tools like:\ndiff -r force-app deployed\n```\n\n### Verifying Apex Class Replacements\nFor Apex class replacements, create a simple test:\n\n```java\n@isTest\nprivate class StringReplacementsTest {\n    @isTest\n    static void testApiEndpoint() {\n        // Assuming you have a class with API_ENDPOINT that was replaced\n        // The value after deployment should match the replacement\n        System.assertEquals('https://api.example.com/v1', ApiService.getEndpoint());\n    }\n    \n    @isTest\n    static void testFeatureFlag() {\n        // Assuming you have a feature flag that was replaced\n        Boolean isEnabled = FeatureManager.isFeatureEnabled();\n        // The value should match your replacement (true in this example)\n        System.assertEquals(true, isEnabled);\n    }\n}\n```\n\n### Testing LWC Component Replacements\nFor Lightning Web Components:\n\n```javascript\n// In a test component\nimport { LightningElement } from 'lwc';\nimport { CONFIG } from 'c/config';\n\nexport default class TestConfigReplacements extends LightningElement {\n    connectedCallback() {\n        // Log replaced values to browser console for verification\n        console.log('API Version:', CONFIG.apiVersion);\n        console.log('Max Records:', CONFIG.maxRecords);\n        console.log('Environment:', CONFIG.environment);\n        \n        // You can also add asserts for Jest tests\n    }\n}\n```\n\n## Automated Testing\n\n### Create a Testing Script\nCreate a bash script to automate replacement testing:\n\n```bash\n#!/bin/bash\n# test-replacements.sh\n\n# Set up test org\nsf org create scratch --definition-file config/project-scratch-def.json --alias TestReplace\n\n# Deploy with replacements\nsf project deploy start --source-dir force-app --target-org TestReplace\n\n# Run tests\nsf apex run test --target-org TestReplace --tests StringReplacementsTest --code-coverage\n\n# Retrieve specific files to verify\nsf project retrieve start --source-dir deployed --target-org TestReplace -m \"ApexClass:ApiService,ApexClass:FeatureManager\"\n\n# Optional: Look for replacement tokens in deployed code\ngrep -r \"@\" deployed/\n```\n\n### CI/CD Pipeline Integration\nIntegrate replacement testing in your CI/CD pipeline:\n\n```yaml\n# Example GitHub Actions workflow\nname: Test String Replacements\n\non: [push, pull_request]\n\njobs:\n  test-replacements:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Install Salesforce CLI\n        run: |\n          npm install @salesforce/cli --global\n      - name: Authenticate Dev Hub\n        run: |\n          echo \"${{ secrets.SFDX_AUTH_URL }}\" > ./authfile\n          sf org login sfdx-url --sfdx-url-file ./authfile --alias devhub\n      - name: Create Scratch Org\n        run: |\n          sf org create scratch --definition-file config/project-scratch-def.json --alias test-org --duration-days 1\n      - name: Deploy with Replacements\n        run: |\n          sf project deploy start --source-dir force-app --target-org test-org\n      - name: Run Tests\n        run: |\n          sf apex run test --target-org test-org --code-coverage --result-format human\n```\n\n## Testing Different Replacement Scenarios\n\n### Testing Environment-Specific Replacements\nTest replacements across different environments:\n\n1. Create different scratch org definition files:\n```bash\n# Development environment\nsf org create scratch --definition-file config/dev-scratch-def.json --alias DevOrg\n\n# Production-like environment\nsf org create scratch --definition-file config/prod-scratch-def.json --alias ProdOrg\n```\n\n2. Use different replacement configurations:\n```bash\n# Create different project config files\ncp sfdx-project.json sfdx-project.dev.json\ncp sfdx-project.json sfdx-project.prod.json\n\n# Edit each with environment-specific replacements\n\n# Deploy with specific config\nSF_PROJECT_JSON=sfdx-project.dev.json sf project deploy start --source-dir force-app --target-org DevOrg\nSF_PROJECT_JSON=sfdx-project.prod.json sf project deploy start --source-dir force-app --target-org ProdOrg\n```\n\n### Testing Package Versions\nTest replacements in package versions:\n\n```bash\n# Create a package version with replacements\nsf package version create --package MyPackage --installation-key test1234 --wait 10\n\n# Install the package in a test org\nsf org create scratch --definition-file config/project-scratch-def.json --alias PackageTest\nsf package install --package MyPackage@latest --target-org PackageTest --installation-key test1234\n\n# Test the installed package\nsf apex run test --target-org PackageTest --code-coverage\n```\n\n## Best Practices for Testing Replacements\n\n### Specific Testing Guidelines\n1. **Test Each Replacement**: Create specific tests for each replacement token\n2. **Test Edge Cases**: Test with extreme values and special characters\n3. **Cross-Environment Testing**: Test in different org types (scratch, sandbox, production)\n4. **Test File Pattern Coverage**: Verify all files matching patterns are updated\n5. **Validate Syntax**: Ensure replacements don't introduce syntax errors\n\n### Useful Testing Tools\n- Diff tools to compare source and deployed files\n- Linting tools to validate syntax after replacement\n- Automated test runners\n- CI/CD platforms for continuous testing\n\n### Logging and Debugging\nEnable detailed logging for troubleshooting:\n\n```bash\n# Enable trace logging\nsf config set logLevel=trace --global\n\n# Check logs after deployment\nsf apex log get --target-org TestOrg\n```\n\n## Troubleshooting Common Issues\n\n### Replacements Not Applied\nIf replacements aren't being applied:\n\n1. Check package directory paths in `sfdx-project.json`\n2. Verify file patterns match your source files\n3. Ensure token syntax matches exactly\n4. Check for case sensitivity issues\n\n### Syntax Errors After Replacement\nIf replacements cause syntax errors:\n\n1. Check that replacement values are properly formatted for each file type\n2. Verify string replacements in code literals are properly escaped\n3. Test with smaller replacements first\n\n### Package Version Issues\nFor package version problems:\n\n1. Check package dependencies\n2. Verify replacements against package validation rules\n3. Test package installation in a clean org\n\n## Further Reading\nFor more information about testing string replacements, see the [Salesforce DX Developer Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_build_string_replace.htm) ",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/test_string_replacements.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/project_setup/usernames_and_orgs.md",
      "content": "---\ndescription: Understanding Salesforce DX Usernames and Orgs\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding Salesforce DX Usernames and Orgs\nglobs: \nalwaysApply: false\n---\n# Salesforce DX Usernames and Orgs\n\n## Overview\nSalesforce DX introduces a new approach to managing orgs and usernames for development. This rule explains how usernames work across different org types, how to manage them, and best practices for implementing a username strategy in your development process.\n\n## Types of Orgs in Salesforce DX\n\n### Dev Hub Org\n- Central org that manages scratch orgs\n- Used for creating and deleting scratch orgs\n- Can be a production org, Developer Edition, or trial org\n- Typically limited to one per team or project\n\n```bash\n# Authorize a Dev Hub org\nsf org login web --set-default-dev-hub --alias DevHub\n```\n\n### Scratch Orgs\n- Short-lived, disposable orgs\n- Created from your Dev Hub org\n- Can be created with specific configurations, features, and settings\n- Used for development, testing, and automation\n\n```bash\n# Create a scratch org\nsf org create scratch --definition-file config/project-scratch-def.json --alias MyScratchOrg\n```\n\n### Sandbox Orgs\n- Copies of production orgs\n- Used for testing, UAT, and staging\n- Created from your production org\n- Longer-lived than scratch orgs\n\n```bash\n# Authorize a sandbox org\nsf org login web --instance-url https://test.salesforce.com --alias MySandbox\n```\n\n### Production Orgs\n- Your live, customer-facing org\n- Used for final deployments and production releases\n- Typically has stricter security controls and change management\n\n```bash\n# Authorize a production org\nsf org login web --instance-url https://login.salesforce.com --alias Production\n```\n\n## Username Management\n\n### Username Format\n- Scratch org usernames are automatically generated unless specified\n- Follow the format: `username@example.com.orgname`\n- Org-specific domains help avoid conflicts between different orgs\n\n### Org Aliases\nAliases provide a convenient shorthand for referencing orgs:\n\n```bash\n# Set an alias for an existing authorized org\nsf alias set MyProdOrg=username@example.com\n\n# List all aliases\nsf alias list\n\n# Delete an alias\nsf alias unset MyProdOrg\n```\n\n### Default Username\nSet a default username to avoid specifying it in every command:\n\n```bash\n# Set default username for current project\nsf config set target-org=MyScratchOrg\n\n# Set default Dev Hub\nsf config set target-dev-hub=DevHub\n```\n\n## Managing Orgs and Authentication\n\n### View Authenticated Orgs\nList all orgs you're authenticated to:\n\n```bash\n# List all authorized orgs\nsf org list\n\n# View details of a specific org\nsf org display --target-org MyScratchOrg\n```\n\n### Organization Details\nView detailed information about an org:\n\n```bash\n# Get org details\nsf org display --target-org MyScratchOrg --verbose\n```\n\n### Logout from Orgs\nRemove authentication for orgs you're no longer using:\n\n```bash\n# Logout from a specific org\nsf org logout --target-org MyScratchOrg\n\n# Logout from all orgs\nsf org logout --all\n```\n\n## Username Strategy for Teams\n\n### Dev Hub Username Conventions\nFor the Dev Hub, consider a team-wide naming convention:\n\n```\nteam-devhub@yourcompany.com\n```\n\n### Scratch Org Username Conventions\nFor scratch orgs, include developer initials and purpose:\n\n```\n# Example format: dev-initials.purpose@project.scratchorg\njd.feature123@myproject.scratchorg\n```\n\n### Sandbox Username Conventions\nFor sandboxes, use consistent format to identify purpose:\n\n```\n# Format: username.sandbox-name@yourcompany.com.sandbox\ndeveloper1.qa@yourcompany.com.qa\ndeveloper1.uat@yourcompany.com.uat\n```\n\n## Automating Username Management\n\n### Configuration Files\nStore org and username configurations in your project:\n\n```bash\n# Create a local config file\nmkdir -p .sf\ntouch .sf/config.json\n```\n\nExample `.sf/config.json`:\n```json\n{\n  \"target-org\": \"MyScratchOrg\",\n  \"target-dev-hub\": \"DevHub\"\n}\n```\n\n### Scripting Org Creation\nAutomate org creation with scripts:\n\n```bash\n#!/bin/bash\n# Create a scratch org with predefined username\nsf org create scratch \\\n  --definition-file config/project-scratch-def.json \\\n  --username developer@example.com.scratch \\\n  --alias DevScratch \\\n  --duration-days 7\n```\n\n### CI/CD Integration\nFor CI/CD pipelines, use service accounts with clear naming:\n\n```\nci-user@yourproject.com\n```\n\n## Troubleshooting Username Issues\n\n### Common Problems\n\n1. **Username Already in Use**:\n   ```bash\n   # Use a more unique username\n   sf org create scratch --definition-file config/project-scratch-def.json --username unique-name@example.com.scratch\n   ```\n\n2. **Username Invalid Format**:\n   ```bash\n   # Ensure username is in email format\n   sf org create scratch --definition-file config/project-scratch-def.json --username validformat@example.com\n   ```\n\n3. **Authentication Issues**:\n   ```bash\n   # Refresh authentication\n   sf org logout --target-org ProblemOrg\n   sf org login web --alias ProblemOrg\n   ```\n\n### Debug Commands\n\nCheck current authentication:\n```bash\n# Show current user details\nsf org display --target-org MyScratchOrg\n```\n\n## Best Practices\n\n1. **Use Meaningful Aliases**: Create descriptive aliases for your orgs (e.g., `DevScratch`, `QASandbox`, etc.)\n2. **Document Username Strategy**: Include your username convention in your project README\n3. **Rotate Service Account Credentials**: Regularly update passwords for service accounts used in automated processes\n4. **Limit Org Access**: Only authenticate to orgs you actively need\n5. **Use Project-Specific Configuration**: Set local org defaults for each project\n\n## Further Reading\nFor more information about Salesforce DX usernames and orgs, see the [Salesforce DX Developer Guide](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_usernames_orgs.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/project_setup/usernames_and_orgs.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/sandboxes/authorize_your_production_org.md",
      "content": "---\ndescription:  How to authorize your production org for sandbox operations in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to authorize your production org for sandbox operations in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Authorize Your Production Org\n\n## Overview\nBefore creating or working with sandboxes in Salesforce DX, you must first authorize your production org. This rule provides guidance on authorizing your production organization to enable sandbox management.\n\n## Key Concepts\n- Production org authorization is required for sandbox operations\n- Web-based OAuth flow is recommended for production org authorization\n- Production orgs are identified with a \".\" suffix in alias names\n\n## Authorization Process\n### Using Web-Based OAuth Flow\n```bash\nsf org login web --instance-url https://login.salesforce.com --alias yourProdOrg\n```\n\n### Verifying Authorization\n```bash\nsf org list --all\n```\n\n## Important Notes\n- Always use the production org (not a sandbox) for creating and managing sandboxes\n- Ensure your user account has appropriate permissions to create sandboxes\n- Store your production org authentication for reuse in scripts and CI/CD pipelines\n\n## Best Practices\n1. Use a distinct alias for your production org (e.g., \"prodOrg\")\n2. Verify authorization before attempting sandbox operations\n3. For headless environments, consider using JWT-based authentication\n\n## Further Reading\n- [Salesforce CLI Authentication](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth.htm)\n- [Sandbox Management Permissions](https://help.salesforce.com/articleView?id=sf.create_test_instance.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/sandboxes/authorize_your_production_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/sandboxes/create_clone_refresh_sandbox.md",
      "content": "---\ndescription: How to create, clone, or refresh Salesforce sandboxes using Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create, clone, or refresh Salesforce sandboxes using Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Create, Clone, or Refresh a Sandbox\n\n## Overview\nThis rule explains how to create new sandboxes, clone existing ones, or refresh sandboxes using Salesforce DX. These operations are crucial for maintaining development and testing environments.\n\n## Key Concepts\n- **Create**: Build a new sandbox environment\n- **Clone**: Make a copy of an existing sandbox\n- **Refresh**: Update an existing sandbox with new data from production\n\n## Prerequisites\n- Production org authorization\n- Sandbox definition file (for non-interactive operations)\n- Appropriate permissions in the org\n\n## Creating a New Sandbox\n### Using CLI Command\n```bash\nsf org sandbox create --definition-file config/sandbox-def.json --async\n```\n\n### Monitoring Sandbox Creation\n```bash\nsf org sandbox create status --job-id <job_id>\n```\n\n## Cloning a Sandbox\nTo clone a sandbox, include the `cloneFrom` property in your definition file:\n```json\n{\n  \"sandboxName\": \"ClonedSandbox\",\n  \"licenseType\": \"DEVELOPER\",\n  \"description\": \"Cloned from DevSandbox\",\n  \"cloneFrom\": \"DevSandbox\",\n  \"autoActivate\": true\n}\n```\n\nThen create the sandbox using:\n```bash\nsf org sandbox create --definition-file config/clone-sandbox-def.json --async\n```\n\n## Refreshing a Sandbox\nRefreshing resets a sandbox with fresh data from production:\n\n```bash\nsf org sandbox refresh --name ExistingSandbox --async\n```\n\nOr using a definition file:\n```bash\nsf org sandbox refresh --definition-file config/refresh-sandbox-def.json --async\n```\n\n## Accessing a Sandbox\nAfter creation or refresh, you need to authorize to the sandbox:\n\n```bash\nsf org login web --instance-url https://test.salesforce.com --alias mySandbox\n```\n\n## Common Options\n- `--async`: Run the command asynchronously\n- `--definition-file`: Path to the sandbox definition file\n- `--name`: Name of the sandbox for refresh operations\n- `--job-id`: ID of the job for checking status\n\n## Best Practices\n1. Create sandboxes with descriptive names that indicate their purpose\n2. Use post-copy scripts to automate configuration after refresh\n3. Track sandbox definition files in version control\n4. Regularly refresh test environments with production data\n5. Monitor sandbox usage and limits in your org\n\n## Troubleshooting\n- If a sandbox creation fails, check the job status for error details\n- Ensure you have the necessary sandbox licenses available\n- Verify that the sandbox name is unique within your org\n\n## Further Reading\n- [Salesforce Sandbox Management](https://help.salesforce.com/articleView?id=sf.data_sandbox_manage.htm)\n- [Sandbox Post-Copy](https://help.salesforce.com/articleView?id=sf.data_sandbox_postcopy_script.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/sandboxes/create_clone_refresh_sandbox.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/sandboxes/create_sandbox_definition_file.md",
      "content": "---\ndescription: How to create and configure a sandbox definition file for Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and configure a sandbox definition file for Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Create a Sandbox Definition File\n\n## Overview\nA sandbox definition file is a JSON configuration file that specifies the settings for creating a Salesforce sandbox. This rule provides guidance on creating and configuring a sandbox definition file for use with Salesforce DX.\n\n## Key Concepts\n- Sandbox definition files are used to specify sandbox configuration\n- JSON format with specific properties to define sandbox characteristics\n- Can be used for both creating new and refreshing existing sandboxes\n\n## File Structure\nSandbox definition files have the following structure:\n```json\n{\n  \"sandboxName\": \"MySandbox\",\n  \"licenseType\": \"DEVELOPER\",\n  \"description\": \"Development environment for feature X\",\n  \"cloneFrom\": \"ExistingSandbox\",\n  \"autoActivate\": true,\n  \"apexClassId\": \"01p3X000000XXXXX\",\n  \"copyChatter\": false\n}\n```\n\n## Required and Optional Properties\n### Required Properties\n- `sandboxName`: Name of the sandbox (must be unique within the org)\n- `licenseType`: Type of sandbox (DEVELOPER, DEVELOPER_PRO, PARTIAL, FULL)\n\n### Optional Properties\n- `description`: Description of the sandbox\n- `cloneFrom`: Name of an existing sandbox to clone from\n- `autoActivate`: Whether to automatically activate the sandbox after creation\n- `apexClassId`: ID of an Apex class implementing the SandboxPostCopy interface\n- `copyChatter`: Whether to copy Chatter data to the sandbox\n\n## Example Definition Files\n### Basic Developer Sandbox\n```json\n{\n  \"sandboxName\": \"DevSandbox\",\n  \"licenseType\": \"DEVELOPER\",\n  \"description\": \"Development sandbox for testing\",\n  \"autoActivate\": true\n}\n```\n\n### Full Copy Sandbox with Post-Copy Script\n```json\n{\n  \"sandboxName\": \"FullQA\",\n  \"licenseType\": \"FULL\",\n  \"description\": \"Full QA environment\",\n  \"autoActivate\": true,\n  \"apexClassId\": \"01p3X000000XXXXX\"\n}\n```\n\n## Best Practices\n1. Store definition files in source control for reuse and tracking\n2. Create separate definition files for different sandbox purposes\n3. Use descriptive names and include details in the description\n4. Consider post-copy automation using Apex classes\n\n## Further Reading\n- [Salesforce Sandbox Types](https://help.salesforce.com/articleView?id=sf.data_sandbox_environments.htm)\n- [Post-Copy Scripts](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_interface_System_SandboxPostCopy.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/sandboxes/create_sandbox_definition_file.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/create_and_manage_org_shapes.md",
      "content": "---\ndescription: How to create, list, delete, and manage Org Shapes in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create, list, delete, and manage Org Shapes in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Create and Manage Org Shapes\n\n## Overview\nOrg Shapes allow you to capture the configuration and settings of an existing org for use in creating consistent Scratch Orgs. This guide explains how to create and manage Org Shapes using Salesforce CLI.\n\n## Key Concepts\n- Org Shapes are templates based on existing orgs\n- Multiple Org Shapes can be created and managed\n- Org Shapes are stored in the Dev Hub\n- Org Shapes can be listed, viewed, and deleted\n\n## Prerequisites\n- Org Shape feature enabled in your Dev Hub\n- Appropriate permissions to create and manage Org Shapes\n- Access to source orgs you want to capture\n\n## Creating Org Shapes\n\n### Capturing an Org Shape\nTo capture an Org Shape from an existing org:\n\n```bash\nsf org create shape -o SourceOrg\n```\n\n### Parameters\n- `-o, --target-org` - Username or alias of the source org\n- `-v, --target-dev-hub` - Username or alias of the Dev Hub org\n- `--async` - Run the command asynchronously\n- `--wait` - Number of minutes to wait for the shape capture to complete\n\n## Listing Org Shapes\n\n### View All Org Shapes\nTo list all available Org Shapes in your Dev Hub:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\n### Output Format\nThe list command returns information about each Org Shape, including:\n- Source Org ID\n- Creation Date\n- Status\n- Edition\n- Features\n\n## Using Org Shapes in Scratch Org Definition Files\nTo use an Org Shape in a Scratch Org definition file:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Enterprise\",\n  \"sourceOrg\": \"00Dxx0000000001EAA\",\n  \"hasSampleData\": false\n}\n```\n\n## Deleting Org Shapes\nTo delete an Org Shape when no longer needed:\n\n```bash\nsf org delete shape -o 00Dxx0000000001EAA -v DevHub\n```\n\n## Refreshing Org Shapes\nOrg Shapes are point-in-time snapshots. To update an Org Shape with the latest configuration:\n\n1. Delete the existing Org Shape\n2. Create a new Org Shape from the same source org\n\n## Common Management Tasks\n\n### Finding Org Shape Details\nTo get detailed information about a specific Org Shape:\n\n```bash\nsf org describe shape -o 00Dxx0000000001EAA -v DevHub\n```\n\n### Checking Org Shape Status\nTo verify if an Org Shape creation is complete:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\n## Best Practices\n1. Name your source orgs clearly to identify their purpose\n2. Document which Org Shapes are used for which development scenarios\n3. Periodically refresh Org Shapes to capture configuration changes\n4. Delete unused Org Shapes to maintain a clean environment\n5. Use consistent naming conventions for source orgs and Scratch Orgs\n6. Create Org Shapes for different environments (e.g., development, UAT, production)\n\n## Troubleshooting\n- If Org Shape creation fails, check permissions and connectivity\n- If a Scratch Org doesn't reflect the expected configuration, verify the Org Shape ID\n- For persistent issues, try recreating the Org Shape\n\n## Further Reading\n[Salesforce DX Developer Guide: Create and Manage Org Shapes](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_org_shape_create.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/create_and_manage_org_shapes.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/create_scratch_org_based_on_org_shape.md",
      "content": "---\ndescription: How to create a Scratch Org based on an existing org's shape\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create a Scratch Org based on an existing org's shape\nglobs: \nalwaysApply: false\n---\n# Create a Scratch Org Based on an Org Shape\n\n## Overview\nOrg Shape allows you to create Scratch Orgs that closely match the shape and configuration of an existing org. This ensures consistency between your development environment and production or sandbox orgs.\n\n## Key Concepts\n- Org Shape captures configuration, settings, and feature enablement from a source org\n- Org Shape Scratch Orgs inherit features and settings from the source org\n- Source orgs can be production orgs, sandboxes, or other Scratch Orgs\n- Org Shape requires special permissions in your Dev Hub\n\n## Prerequisites\n- Org Shape must be enabled in your Dev Hub\n- You must have the right permissions to create Org Shape Scratch Orgs\n- The source org must be accessible and authorized\n\n## Creating an Org Shape Scratch Org\n\n### Using the sourceOrg Parameter\nIn your Scratch Org definition file, specify the source org ID:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Enterprise\",\n  \"sourceOrg\": \"00Dxx0000000001EAA\",\n  \"hasSampleData\": false\n}\n```\n\n### Command to Create Org Shape Scratch Org\n```bash\nsf org create scratch -f config/org-shape-scratch-def.json -a OrgShapeScratch\n```\n\n## Source Org Authorization\nBefore creating an Org Shape Scratch Org, you need to authorize the source org:\n\n```bash\nsf org login web -a SourceOrg\n```\n\n## Overriding Source Org Settings\nYou can override specific settings from the source org in your definition file:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Enterprise\",\n  \"sourceOrg\": \"00Dxx0000000001EAA\",\n  \"features\": [\"Communities\"],\n  \"settings\": {\n    \"lightningExperienceSettings\": {\n      \"enableS1DesktopEnabled\": true\n    }\n  },\n  \"hasSampleData\": false\n}\n```\n\n## Checking Org Shape Status\nTo check if Org Shape is enabled and available:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\n## Benefits of Org Shape\n1. More accurate development environment that reflects production\n2. Simplified configuration management\n3. Reduced setup time when creating new Scratch Orgs\n4. Consistent testing environments that match production\n\n## Limitations\n- Not all settings and configurations are captured in Org Shape\n- Some features may not be completely replicated\n- Custom code and data are not included in Org Shape\n\n## Best Practices\n1. Use a stable source org to ensure consistency\n2. Document which org was used as the source\n3. Include the sourceOrg parameter in version-controlled definition files\n4. Test Org Shape Scratch Orgs to ensure they have the necessary configuration\n5. Consider creating multiple Org Shape definitions for different scenarios\n\n## Further Reading\n[Salesforce DX Developer Guide: Create a Scratch Org Based on an Org Shape](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_org_shape.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/create_scratch_org_based_on_org_shape.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/create_scratch_org_based_on_snapshot.md",
      "content": "---\ndescription: How to create a Scratch Org based on a previously captured snapshot\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create a Scratch Org based on a previously captured snapshot\nglobs: \nalwaysApply: false\n---\n# Create a Scratch Org Based on a Snapshot\n\n## Overview\nOnce you've created a Scratch Org Snapshot, you can use it as a template to create new Scratch Orgs with identical configuration, metadata, and customizations. This approach significantly reduces setup time and ensures consistency across development environments.\n\n## Key Concepts\n- Snapshot-based Scratch Orgs inherit the entire configuration of the source Scratch Org\n- Creating from a snapshot is faster than manually configuring a new Scratch Org\n- Snapshots are referenced by their unique ID or name\n- Snapshot-based Scratch Orgs can still use definition file parameters for customization\n\n## Prerequisites\n- A previously created Scratch Org Snapshot\n- Access to the Dev Hub org\n- Proper permissions to create Scratch Orgs from snapshots\n- Salesforce CLI installed and configured\n\n## Creating a Scratch Org from a Snapshot\n\n### Basic Command Syntax\n```bash\nsf org create scratch -f config/project-scratch-def.json -s SnapshotId -a SnapshotOrg\n```\n\n### Parameters\n- `-f, --definition-file` - Path to a scratch org definition file\n- `-s, --snapshot` - ID or name of the snapshot to use\n- `-a, --alias` - Alias to assign to the new Scratch Org\n- `-d, --duration-days` - Number of days before the scratch org expires (1-30, default is 7)\n- `-v, --target-dev-hub` - Username or alias of the Dev Hub org\n- `-w, --wait` - Number of minutes to wait for the scratch org to be ready\n- `--async` - Run the command asynchronously\n\n### Example Using Snapshot ID\n```bash\nsf org create scratch -f config/project-scratch-def.json -s 0Oxx00000000001 -a TestOrg\n```\n\n### Example Using Snapshot Name\n```bash\nsf org create scratch -f config/project-scratch-def.json -s \"Release Candidate v1.2\" -a RCTestOrg\n```\n\n## Definition File Requirements\nWhen creating a Scratch Org from a snapshot, the definition file is still required but can be minimal:\n\n```json\n{\n  \"orgName\": \"Snapshot-based Org\",\n  \"edition\": \"Developer\"\n}\n```\n\nThe snapshot's configuration overrides most settings in the definition file, but you can still specify:\n- `orgName`: Custom name for the org\n- `adminEmail`: Email for the admin user\n- `username`: Custom username (if not auto-generated)\n- `hasSampleData`: Whether to include sample data (though the snapshot may already include data)\n\n## Finding Available Snapshots\nTo see all available snapshots for use:\n\n```bash\nsf org snapshot list\n```\n\nThis lists all snapshots with their IDs, names, and creation dates.\n\n## Verifying the New Scratch Org\nAfter creating a Scratch Org from a snapshot:\n\n```bash\nsf org open -o SnapshotOrg\n```\n\nVerify that the configuration matches the expected state from the snapshot.\n\n## Common Use Cases\n\n### Team Development\n```bash\nsf org create scratch -f config/minimal-def.json -s \"Team Development Baseline\" -a TeamDevOrg\n```\n\n### QA Testing\n```bash\nsf org create scratch -f config/minimal-def.json -s \"QA Environment\" -a QATestOrg -d 14\n```\n\n### Package Development\n```bash\nsf org create scratch -f config/minimal-def.json -s \"Package Dev Environment\" -a PackageDevOrg\n```\n\n## Troubleshooting\n\n### Common Issues\n- **Snapshot Not Found**: Verify the snapshot ID or name is correct\n- **Permission Error**: Ensure you have proper permissions in the Dev Hub\n- **Creation Timeout**: For complex snapshots, use `--async` and check status later\n\n### Resolution Steps\n1. For snapshot not found: `sf org snapshot list` to verify available snapshots\n2. For permission issues: Verify permissions in the Dev Hub\n3. For timeouts: `sf org create scratch -f config/project-scratch-def.json -s SnapshotId -a SnapshotOrg --async`\n\n## Best Practices\n1. Use descriptive aliases for snapshot-based Scratch Orgs\n2. Document which snapshot was used for each Scratch Org\n3. Regularly update snapshots as your configuration evolves\n4. Use snapshot-based Scratch Orgs in CI/CD pipelines for consistent testing\n5. Create different snapshots for different stages of development or features\n\n## Further Reading\n[Salesforce DX Developer Guide: Create a Scratch Org from a Snapshot](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_create_from_snapshot.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/create_scratch_org_based_on_snapshot.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/create_scratch_org_snapshot.md",
      "content": "---\ndescription: How to create a Scratch Org Snapshot using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create a Scratch Org Snapshot using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create a Scratch Org Snapshot\n\n## Overview\nCreating a Scratch Org Snapshot allows you to capture the current state of a Scratch Org, including its metadata, configuration, and customizations. This snapshot can then be used to create new Scratch Orgs with identical state.\n\n## Key Concepts\n- Snapshots preserve the complete state of a Scratch Org\n- Snapshot creation is performed using the Salesforce CLI\n- Snapshots are stored in your Dev Hub org\n- Snapshots have a unique name and ID for reference\n\n## Prerequisites\n- A configured Scratch Org with the state you want to capture\n- Access to the Dev Hub org\n- Proper permissions to create snapshots\n- Salesforce CLI installed and configured\n\n## Creating a Basic Snapshot\n\n### Command Syntax\n```bash\nsf org snapshot create -o MyScratchOrg -n \"My Snapshot\"\n```\n\n### Parameters\n- `-o, --target-org` - Username or alias of the source Scratch Org\n- `-n, --snapshot-name` - Name for the snapshot (required)\n- `-d, --description` - Description of the snapshot (optional)\n- `-v, --target-dev-hub` - Username or alias of the Dev Hub org\n- `--async` - Run the command asynchronously\n- `--wait` - Number of minutes to wait for the snapshot creation to complete\n\n### Example\n```bash\nsf org snapshot create -o DevScratchOrg -n \"Release Candidate v1.2\" -d \"Snapshot for RC testing\"\n```\n\n## Creating Snapshots for Different Purposes\n\n### Snapshot for Team Development\n```bash\nsf org snapshot create -o TeamOrg -n \"Team Development Baseline\" -d \"Standard configuration for team development\"\n```\n\n### Snapshot for Testing\n```bash\nsf org snapshot create -o TestOrg -n \"QA Environment\" -d \"Configuration for testing release v2.1\"\n```\n\n### Snapshot for Package Development\n```bash\nsf org snapshot create -o PackageOrg -n \"Package Dev Environment\" -d \"Environment for developing the managed package\"\n```\n\n## Verifying Snapshot Creation\nAfter creating a snapshot, verify its status:\n\n```bash\nsf org snapshot list\n```\n\nThe output will show all available snapshots, including their IDs, names, and creation dates.\n\n## Snapshot Creation Process\n1. Prepare your Scratch Org with all necessary customizations\n2. Deploy all required metadata\n3. Make any UI-based configurations\n4. Create the snapshot using the CLI command\n5. Wait for the snapshot process to complete\n6. Verify the snapshot is available in the snapshot list\n\n## Troubleshooting Snapshot Creation\n\n### Common Issues\n- **Timeout Error**: For large orgs, use `--async` and check status later\n- **Permission Error**: Ensure you have proper permissions in the Dev Hub\n- **Connectivity Issues**: Check your network connection and authentication\n\n### Resolution Steps\n1. For timeouts: `sf org snapshot create -o MyScratchOrg -n \"My Snapshot\" --async`\n2. For permission issues: Verify permissions in the Dev Hub\n3. For authentication issues: Re-authenticate to the Dev Hub\n\n## Best Practices\n1. Give snapshots descriptive names that indicate their purpose\n2. Add detailed descriptions for better documentation\n3. Create snapshots at key development milestones\n4. Verify the snapshot contents by creating a test Scratch Org\n5. Document which state each snapshot represents\n6. Clean up unused snapshots to avoid clutter\n\n## Further Reading\n[Salesforce DX Developer Guide: Create a Scratch Org Snapshot](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_create_snapshot.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/create_scratch_org_snapshot.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/create_scratch_org_user.md",
      "content": "---\ndescription: How to create additional users in a Scratch Org\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create additional users in a Scratch Org\nglobs: \nalwaysApply: false\n---\n# Create a Scratch Org User\n\n## Overview\nCreating additional users in a Scratch Org allows you to test your application with different user profiles, roles, and permission sets. This guide explains how to create and manage users in your Scratch Orgs.\n\n## Key Concepts\n- Additional users can be created beyond the default admin user\n- User details can be specified in a definition file\n- Users can be assigned specific profiles, roles, and permission sets\n- User creation can be scripted for consistent test environments\n\n## Prerequisites\n- An active Scratch Org\n- Appropriate licenses available in the Scratch Org\n- Required profiles and permission sets in the Scratch Org\n\n## Creating a User with the CLI\n\n### Basic Command Syntax\n```bash\nsf org create user -o MyScratchOrg -f config/user-def.json\n```\n\n### Parameters\n- `-o, --target-org` - Username or alias of the Scratch Org\n- `-f, --definition-file` - Path to a user definition file\n- `-a, --alias` - Alias to associate with the user\n- `-g, --generate-password` - Generate a password for the user\n- `-p, --password` - Set a specific password for the user\n\n### Example\n```bash\nsf org create user -o MyScratchOrg -f config/standard-user.json -g\n```\n\n## User Definition File Format\nThe user definition file is a JSON file that specifies the user's properties:\n\n```json\n{\n  \"Username\": \"testuser@example.com\",\n  \"LastName\": \"User\",\n  \"FirstName\": \"Test\",\n  \"Email\": \"testuser@example.com\",\n  \"ProfileName\": \"Standard User\",\n  \"Alias\": \"tuser\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n### Required Properties\n- `Username`: Must be in email format and unique\n- `LastName`: User's last name\n- `Email`: User's email address\n- `ProfileName`: Name of an existing profile in the org\n- `TimeZoneSidKey`: User's time zone\n- `LocaleSidKey`: User's locale\n- `EmailEncodingKey`: Email encoding (typically UTF-8)\n- `LanguageLocaleKey`: User's language and locale\n\n### Optional Properties\n- `FirstName`: User's first name\n- `Alias`: Short name for the user (max 8 characters)\n- `UserRoleId` or `UserRole`: Role ID or name\n- Additional custom fields can be included as needed\n\n## Creating Different Types of Users\n\n### Standard User\n```json\n{\n  \"Username\": \"standard.user@example.com\",\n  \"LastName\": \"User\",\n  \"FirstName\": \"Standard\",\n  \"Email\": \"standard.user@example.com\",\n  \"ProfileName\": \"Standard User\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n### Sales Manager\n```json\n{\n  \"Username\": \"sales.manager@example.com\",\n  \"LastName\": \"Manager\",\n  \"FirstName\": \"Sales\",\n  \"Email\": \"sales.manager@example.com\",\n  \"ProfileName\": \"Standard User\",\n  \"UserRole\": \"Sales Manager\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n### Custom Profile User\n```json\n{\n  \"Username\": \"custom.user@example.com\",\n  \"LastName\": \"User\",\n  \"FirstName\": \"Custom\",\n  \"Email\": \"custom.user@example.com\",\n  \"ProfileName\": \"Custom: Support Profile\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n## Generating Passwords for Users\nTo generate a password for a specific user:\n\n```bash\nsf org generate password -o MyScratchOrg -u username@example.com\n```\n\nTo create a user and generate a password in one step:\n\n```bash\nsf org create user -o MyScratchOrg -f config/user-def.json -g\n```\n\n## Assigning Permission Sets\nAfter creating users, you can assign permission sets:\n\n```bash\nsf org assign permset -o MyScratchOrg -n PermissionSetName -u username@example.com\n```\n\n## Verifying User Creation\nTo verify the user was created successfully:\n\n```bash\nsf org list users -o MyScratchOrg\n```\n\n## Best Practices\n1. Store user definition files in a dedicated directory like `config/users/`\n2. Create standardized definition files for common user types\n3. Document the purpose and permissions of each user definition\n4. Use scripts to create consistent sets of users across Scratch Orgs\n5. Create users with minimal necessary permissions for security testing\n6. Test your application with various user profiles and permission levels\n\n## Further Reading\n[Salesforce DX Developer Guide: Create Scratch Org Users](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_users_create.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/create_scratch_org_user.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/create_scratch_orgs.md",
      "content": "---\ndescription: How to create and manage Scratch Orgs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and manage Scratch Orgs using Salesforce CLI\nglobs: \nalwaysApply: false\n---\n# Create Scratch Orgs\n\n## Overview\nScratch Orgs are temporary Salesforce environments optimized for development and testing. They provide a clean, isolated environment for development, and can be easily created and destroyed.\n\n## Key Concepts\n- Scratch Orgs are created from your Dev Hub org\n- A definition file specifies the configuration of the Scratch Org\n- Scratch Orgs have a maximum lifetime of 30 days\n- Each Scratch Org has a unique username and password\n\n## Basic Creation Command\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyScratchOrg\n```\n\n### Parameters\n- `-f, --definition-file` - Path to a scratch org definition file\n- `-a, --alias` - Alias to associate with the scratch org\n- `-d, --duration-days` - Number of days before the scratch org expires (1-30, default is 7)\n- `-v, --target-dev-hub` - Username or alias of the Dev Hub org\n- `-c, --no-ancestors` - Don't include second-generation package ancestors in the scratch org\n- `-n, --no-namespace` - Create the scratch org with no namespace\n- `--no-track` - Don't track the newly created org with the org tracking file\n- `-w, --wait` - Number of minutes to wait for the scratch org to be ready\n- `--async` - Run the command asynchronously\n\n## Creating Different Types of Scratch Orgs\n\n### Basic Scratch Org\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyScratchOrg\n```\n\n### Scratch Org with Specific Duration\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyScratchOrg -d 14\n```\n\n### Scratch Org from a Different Dev Hub\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyScratchOrg -v MyDevHub\n```\n\n### Namespaced Scratch Org\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyNamespacedOrg\n```\n\n### Non-Namespaced Scratch Org\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyNonNamespacedOrg -n\n```\n\n## Accessing Scratch Orgs\nTo open a scratch org in the browser:\n\n```bash\nsf org open -o MyScratchOrg\n```\n\nTo get login details for a scratch org:\n\n```bash\nsf org display -o MyScratchOrg\n```\n\n## Managing Scratch Orgs\nTo list all scratch orgs:\n\n```bash\nsf org list\n```\n\nTo delete a scratch org:\n\n```bash\nsf org delete scratch -o MyScratchOrg\n```\n\n## Best Practices\n1. Use aliases to make it easier to reference your scratch orgs\n2. Set an appropriate expiration duration based on your development needs\n3. Delete scratch orgs when you no longer need them to free up allocations\n4. Use version control for your scratch org definition files\n5. Create different definition files for different development scenarios\n6. Automate scratch org creation and setup for repeatable development environments\n\n## Further Reading\n[Salesforce DX Developer Guide: Create Scratch Orgs](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_create.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/create_scratch_orgs.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/deploy_source_to_scratch_org.md",
      "content": "---\ndescription: How to deploy source code from your project to a Scratch Org\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to deploy source code from your project to a Scratch Org\nglobs: \nalwaysApply: false\n---\n# Deploy Source From Your Project to the Scratch Org\n\n## Overview\nAfter creating a Scratch Org, you'll typically need to deploy your project source code to it. Salesforce DX provides several commands to push your source code to a Scratch Org.\n\n## Key Concepts\n- Source code deployment moves code from your local project to the Scratch Org\n- Deployment can be incremental or complete\n- Source tracking helps manage changes between your local project and the Scratch Org\n- Deployment can target specific files, directories, or metadata types\n\n## Basic Deployment Commands\n\n### Push Source to Scratch Org\nThe push command deploys source from your project to the Scratch Org. It uses source tracking to determine what needs to be deployed.\n\n```bash\nsf project deploy start -o MyScratchOrg\n```\n\n### Deploy Specific Source\nTo deploy only specific files or directories:\n\n```bash\nsf project deploy start -o MyScratchOrg -d force-app/main/default/classes\n```\n\n### Deploy All Source (Overwrite)\nTo force deployment of all source, even if it hasn't changed:\n\n```bash\nsf project deploy start -o MyScratchOrg --ignore-conflicts --force-overwrite\n```\n\n### Deploy with Tests\nTo run tests as part of the deployment:\n\n```bash\nsf project deploy start -o MyScratchOrg -l RunLocalTests\n```\n\n## Command Parameters\n\n- `-o, --target-org` - Username or alias of the target org\n- `-d, --source-dir` - Path to the source files to deploy\n- `-x, --manifest` - Path to a manifest file (package.xml) that specifies metadata to deploy\n- `-m, --metadata` - Comma-separated list of metadata component names to deploy\n- `-w, --wait` - Number of minutes to wait for the deployment to complete\n- `-l, --test-level` - Level of testing for the deployment (RunLocalTests, RunAllTestsInOrg, etc.)\n- `--ignore-conflicts` - Ignore conflicts and deploy anyway\n- `--force-overwrite` - Force an overwrite of the remote components\n\n## Source Deployment Examples\n\n### Deploy Using Package.xml Manifest\n```bash\nsf project deploy start -o MyScratchOrg -x path/to/package.xml\n```\n\n### Deploy Specific Metadata Components\n```bash\nsf project deploy start -o MyScratchOrg -m ApexClass:MyClass,ApexTrigger:MyTrigger\n```\n\n### Deploy with Validation Only (No Deployment)\n```bash\nsf project deploy validate -o MyScratchOrg\n```\n\n### Deploy with Specific Test Class\n```bash\nsf project deploy start -o MyScratchOrg -l RunSpecifiedTests -t MyTestClass\n```\n\n## Best Practices\n1. Use source tracking to manage changes between your local project and the Scratch Org\n2. Validate your deployment before actually deploying to catch potential errors\n3. Deploy small, incremental changes to make debugging easier\n4. Use the `--json` flag to get detailed error information for failed deployments\n5. Set up deployment scripts for consistent and repeatable deployments\n6. Clear source tracking if you encounter persistent deployment issues\n\n## Further Reading\n[Salesforce DX Developer Guide: Deploy Source to an Org](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_push_md_to_scratch_org.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/deploy_source_to_scratch_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/enable_org_shape_for_scratch_orgs.md",
      "content": "---\ndescription: How to enable Org Shape functionality for Scratch Orgs in your Dev Hub\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to enable Org Shape functionality for Scratch Orgs in your Dev Hub\nglobs: \nalwaysApply: false\n---\n# Enable Org Shape for Scratch Orgs\n\n## Overview\nOrg Shape is a powerful feature that allows you to create Scratch Orgs that mirror the configuration and settings of an existing org. Before you can use Org Shape, you need to enable it in your Dev Hub org.\n\n## Key Concepts\n- Org Shape must be enabled in the Dev Hub org before use\n- Enabling Org Shape requires admin permissions in the Dev Hub\n- Once enabled, all users with appropriate permissions can create Org Shape Scratch Orgs\n- Org Shape enablement is managed through Setup in your Dev Hub org\n\n## Prerequisites\n- A Dev Hub org with admin access\n- Salesforce DX enabled in your Dev Hub org\n- Proper permissions to modify Dev Hub settings\n\n## Enabling Org Shape in Dev Hub\n\n### Through the Salesforce UI\n1. Log in to your Dev Hub org\n2. Go to **Setup**\n3. In the Quick Find box, search for **Dev Hub**\n4. Select **Dev Hub** in the Setup menu\n5. Check the box for **Enable Org Shape for Scratch Orgs**\n6. Click **Save**\n\n### Verification\nTo verify that Org Shape is enabled, you can use the Salesforce CLI:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\n## Permission Requirements\nUsers need the following permissions to create and manage Org Shape Scratch Orgs:\n\n- \"Create and Manage Scratch Orgs\" permission\n- Access to the Dev Hub org\n- Source org access (for the org being used as the shape model)\n\n## Setting Up User Permissions\nTo grant users the ability to use Org Shape:\n\n1. In your Dev Hub, go to **Setup**\n2. Navigate to **Users > Permission Sets**\n3. Create a new Permission Set or modify an existing one\n4. Add the \"Create and Manage Scratch Orgs\" permission\n5. Assign the Permission Set to appropriate users\n\n## Common Issues When Enabling Org Shape\n- Insufficient permissions in the Dev Hub\n- Dev Hub not properly set up or authenticated\n- License limitations in your Dev Hub org\n\n## Testing Org Shape After Enablement\nAfter enabling Org Shape, test it by creating a simple Org Shape Scratch Org:\n\n```bash\nsf org create scratch -f config/org-shape-def.json -a TestOrgShape\n```\n\nWhere the definition file contains:\n```json\n{\n  \"orgName\": \"Org Shape Test\",\n  \"edition\": \"Developer\",\n  \"sourceOrg\": \"YOUR_SOURCE_ORG_ID\"\n}\n```\n\n## Best Practices\n1. Enable Org Shape in a centralized Dev Hub that the whole team can access\n2. Document the enablement process for team reference\n3. Create a dedicated permission set for Org Shape users\n4. Regularly verify that Org Shape is functioning correctly\n5. Monitor usage to ensure compliance with Scratch Org limits\n\n## Further Reading\n[Salesforce DX Developer Guide: Enable Org Shape](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_org_shape_enable.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/enable_org_shape_for_scratch_orgs.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/generate_or_change_password_for_scratch_org_user.md",
      "content": "---\ndescription: How to generate or change a password for a Scratch Org user\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to generate or change a password for a Scratch Org user\nglobs: \nalwaysApply: false\n---\n# Generate or Change a Password for a Scratch Org User\n\n## Overview\nScratch Org users need passwords to log in directly to the Salesforce UI. This guide explains how to generate or change passwords for Scratch Org users, including both the default admin user and any additional users you create.\n\n## Key Concepts\n- Passwords are not automatically set when Scratch Orgs or users are created\n- Password generation is required for direct UI login\n- Passwords can be randomly generated or specifically set\n- Password operations are performed using the Salesforce CLI\n\n## Generating a Password for the Admin User\nWhen you create a Scratch Org, the default admin user doesn't have a password by default. To generate a password:\n\n```bash\nsf org generate password -o MyScratchOrg\n```\n\n### Output\nThe command returns information including:\n- Username\n- Password\n- Instance URL\n- Login URL\n\nExample:\n```\nUsername: test-wvkm2eik13u6@example.com\nPassword: Test1234\nLogin URL: https://power-velocity-1234-dev-ed.cs18.my.salesforce.com\n```\n\n## Generating a Password for a Specific User\nIf you've created additional users in your Scratch Org, you can generate passwords for them:\n\n```bash\nsf org generate password -o MyScratchOrg -u username@example.com\n```\n\nWhere `username@example.com` is the username of the specific user.\n\n## Setting a Specific Password\nTo set a specific password instead of generating a random one:\n\n```bash\nsf org generate password -o MyScratchOrg -u username@example.com -p YourPassword123\n```\n\nThe password must meet Salesforce password requirements:\n- At least 8 characters\n- At least one letter and one number\n- Cannot contain the username\n\n## Password Generation During User Creation\nYou can generate a password at the same time you create a user:\n\n```bash\nsf org create user -o MyScratchOrg -f config/user-def.json -g\n```\n\nThe `-g` flag tells the CLI to generate a password for the new user.\n\n## Changing an Existing Password\nTo change an existing password, use the same command as for generating a new password:\n\n```bash\nsf org generate password -o MyScratchOrg -u username@example.com -p NewPassword123\n```\n\nThis overwrites the previous password.\n\n## Viewing Current Login Information\nTo see the current login information for the admin user:\n\n```bash\nsf org display -o MyScratchOrg\n```\n\nTo see information for a specific user:\n\n```bash\nsf org display user -o MyScratchOrg -u username@example.com\n```\n\n## Common Use Cases\n\n### Creating a Script to Set Up Multiple Users with Passwords\n```bash\n#!/bin/bash\n# Create admin user password\nsf org generate password -o MyScratchOrg\n\n# Create additional users with passwords\nsf org create user -o MyScratchOrg -f config/users/sales-manager.json -g\nsf org create user -o MyScratchOrg -f config/users/sales-rep.json -g\nsf org create user -o MyScratchOrg -f config/users/support-agent.json -g\n```\n\n### Setting Identical Passwords for Testing\n```bash\nsf org generate password -o MyScratchOrg -p \"TestPass123\"\nsf org generate password -o MyScratchOrg -u sales.manager@example.com -p \"TestPass123\"\nsf org generate password -o MyScratchOrg -u sales.rep@example.com -p \"TestPass123\"\n```\n\n## Troubleshooting\n\n### Common Issues\n- **\"Password doesn't meet complexity requirements\"**: Ensure the password meets Salesforce requirements\n- **\"User not found\"**: Verify the username is correct\n- **\"Authentication failed\"**: Ensure you have access to the Scratch Org\n\n### Verifying Password Generation\nAfter generating a password, try logging in with the provided URL and credentials to verify it works.\n\n## Best Practices\n1. Generate passwords immediately after creating users\n2. Document login credentials for team members in a secure location\n3. Consider using standardized passwords for test environments\n4. Include password generation in setup scripts\n5. For security, use strong, unique passwords even in development environments\n6. Use parameter files or environment variables for scripts to avoid hardcoding passwords\n\n## Further Reading\n[Salesforce DX Developer Guide: Generate or Change a Scratch Org User Password](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_users_password.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/generate_or_change_password_for_scratch_org_user.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/manage_orgs_from_dev_hub_org.md",
      "content": "---\ndescription: How to manage Scratch Orgs from the Dev Hub org using the Salesforce UI\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to manage Scratch Orgs from the Dev Hub org using the Salesforce UI\nglobs: \nalwaysApply: false\n---\n# Manage Orgs From the Dev Hub Org\n\n## Overview\nWhile Salesforce CLI is the primary tool for managing Scratch Orgs, you can also perform management tasks directly from the Dev Hub org using the Salesforce UI. This provides a visual interface for monitoring and managing your Scratch Orgs.\n\n## Key Concepts\n- Dev Hub org provides a centralized view of all your Scratch Orgs\n- Management capabilities are available through the Salesforce UI\n- Visual dashboards and reports help track Scratch Org usage\n- Both administrators and developers can use the UI based on their permissions\n\n## Accessing Scratch Org Management in Dev Hub\n\n### Navigation Path\n1. Log in to your Dev Hub org\n2. From Setup, enter \"Active Scratch Org\" in the Quick Find box\n3. Select **Active Scratch Org Management**\n\n### Available Management Views\n- **Active Scratch Orgs**: View all active Scratch Orgs\n- **Scratch Org Limits**: Monitor your organization's Scratch Org usage and limits\n- **Deleted Scratch Orgs**: View recently deleted Scratch Orgs\n\n## Managing Scratch Orgs Through the UI\n\n### Viewing Scratch Org Details\nFrom the Active Scratch Orgs page, you can:\n- See the username for each Scratch Org\n- View the creation and expiration dates\n- See the Scratch Org's edition\n- Identify who created the Scratch Org\n- Check the namespace, if applicable\n\n### Actions Available in the UI\n- **Delete**: Remove a Scratch Org before its expiration date\n- **Extend**: Extend the expiration date (up to the maximum of 30 days from creation)\n- **View Details**: See more information about a specific Scratch Org\n\n## Monitoring Scratch Org Usage\n\n### Tracking Allocations\nThe Scratch Org Limits page shows:\n- Total allocation of active Scratch Orgs\n- Current number of active Scratch Orgs\n- Daily creation limit\n- Number of Scratch Orgs created today\n\n### Creating Reports\nYou can create custom reports on Scratch Org usage:\n1. From the Reports tab, click **New Report**\n2. Select **Active Scratch Orgs** as the report type\n3. Customize the report with relevant fields\n4. Save and run the report\n\n## Managing Org Shapes\n\n### Viewing Org Shapes\nTo view Org Shapes in the Dev Hub:\n1. From Setup, enter \"Org Shapes\" in the Quick Find box\n2. Select **Org Shapes**\n\n### Org Shape Actions\n- View source org details\n- See creation date and status\n- Delete unused Org Shapes\n\n## Managing Snapshots\n\n### Viewing Snapshots\nTo view Snapshots in the Dev Hub:\n1. From Setup, enter \"Org Snapshots\" in the Quick Find box\n2. Select **Org Snapshots**\n\n### Snapshot Actions\n- See snapshot details and description\n- View creation date and status\n- Delete unused snapshots\n\n## Setting Up User Access\n\n### Required Permissions\nTo manage Scratch Orgs in the UI, users need:\n- Access to the Dev Hub org\n- \"View Setup and Configuration\" permission\n- \"Create and Manage Scratch Orgs\" permission to perform management actions\n\n### Assigning Permissions\n1. From Setup, go to **Users > Permission Sets**\n2. Create or modify a permission set with the required permissions\n3. Assign the permission set to appropriate users\n\n## Best Practices\n1. Regularly review active Scratch Orgs to identify and delete unused ones\n2. Monitor approaching expiration dates to avoid unexpected org deletions\n3. Use the UI for team-wide visibility of Scratch Org usage\n4. Create dashboards to track Scratch Org allocation consumption\n5. Combine CLI and UI management for comprehensive org administration\n6. Establish governance policies for Scratch Org management\n\n## Further Reading\n[Salesforce DX Developer Guide: Manage Orgs From the Dev Hub Org](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_view_from_dev_hub.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/manage_orgs_from_dev_hub_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/org_shape_permissions.md",
      "content": "---\ndescription: Understanding the necessary permissions to work with Org Shape\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding the necessary permissions to work with Org Shape\nglobs: \nalwaysApply: false\n---\n# Org Shape Permissions\n\n## Overview\nWorking with Org Shape requires specific permissions in both your Dev Hub org and your source orgs. This guide explains the permissions needed to create and manage Org Shape Scratch Orgs.\n\n## Key Concepts\n- Different permission sets are required for administrators and developers\n- Permissions must be configured in the Dev Hub org\n- Source org access requires proper authentication\n- Permission assignments determine who can create and use Org Shape Scratch Orgs\n\n## Required Permissions\n\n### Dev Hub Administrator Permissions\nAdministrators who enable and configure Org Shape need:\n- \"Manage Dev Hub\" permission\n- System Administrator profile (or equivalent privileges)\n- Access to modify Dev Hub settings in Setup\n\n### Developer Permissions\nDevelopers who create and use Org Shape Scratch Orgs need:\n- \"Create and Manage Scratch Orgs\" permission\n- Access to the Dev Hub org\n- Access to source orgs used for creating Org Shape\n- \"View Setup and Configuration\" permission\n\n## Setting Up Permissions\n\n### Creating Permission Sets for Org Shape\n1. In your Dev Hub, go to **Setup > Users > Permission Sets**\n2. Click **New**\n3. Enter a Label (e.g., \"Org Shape Developer\")\n4. Select a license type (typically \"Salesforce\")\n5. Click **Save**\n6. Under System Permissions, click **Edit**\n7. Enable \"Create and Manage Scratch Orgs\" permission\n8. Click **Save**\n\n### Assigning Permission Sets\n1. In your Dev Hub, go to **Setup > Users > Permission Sets**\n2. Select the Org Shape permission set\n3. Click **Manage Assignments**\n4. Click **Add Assignments**\n5. Select the users who need Org Shape access\n6. Click **Assign**\n\n## Connected App Permissions\nIf using a connected app for Org Shape authorization:\n\n1. In your Dev Hub, go to **Setup > Apps > App Manager**\n2. Find and select your connected app\n3. Under \"Manage\", select **Edit Policies**\n4. Ensure \"API Only\" is selected for Permitted Users\n5. Set appropriate IP relaxation settings\n6. Save changes\n\n## Permission Verification\nTo verify a user has proper permissions:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\nIf the command succeeds, the user has appropriate permissions.\n\n## Troubleshooting Permission Issues\n\n### Common Permission Error Messages\n- \"Insufficient Privileges\" - User lacks necessary permissions\n- \"Authentication Failed\" - Source org authentication issues\n- \"User does not have required permissions in Dev Hub\" - Missing Dev Hub permissions\n\n### Resolving Permission Problems\n1. Verify the user has the \"Create and Manage Scratch Orgs\" permission\n2. Check that the Dev Hub is properly authorized\n3. Ensure the user has access to the source org\n4. Verify that Org Shape is enabled in the Dev Hub\n\n## Best Practices\n1. Use permission sets rather than modifying profiles directly\n2. Create different permission sets for administrators and developers\n3. Document permission assignments for team reference\n4. Regularly audit permissions to ensure proper access\n5. Include permission setup in onboarding documentation\n\n## Further Reading\n[Salesforce DX Developer Guide: Org Shape Permissions](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_org_shape_permissions.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/org_shape_permissions.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/retrieve_source_from_scratch_org.md",
      "content": "---\ndescription: How to retrieve source code from a Scratch Org to your local project\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to retrieve source code from a Scratch Org to your local project\nglobs: \nalwaysApply: false\n---\n# Retrieve Source from the Scratch Org to Your Project\n\n## Overview\nWhen you make changes directly in a Scratch Org (through the UI or developer console), you'll need to retrieve those changes back to your local project. Salesforce DX provides commands to pull or retrieve source from a Scratch Org to your project.\n\n## Key Concepts\n- Source retrieval brings changes from the Scratch Org back to your local project\n- Retrieval can be incremental (based on source tracking) or for specific components\n- Source tracking helps identify what has changed in the Scratch Org\n- Retrieved source is formatted according to Salesforce DX source format\n\n## Basic Retrieval Commands\n\n### Pull Source from Scratch Org\nThe pull command retrieves source from the Scratch Org to your project using source tracking to identify changes.\n\n```bash\nsf project retrieve start -o MyScratchOrg\n```\n\n### Retrieve Specific Source\nTo retrieve only specific files or metadata:\n\n```bash\nsf project retrieve start -o MyScratchOrg -m ApexClass:MyClass\n```\n\n### Retrieve Based on Package.xml\nTo retrieve based on a manifest file:\n\n```bash\nsf project retrieve start -o MyScratchOrg -x path/to/package.xml\n```\n\n### Retrieve a Directory\nTo retrieve a specific directory:\n\n```bash\nsf project retrieve start -o MyScratchOrg -d force-app/main/default/classes\n```\n\n## Command Parameters\n\n- `-o, --target-org` - Username or alias of the target org\n- `-d, --source-dir` - Path to the local directory to retrieve the source to\n- `-x, --manifest` - Path to a manifest file (package.xml) that specifies what to retrieve\n- `-m, --metadata` - Comma-separated list of metadata component names to retrieve\n- `-w, --wait` - Number of minutes to wait for the retrieval to complete\n- `--ignore-conflicts` - Ignore conflicts and retrieve anyway\n- `--to-scratch-org` - Useful when retrieving between non-source-tracked orgs\n\n## Source Retrieval Examples\n\n### Retrieve All Metadata of Specific Types\n```bash\nsf project retrieve start -o MyScratchOrg -m ApexClass,ApexTrigger,CustomObject\n```\n\n### Retrieve and Overwrite Local Changes\n```bash\nsf project retrieve start -o MyScratchOrg --force-overwrite\n```\n\n### Retrieve Multiple Specific Components\n```bash\nsf project retrieve start -o MyScratchOrg -m \"ApexClass:MyClass1,ApexClass:MyClass2\"\n```\n\n### Retrieve Source to a Different Directory\n```bash\nsf project retrieve start -o MyScratchOrg -d alternate-app\n```\n\n## Handling Conflicts\nWhen retrieving source, you might encounter conflicts if the same component has been modified both locally and in the Scratch Org. You have several options:\n\n1. Use `--force-overwrite` to overwrite local changes with the Scratch Org version\n2. Use `--ignore-conflicts` to skip conflicting files\n3. Manually resolve conflicts by editing the files\n\n## Best Practices\n1. Pull changes frequently to minimize potential conflicts\n2. Use source tracking to manage changes between your local project and the Scratch Org\n3. Use specific retrieval for precise control over what gets pulled\n4. Back up your local changes before retrieving if you're unsure about conflicts\n5. Set up retrieval scripts for consistent and repeatable operations\n6. Use manifest files (package.xml) for complex retrieval operations\n\n## Further Reading\n[Salesforce DX Developer Guide: Pull Source from the Scratch Org to Your Project](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_pull.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/retrieve_source_from_scratch_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_definition_file.md",
      "content": "---\ndescription: How to build and customize a Scratch Org definition file\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to build and customize a Scratch Org definition file\nglobs: \nalwaysApply: false\n---\n# Build Your Own Scratch Org Definition File\n\n## Overview\nA Scratch Org definition file is a JSON file that specifies the configuration details for a Scratch Org. It defines the edition, features, settings, and other properties needed when creating a Scratch Org.\n\n## Key Concepts\n- Scratch Org definition files use JSON format\n- They specify configuration details required to create consistent Scratch Orgs\n- Definition files can be stored in the `config` folder of your project\n- The file is used with the `sf org create scratch` command\n\n## Basic Structure\nA basic Scratch Org definition file includes:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Developer\",\n  \"features\": [],\n  \"settings\": {},\n  \"hasSampleData\": false\n}\n```\n\n## Required Properties\n- `edition`: Specifies the Salesforce edition to use (Developer, Enterprise, Group, Professional, etc.)\n\n## Optional Properties\n- `orgName`: Name of the org\n- `username`: Username for the admin user (auto-generated if not specified)\n- `adminEmail`: Email for the admin user\n- `hasSampleData`: Whether to include sample data (default is false)\n- `features`: Array of features to enable\n- `settings`: Object containing org settings to configure\n- `sourceOrg`: Source org ID for org shape-based Scratch Orgs\n- `release`: Salesforce release version (Current, Previous, Preview)\n- `language`: Default language for the org\n- `country`: Default country for the org\n- `description`: Description of the Scratch Org\n\n## Example Definition File\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Enterprise\",\n  \"features\": [\"Communities\", \"ServiceCloud\", \"MarketingUser\"],\n  \"settings\": {\n    \"lightningExperienceSettings\": {\n      \"enableS1DesktopEnabled\": true\n    },\n    \"mobileSettings\": {\n      \"enableS1EncryptedStoragePref2\": false\n    },\n    \"securitySettings\": {\n      \"passwordPolicies\": {\n        \"enableSetPasswordInApi\": true\n      }\n    }\n  },\n  \"hasSampleData\": true\n}\n```\n\n## Command Usage\nTo create a Scratch Org using a definition file:\n\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyScratchOrg\n```\n\n## Best Practices\n1. Store definition files in the `config` directory of your project\n2. Version control your definition files\n3. Create different definition files for different development scenarios\n4. Document the purpose of each definition file in your project\n5. Include only the features and settings required for your development needs\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Org Definition File](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_def_file.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_definition_file.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_definition_for_org_shape.md",
      "content": "---\ndescription: How to create and configure a Scratch Org definition file for Org Shape\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and configure a Scratch Org definition file for Org Shape\nglobs: \nalwaysApply: false\n---\n# Scratch Org Definition for Org Shape\n\n## Overview\nWhen using Org Shape to create Scratch Orgs, you need a specific definition file configuration. This guide explains how to create and configure a Scratch Org definition file specifically for use with Org Shape.\n\n## Key Concepts\n- Org Shape definition files require the `sourceOrg` parameter\n- Some parameters override settings from the source org\n- Conflict resolution follows specific rules for overlapping settings\n- Multiple definition files can reference the same Org Shape\n\n## Basic Structure for Org Shape\nA basic Scratch Org definition file for Org Shape includes:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Enterprise\",\n  \"sourceOrg\": \"00Dxx0000000001EAA\",\n  \"hasSampleData\": false\n}\n```\n\n## Required Parameters\n- `sourceOrg`: The ID of the source org to use as the shape template\n\n## Optional Parameters\n- `orgName`: Name of the org (overrides source org name)\n- `edition`: Edition to use (must match source org edition)\n- `features`: Additional features to enable (supplements source org features)\n- `settings`: Settings to override or supplement from source org\n- `hasSampleData`: Whether to include sample data (default is false)\n- `language`: Default language for the org\n- `country`: Default country for the org\n\n## Parameter Precedence\nWhen there are conflicts between source org settings and definition file settings:\n1. Settings explicitly defined in the definition file take precedence\n2. Features explicitly defined in the definition file supplement source org features\n3. Edition must match the source org edition\n\n## Example: Supplementing Source Org Features\n```json\n{\n  \"orgName\": \"Feature Enriched Org\",\n  \"edition\": \"Enterprise\",\n  \"sourceOrg\": \"00Dxx0000000001EAA\",\n  \"features\": [\"Communities\", \"PersonAccounts\"],\n  \"hasSampleData\": false\n}\n```\n\n## Example: Overriding Source Org Settings\n```json\n{\n  \"orgName\": \"Custom Settings Org\",\n  \"edition\": \"Enterprise\",\n  \"sourceOrg\": \"00Dxx0000000001EAA\",\n  \"settings\": {\n    \"lightningExperienceSettings\": {\n      \"enableS1DesktopEnabled\": false\n    },\n    \"securitySettings\": {\n      \"passwordPolicies\": {\n        \"enableSetPasswordInApi\": true\n      }\n    }\n  },\n  \"hasSampleData\": false\n}\n```\n\n## Finding Source Org ID\nTo find a source org ID for use in the definition file:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\nOr from an authorized org:\n\n```bash\nsf org display -o SourceOrg --json\n```\n\n## Limitations\n- Edition in the definition file must match the source org edition\n- Some features cannot be added if not supported by the org edition\n- Some settings may not take effect if they conflict with enabled features\n- Not all source org settings are captured in the Org Shape\n\n## Best Practices\n1. Keep definition files simple by relying on the source org for most settings\n2. Only override settings when necessary\n3. Document why certain settings are overridden\n4. Version control your Org Shape definition files\n5. Name files clearly to indicate which source org they use\n6. Test Scratch Orgs after creation to verify settings were applied correctly\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Org Definition for Org Shape](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_org_shape_def_file.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_definition_for_org_shape.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_error_codes.md",
      "content": "---\ndescription: Understanding and resolving common Scratch Org error codes\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding and resolving common Scratch Org error codes\nglobs: \nalwaysApply: false\n---\n# Scratch Org Error Codes\n\n## Overview\nWhen working with Scratch Orgs, you may encounter various error codes that indicate specific issues. Understanding these error codes helps you troubleshoot and resolve problems efficiently.\n\n## Key Concepts\n- Error codes provide specific information about what went wrong\n- Errors can occur during creation, operation, or deletion of Scratch Orgs\n- Most errors have specific resolution steps\n- Salesforce CLI provides detailed error information\n\n## Common Error Codes and Solutions\n\n### Creation Errors\n\n#### Error: ORG_CREATE_FAILED\n**Description**: The Scratch Org creation failed.\n**Possible Causes**:\n- Network connectivity issues\n- Invalid Scratch Org definition file\n- Dev Hub limits reached\n- Invalid parameters\n\n**Resolution Steps**:\n1. Verify your network connection\n2. Check your Scratch Org definition file for syntax errors\n3. Verify you haven't reached your Scratch Org limits\n4. Try with a simpler definition file\n\n#### Error: INVALID_DEFINITION_FILE\n**Description**: The Scratch Org definition file is invalid.\n**Possible Causes**:\n- JSON syntax errors\n- Invalid features or settings\n- Incorrect parameter types\n\n**Resolution Steps**:\n1. Validate your JSON syntax\n2. Remove any unsupported features or settings\n3. Verify all parameters are correctly typed\n\n#### Error: DUPLICATE_VALUE\n**Description**: A unique field value is duplicated.\n**Possible Causes**:\n- Username already exists\n- Email address already in use\n\n**Resolution Steps**:\n1. Try creating the Scratch Org again (autogenerated usernames will be different)\n2. Specify a different username or email in your definition file\n\n### Operation Errors\n\n#### Error: ORG_NOT_FOUND\n**Description**: The specified Scratch Org cannot be found.\n**Possible Causes**:\n- Incorrect alias or username\n- Org has been deleted\n- Org has expired\n\n**Resolution Steps**:\n1. Verify the org alias or username\n2. Check if the org exists using `sf org list`\n3. Create a new Scratch Org if needed\n\n#### Error: INSUFFICIENT_ACCESS\n**Description**: User doesn't have sufficient permissions.\n**Possible Causes**:\n- Missing \"Create and Manage Scratch Orgs\" permission\n- Not authorized to the Dev Hub\n- Not a member of the correct organization\n\n**Resolution Steps**:\n1. Verify you have the required permissions\n2. Authenticate to the Dev Hub: `sf org login web -d`\n3. Contact your administrator for proper access\n\n#### Error: SOURCE_CONFLICT\n**Description**: Conflict detected during source push or pull.\n**Possible Causes**:\n- Same component modified locally and in the org\n- Metadata conflict\n\n**Resolution Steps**:\n1. Use `--force-overwrite` to override conflicts\n2. Manually resolve conflicts by editing files\n3. Pull changes first, then make local changes\n\n### Deletion Errors\n\n#### Error: INVALID_STATUS\n**Description**: Operation not allowed due to current org status.\n**Possible Causes**:\n- Trying to modify a deleted org\n- Org is in a transitional state\n\n**Resolution Steps**:\n1. Verify the org status using `sf org list`\n2. Wait a few minutes if the org is in a transitional state\n3. Create a new org if needed\n\n## Enhanced Troubleshooting\n\n### Getting Detailed Error Information\nFor more detailed error information, use the `--json` flag:\n\n```bash\nsf org create scratch -f config/project-scratch-def.json -a MyScratchOrg --json\n```\n\nThe output includes detailed error messages and stack traces.\n\n### Common Error Patterns and Solutions\n\n#### Connectivity Issues\n**Symptoms**: Timeouts, connection refused errors\n**Solutions**:\n1. Check your network connection\n2. Verify VPN settings if applicable\n3. Try again later if it might be a Salesforce service issue\n\n#### Permission Issues\n**Symptoms**: Access denied, insufficient privileges\n**Solutions**:\n1. Verify your authentication to the Dev Hub\n2. Check your permission sets in the Dev Hub\n3. Re-authenticate using `sf org login web -d`\n\n#### Configuration Issues\n**Symptoms**: Invalid definition file, unsupported feature\n**Solutions**:\n1. Validate your JSON syntax\n2. Remove unsupported features or settings\n3. Start with a minimal definition file and add features incrementally\n\n## Best Practices for Error Prevention\n1. Use version-controlled, validated definition files\n2. Test definition files before team-wide deployment\n3. Monitor Scratch Org limits and usage\n4. Follow naming conventions for aliases and usernames\n5. Document common errors and solutions for your team\n6. Include error handling in your scripts\n\n## Further Reading\n[Salesforce DX Developer Guide: Troubleshooting Scratch Orgs](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_troubleshoot.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_error_codes.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_features.md",
      "content": "---\ndescription: Available features that can be enabled in Scratch Org definition files\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Available features that can be enabled in Scratch Org definition files\nglobs: \nalwaysApply: false\n---\n# Scratch Org Features\n\n## Overview\nScratch Org features are specific capabilities that you can enable when creating a Scratch Org. These features correspond to Salesforce product offerings and functionality that might require licenses in production environments.\n\n## Key Concepts\n- Features are specified in the `features` array in the Scratch Org definition file\n- Features allow you to test functionality that might require licenses in production\n- Some features have dependencies on other features\n- Features are case-sensitive\n\n## Common Features\nHere are some commonly used Scratch Org features:\n\n### Sales Cloud Features\n- `API` - API Access\n- `AuthorApex` - Apex Development\n- `DebugApex` - Apex Debugging\n- `ForceComPlatform` - Force.com Platform\n- `LightningSalesConsole` - Lightning Sales Console\n- `MarketingUser` - Marketing User\n- `SalesUser` - Sales User\n\n### Service Cloud Features\n- `ServiceCloud` - Service Cloud\n- `LightningServiceConsole` - Lightning Service Console\n- `LiveAgent` - Live Agent\n- `ServiceUser` - Service User\n- `Knowledge` - Knowledge Management\n\n### Community Features\n- `Communities` - Community Cloud\n- `CustomerCommunity` - Customer Community\n- `CustomerCommunityPlus` - Customer Community Plus\n- `PartnerCommunity` - Partner Community\n\n### Development Features\n- `Workflow` - Workflow Rules\n- `ProcessBuilder` - Process Builder\n- `MultiCurrency` - Multiple Currencies\n- `StateAndCountryPicklist` - State and Country Picklists\n- `DevelopmentWave` - Analytics Development\n- `AnalyticsAdminPerms` - Analytics Admin Permissions\n\n### Other Features\n- `PersonAccounts` - Person Accounts\n- `ContactsToMultipleAccounts` - Contacts to Multiple Accounts\n- `LightningExperience` - Lightning Experience\n- `EinsteinAnalyticsPlus` - Einstein Analytics Plus\n- `EinsteinBuilderFree` - Einstein Builder Free\n\n## Example Usage\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Developer\",\n  \"features\": [\n    \"API\",\n    \"AuthorApex\",\n    \"Communities\",\n    \"ServiceCloud\",\n    \"MultiCurrency\"\n  ],\n  \"settings\": {}\n}\n```\n\n## Checking Available Features\nTo check which features are available for a specific Scratch Org edition:\n\n```bash\nsf org create scratch --edition=Enterprise --json\n```\n\nThis will list all available features for the Enterprise edition.\n\n## Feature Dependencies\nSome features have dependencies on other features. For example:\n- `CustomerCommunity` requires `Communities`\n- `ServiceUser` may require `SalesUser`\n\n## Best Practices\n1. Only enable features that you need for your development\n2. Be aware of feature dependencies\n3. Test with features that match your production environment\n4. Document which features are required for your application\n5. Create different definition files for different feature sets\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Org Features](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_def_file_config_values.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_features.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_settings.md",
      "content": "---\ndescription: Configure organization settings in a Scratch Org definition file\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Configure organization settings in a Scratch Org definition file\nglobs: \nalwaysApply: false\n---\n# Scratch Org Settings\n\n## Overview\nScratch Org settings allow you to configure specific organization preferences, capabilities, and behaviors when creating a Scratch Org. Settings are specified in the `settings` object in the Scratch Org definition file.\n\n## Key Concepts\n- Settings are organized into related groups based on Salesforce functionality\n- Settings configurations mirror the Metadata API settings objects\n- Each setting group contains one or more configuration options\n- Settings values can be boolean, string, number, or complex objects\n\n## Common Settings\n\n### User Interface Settings\n```json\n\"lightningExperienceSettings\": {\n  \"enableS1DesktopEnabled\": true\n}\n```\n\n### Mobile Settings\n```json\n\"mobileSettings\": {\n  \"enableS1EncryptedStoragePref2\": false\n}\n```\n\n### Security Settings\n```json\n\"securitySettings\": {\n  \"passwordPolicies\": {\n    \"enableSetPasswordInApi\": true\n  },\n  \"sessionSettings\": {\n    \"sessionTimeout\": \"TwoHours\"\n  }\n}\n```\n\n### Account Settings\n```json\n\"accountSettings\": {\n  \"enableRelateContactToMultipleAccounts\": true\n}\n```\n\n### Case Management Settings\n```json\n\"caseSettings\": {\n  \"emailToCase\": {\n    \"enableEmailToCase\": true\n  }\n}\n```\n\n### Language Settings\n```json\n\"languageSettings\": {\n  \"enableTranslationWorkbench\": true\n}\n```\n\n### Chatter Settings\n```json\n\"chatterSettings\": {\n  \"enableChatter\": true\n}\n```\n\n## Example Settings Configuration\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Developer\",\n  \"features\": [\"API\"],\n  \"settings\": {\n    \"lightningExperienceSettings\": {\n      \"enableS1DesktopEnabled\": true\n    },\n    \"securitySettings\": {\n      \"passwordPolicies\": {\n        \"enableSetPasswordInApi\": true\n      }\n    },\n    \"mobileSettings\": {\n      \"enableS1EncryptedStoragePref2\": false\n    },\n    \"emailAdministrationSettings\": {\n      \"enableEnhancedEmailEnabled\": true\n    },\n    \"languageSettings\": {\n      \"enableTranslationWorkbench\": true\n    }\n  }\n}\n```\n\n## Finding Available Settings\nSettings correspond to Metadata API types. You can explore available settings in the Metadata API documentation.\n\nTo see the current settings in an existing org, you can retrieve the metadata:\n\n```bash\nsf project retrieve start --metadata Settings:Security\n```\n\n## Best Practices\n1. Only configure settings that are relevant to your development needs\n2. Test with settings that match your production environment\n3. Document which settings are required for your application\n4. Create different definition files for different settings configurations\n5. Use descriptive names for your definition files that indicate the included settings\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Org Definition Configuration Values](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_def_file_config_values.htm)\n[Metadata API Developer Guide: Settings](mdc:https:/developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_settings.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_settings.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_snapshots.md",
      "content": "---\ndescription: Understanding Scratch Org Snapshots and their benefits\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding Scratch Org Snapshots and their benefits\nglobs: \nalwaysApply: false\n---\n# Scratch Org Snapshots\n\n## Overview\nScratch Org Snapshots allow you to capture the state of a Scratch Org, including its metadata, configuration, and settings. Snapshots enable you to recreate that exact state in a new Scratch Org, enhancing consistency and accelerating development cycles.\n\n## Key Concepts\n- Snapshots capture the metadata and configuration of a Scratch Org\n- Snapshots can be saved and reused to create new Scratch Orgs\n- Snapshots help maintain consistency across development environments\n- Snapshots accelerate development by reducing setup time\n- Snapshots can be used for package version creation\n\n## Benefits of Using Snapshots\n\n### Development Efficiency\n- Reduce setup time for new Scratch Orgs\n- Avoid repeating the same deployment and configuration steps\n- Capture complex org configurations that would be time-consuming to recreate\n\n### Testing Consistency\n- Ensure all team members test against the same configuration\n- Create consistent testing environments for CI/CD processes\n- Reproduce bug environments exactly for easier troubleshooting\n\n### Release Management\n- Capture pre-release states for reference\n- Create package versions from consistent environments\n- Maintain snapshots for different stages of the development cycle\n\n## Snapshot vs. Other Features\n\n### Snapshot vs. Source Control\n- Snapshots include org configuration not captured in source code\n- Snapshots reflect the deployed and activated state, not just the code\n- Snapshots capture the entire org state, not just tracked components\n\n### Snapshot vs. Org Shape\n- Org Shape captures settings and features from any org\n- Snapshots capture specific metadata configurations from a Scratch Org\n- Snapshots are more comprehensive for Scratch Org state\n\n### Snapshot vs. Templates\n- Snapshots are more dynamic and include actual deployed configurations\n- Templates typically include only the definition but not the resulting state\n- Snapshots can capture changes made through the UI, not just deployed code\n\n## Snapshot Lifecycle\n\n### 1. Create a Scratch Org\nStart with a Scratch Org created using your definition file.\n\n### 2. Set Up and Configure\nDeploy source, make configuration changes, and set up the org as needed.\n\n### 3. Create Snapshot\nCapture the Scratch Org state as a snapshot.\n\n### 4. Create New Scratch Orgs from Snapshot\nUse the snapshot to create new Scratch Orgs with identical configuration.\n\n### 5. Maintain and Update Snapshots\nCreate new snapshots as your configuration evolves.\n\n## Best Practices\n1. Create snapshots at key milestones in development\n2. Name snapshots clearly to indicate their purpose and content\n3. Document what each snapshot contains and when to use it\n4. Clean up old snapshots that are no longer needed\n5. Use snapshots in CI/CD pipelines to ensure consistent testing environments\n6. Consider creating snapshots for different feature sets or configurations\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Org Snapshots](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_snapshots.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_snapshots.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/scratch_org_users.md",
      "content": "---\ndescription: Understanding Scratch Org user management and permissions\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding Scratch Org user management and permissions\nglobs: \nalwaysApply: false\n---\n# Scratch Org Users\n\n## Overview\nScratch Orgs come with an admin user by default, but you may need to create additional users for testing, development, or to simulate a production environment with different user roles and permissions. This guide explains how to manage users in Scratch Orgs.\n\n## Key Concepts\n- Each Scratch Org has a default admin user created automatically\n- Additional users can be created for testing different permission levels\n- User definitions can be stored in files for reuse\n- Scratch Org users can have passwords set for direct login\n\n## Default Admin User\n\n### Characteristics\n- Created automatically with the Scratch Org\n- Has System Administrator profile by default\n- Username is automatically generated\n- Can be customized during Scratch Org creation\n\n### Viewing Admin User Details\nTo see information about the default admin user:\n\n```bash\nsf org display -o MyScratchOrg\n```\n\nThis shows the admin username, password (if set), and other details.\n\n## Managing Scratch Org Users\n\n### Listing Users in a Scratch Org\nTo see all users in a Scratch Org:\n\n```bash\nsf org list users -o MyScratchOrg\n```\n\n### Accessing User Information\nTo get detailed information about a specific user:\n\n```bash\nsf org display user -o MyScratchOrg -u username@example.com\n```\n\n### Generating a Password for the Admin User\nTo set or reset the admin user's password:\n\n```bash\nsf org generate password -o MyScratchOrg\n```\n\nThis generates a random password for the admin user or you can specify a password with the `--password` option.\n\n## User Management Considerations\n\n### User Licenses\n- Scratch Orgs have limited user licenses available\n- The number of users you can create depends on the Scratch Org edition\n- User licenses are consumed when you create new users\n\n### User Profiles and Permissions\n- Users can be assigned any profile available in the Scratch Org\n- Custom permission sets can be assigned to users\n- Role hierarchy can be configured for testing sharing and visibility\n\n### Data Visibility\n- Different users see different data based on:\n  - Profile permissions\n  - Role hierarchy\n  - Sharing rules\n  - Record ownership\n\n## Simulating Multi-User Environments\n\n### Testing Sharing Rules\nCreate multiple users with different roles to test sharing behavior:\n\n```bash\nsf org create user -o MyScratchOrg -f config/user-def.json\n```\n\n### Testing Permission Sets\nAssign different permission sets to users to test feature access:\n\n```bash\nsf data create record -o MyScratchOrg -s PermissionSetAssignment -v \"AssigneeId=005xx000000abcdAAA PermissionSetId=0PS000000000123\"\n```\n\n### Impersonating Different Users\nLog in as different users to test the user experience:\n\n1. Generate a password for the user\n2. Use the login URL and credentials to log in\n\n## Best Practices\n1. Document user configurations for consistent testing\n2. Use user definition files to create users with consistent settings\n3. Create users with different profiles for comprehensive testing\n4. Test sharing and visibility from multiple user perspectives\n5. Include user creation in setup scripts for Scratch Orgs\n6. Consider creating a standardized set of test users for common scenarios\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Org Users](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_users.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/scratch_org_users.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/select_salesforce_release_for_scratch_org.md",
      "content": "---\ndescription: How to specify which Salesforce release version to use for a Scratch Org\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to specify which Salesforce release version to use for a Scratch Org\nglobs: \nalwaysApply: false\n---\n# Select the Salesforce Release for a Scratch Org\n\n## Overview\nSalesforce releases major updates three times a year. When creating Scratch Orgs, you can specify which release version to use, allowing you to test your application against current, previous, or preview releases.\n\n## Key Concepts\n- Scratch Orgs can be created on different Salesforce release versions\n- The `release` parameter in the definition file controls the release version\n- Available options include Current, Previous, and Preview releases\n- Testing against multiple release versions helps ensure compatibility\n\n## Specifying a Release Version\n\n### Syntax in Definition File\nTo specify a release version, add the `release` parameter to your Scratch Org definition file:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Developer\",\n  \"release\": \"Current\",\n  \"features\": [],\n  \"settings\": {}\n}\n```\n\n### Available Release Options\n- `Current`: The current production release (default if not specified)\n- `Previous`: The previous production release\n- `Preview`: The preview/beta version of the upcoming release\n\n## Example Definition Files\n\n### Current Release Definition\n```json\n{\n  \"orgName\": \"Current Release Org\",\n  \"edition\": \"Developer\",\n  \"release\": \"Current\",\n  \"features\": [\"API\"]\n}\n```\n\n### Previous Release Definition\n```json\n{\n  \"orgName\": \"Previous Release Org\",\n  \"edition\": \"Developer\",\n  \"release\": \"Previous\",\n  \"features\": [\"API\"]\n}\n```\n\n### Preview Release Definition\n```json\n{\n  \"orgName\": \"Preview Release Org\",\n  \"edition\": \"Developer\",\n  \"release\": \"Preview\",\n  \"features\": [\"API\"]\n}\n```\n\n## Creating a Scratch Org with a Specific Release\n\n```bash\nsf org create scratch -f config/previous-release-def.json -a PreviousReleaseOrg\n```\n\n## Release Availability and Timing\n\n### Release Cycle\nSalesforce has three major releases per year, typically in:\n- Spring (February - April)\n- Summer (June - August)\n- Winter (October - December)\n\n### Preview Availability\nThe Preview release becomes available during the sandbox preview phase of the Salesforce release cycle, typically 4-6 weeks before the production release.\n\n### Previous Release Retention\nThe Previous release option is typically available until shortly after the next release goes into production.\n\n## Use Cases for Different Releases\n\n### Current Release\n- Standard development work\n- Production-ready testing\n- Final QA before deployment\n\n### Previous Release\n- Testing backward compatibility\n- Supporting orgs that haven't upgraded\n- Reproducing issues in existing production environments\n\n### Preview Release\n- Testing upcoming features\n- Preparing for new release impact\n- Early detection of compatibility issues\n\n## Best Practices\n1. Test your application against all relevant release versions\n2. Create separate Scratch Orgs for each release version you're testing\n3. Use clear naming conventions to indicate which release a Scratch Org is using\n4. Document any release-specific issues or behavior differences\n5. Create automation scripts to test against multiple releases\n6. Update your test strategy during Salesforce's release transition periods\n\n## Limitations\n- Not all features may be available in Previous or Preview releases\n- Preview releases may have incomplete features or known issues\n- Release availability depends on Salesforce's release schedule\n- Some features may behave differently across releases\n\n## Further Reading\n[Salesforce DX Developer Guide: Select the Salesforce Release for a Scratch Org](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_select_release.htm)\n[Salesforce Release Schedule](mdc:https:/developer.salesforce.com/docs/atlas.en-us.236.0.api_meta.meta/api_meta/meta_release_notes.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/select_salesforce_release_for_scratch_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/supported_editions_and_allocations.md",
      "content": "---\ndescription: Information about supported Scratch Org editions and their allocations\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Information about supported Scratch Org editions and their allocations\nglobs: \nalwaysApply: false\n---\n# Supported Scratch Org Editions and Allocations\n\n## Overview\nScratch Orgs come in different editions that mirror production Salesforce editions. Each Dev Hub has allocation limits for how many Scratch Orgs you can create.\n\n## Key Concepts\n- Scratch Orgs are available in different editions that match production Salesforce editions\n- Each Dev Hub has allocation limits for the number of active Scratch Orgs\n- Scratch Orgs have a maximum lifetime of 30 days\n- Different Salesforce license types have different Scratch Org allocation limits\n\n## Supported Editions\nThe following Scratch Org editions are supported:\n- Developer\n- Enterprise\n- Group\n- Professional\n- Partner Developer\n- Partner Enterprise\n- Partner Group\n- Partner Professional\n\n## Allocation Details\n- **Active Scratch Orgs**: Limited based on your Salesforce license\n- **Scratch Org Duration**: Maximum 30 days before they expire\n- **Daily Creation Limit**: Based on your Salesforce license\n\n### Allocation by License Type\n| License Type | Active Scratch Orgs | Daily Creation Limit |\n|-------------|---------------------|---------------------|\n| Developer Edition | 3-6 | 6 |\n| Trial | 3-6 | 6 |\n| Enterprise Edition | 40-100 | 80-200 |\n| Unlimited Edition | 40-100 | 80-200 |\n| Performance Edition | 40-100 | 80-200 |\n\n## Checking Allocations\nYou can check your Scratch Org allocations with the Salesforce CLI:\n\n```bash\nsf org list limits --target-org your-dev-hub-alias\n```\n\n## Best Practices\n1. Monitor your Scratch Org usage to avoid hitting allocation limits\n2. Delete Scratch Orgs when no longer needed to free up allocations\n3. Consider setting shorter expiration dates for temporary development work\n4. Use the `--duration` flag when creating Scratch Orgs to control lifespan\n\n## Further Reading\n[Salesforce DX Developer Guide: Scratch Orgs](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/supported_editions_and_allocations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/troubleshoot_org_shape.md",
      "content": "---\ndescription: How to troubleshoot common issues with Org Shape in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to troubleshoot common issues with Org Shape in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Troubleshoot Org Shape\n\n## Overview\nWhen working with Org Shape, you may encounter various issues during creation, management, or usage. This guide provides troubleshooting steps for common Org Shape problems.\n\n## Key Concepts\n- Org Shape issues can occur at different stages: creation, usage, or management\n- Common problems include permission issues, configuration conflicts, and command errors\n- Diagnostic tools help identify the root cause of issues\n- Most problems have specific resolution steps\n\n## Common Issues and Solutions\n\n### Org Shape Creation Issues\n\n#### \"Insufficient Privileges\" Error\n**Problem**: Unable to create an Org Shape due to permission issues.\n**Solution**:\n1. Verify the user has the \"Create and Manage Scratch Orgs\" permission\n2. Check that Org Shape is enabled in the Dev Hub\n3. Ensure the user has access to the source org\n\n#### Timeout During Org Shape Creation\n**Problem**: Org Shape creation takes too long and times out.\n**Solution**:\n1. Use the `--async` flag to run the shape capture asynchronously\n2. Check the status later using `sf org list shape`\n3. For large orgs, increase the wait time: `sf org create shape -o SourceOrg --wait 60`\n\n#### \"Source Org Not Found\" Error\n**Problem**: The system cannot find the source org.\n**Solution**:\n1. Verify the source org is properly authenticated\n2. Re-authenticate to the source org: `sf org login web -a SourceOrg`\n3. Check that the source org ID or alias is correct\n\n### Scratch Org Creation Issues with Org Shape\n\n#### Edition Mismatch Error\n**Problem**: The edition in the definition file doesn't match the source org edition.\n**Solution**:\n1. Verify the source org's edition: `sf org list shape`\n2. Update the definition file to match the source org's edition\n3. If needed, create a new Org Shape from a different source org\n\n#### Feature Enablement Failures\n**Problem**: Some features specified in the definition file fail to enable.\n**Solution**:\n1. Check for feature dependencies or conflicts\n2. Verify the features are supported by the edition\n3. Try enabling features one at a time to identify the problematic one\n\n#### Incomplete Configuration\n**Problem**: The Scratch Org doesn't have all the expected settings from the source org.\n**Solution**:\n1. Be aware that not all settings are captured in Org Shape\n2. Explicitly add critical settings to the definition file\n3. Document settings that must be configured manually\n\n### Org Shape Management Issues\n\n#### Unable to Delete Org Shape\n**Problem**: Error when trying to delete an Org Shape.\n**Solution**:\n1. Verify there are no active Scratch Orgs using the Org Shape\n2. Check that you have the necessary permissions\n3. Ensure you're using the correct Org Shape ID\n\n#### Missing Org Shapes in List\n**Problem**: Expected Org Shapes don't appear in the list.\n**Solution**:\n1. Verify you're checking the correct Dev Hub: `sf org list shape --target-dev-hub DevHub`\n2. Ensure the Org Shapes were successfully created\n3. Check if another user created the Org Shapes under different permissions\n\n## Diagnostic Approaches\n\n### Collecting Debug Information\nTo get more detailed error information:\n\n```bash\nsf org create shape -o SourceOrg --json --loglevel debug\n```\n\n### Verifying Org Shape Status\nTo check if an Org Shape was successfully created:\n\n```bash\nsf org list shape --target-dev-hub DevHub\n```\n\n### Checking Dev Hub Status\nTo verify Dev Hub configuration:\n\n```bash\nsf org display -o DevHub --json\n```\n\n## Best Practices for Avoiding Issues\n1. Start with simple Org Shapes before attempting complex configurations\n2. Test Org Shape creation with smaller, simpler orgs first\n3. Document successful Org Shape workflows for team reference\n4. Keep definition files simple, adding complexity incrementally\n5. Maintain clear naming conventions for source orgs and Scratch Orgs\n\n## Further Reading\n[Salesforce DX Developer Guide: Troubleshoot Org Shape](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_org_shape_troubleshoot.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/troubleshoot_org_shape.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/scratch_orgs/user_definition_file_for_customizing_scratch_org_user.md",
      "content": "---\ndescription: How to create and use a user definition file for customizing Scratch Org users\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to create and use a user definition file for customizing Scratch Org users\nglobs: \nalwaysApply: false\n---\n# User Definition File for Customizing a Scratch Org User\n\n## Overview\nUser definition files provide a standardized way to specify user properties when creating users in Scratch Orgs. This guide explains how to create and structure user definition files to customize Scratch Org users according to your testing needs.\n\n## Key Concepts\n- User definition files are JSON files containing user information\n- Files can specify profiles, permissions, roles, and other user attributes\n- Multiple definition files can be created for different user types\n- Definition files ensure consistent user creation across environments\n\n## User Definition File Structure\nA basic user definition file includes required fields and optional customizations:\n\n```json\n{\n  \"Username\": \"testuser@example.com\",\n  \"LastName\": \"User\",\n  \"FirstName\": \"Test\",\n  \"Email\": \"testuser@example.com\",\n  \"ProfileName\": \"Standard User\",\n  \"Alias\": \"tuser\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n## Required Fields\nThe following fields are required in all user definition files:\n\n| Field | Description | Example |\n|-------|-------------|---------|\n| `Username` | Unique username in email format | \"testuser@example.com\" |\n| `LastName` | User's last name | \"User\" |\n| `Email` | User's email address | \"testuser@example.com\" |\n| `ProfileName` | Name of an existing profile | \"Standard User\" |\n| `TimeZoneSidKey` | Time zone | \"America/Los_Angeles\" |\n| `LocaleSidKey` | Locale | \"en_US\" |\n| `EmailEncodingKey` | Email encoding | \"UTF-8\" |\n| `LanguageLocaleKey` | Language and locale | \"en_US\" |\n\n## Optional Fields\nThese fields are optional but useful for customization:\n\n| Field | Description | Example |\n|-------|-------------|---------|\n| `FirstName` | User's first name | \"Test\" |\n| `Alias` | Short name (8 char max) | \"tuser\" |\n| `UserRoleId` | ID of a user role | \"00E000000012345\" |\n| `UserRole` | Name of a user role | \"CEO\" |\n| `IsActive` | Whether user is active | true |\n| `Title` | Job title | \"Developer\" |\n| `CompanyName` | Company name | \"Acme Corp\" |\n| `Department` | Department | \"Engineering\" |\n| `Division` | Division | \"Products\" |\n| `ManagerId` | ID of the user's manager | \"005000000012345\" |\n\n## Common User Types\n\n### System Administrator\n```json\n{\n  \"Username\": \"admin@example.com\",\n  \"LastName\": \"Admin\",\n  \"FirstName\": \"System\",\n  \"Email\": \"admin@example.com\",\n  \"ProfileName\": \"System Administrator\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n### Standard User with Role\n```json\n{\n  \"Username\": \"sales.rep@example.com\",\n  \"LastName\": \"Rep\",\n  \"FirstName\": \"Sales\",\n  \"Email\": \"sales.rep@example.com\",\n  \"ProfileName\": \"Standard User\",\n  \"UserRole\": \"Sales Representative\",\n  \"Title\": \"Sales Representative\",\n  \"Department\": \"Sales\",\n  \"Division\": \"North America\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n### Customer Community User\n```json\n{\n  \"Username\": \"customer@example.com\",\n  \"LastName\": \"Customer\",\n  \"FirstName\": \"Community\",\n  \"Email\": \"customer@example.com\",\n  \"ProfileName\": \"Customer Community User\",\n  \"CompanyName\": \"Customer Company\",\n  \"TimeZoneSidKey\": \"America/Los_Angeles\",\n  \"LocaleSidKey\": \"en_US\",\n  \"EmailEncodingKey\": \"UTF-8\",\n  \"LanguageLocaleKey\": \"en_US\"\n}\n```\n\n## Using Definition Files with the CLI\nTo create a user with a definition file:\n\n```bash\nsf org create user -o MyScratchOrg -f config/users/admin-user.json\n```\n\nTo create a user and generate a password:\n\n```bash\nsf org create user -o MyScratchOrg -f config/users/standard-user.json -g\n```\n\n## Creating Multiple Users with Different Files\nYou can create multiple users in a script:\n\n```bash\n#!/bin/bash\nsf org create user -o MyScratchOrg -f config/users/admin-user.json -g\nsf org create user -o MyScratchOrg -f config/users/sales-manager.json -g\nsf org create user -o MyScratchOrg -f config/users/sales-rep1.json -g\nsf org create user -o MyScratchOrg -f config/users/sales-rep2.json -g\n```\n\n## Customizing the Default Admin User\nYou can customize the admin user during Scratch Org creation by specifying `adminEmail` in the Scratch Org definition file:\n\n```json\n{\n  \"orgName\": \"My Company\",\n  \"edition\": \"Developer\",\n  \"adminEmail\": \"admin@mycompany.com\",\n  \"features\": []\n}\n```\n\n## Best Practices\n1. Store user definition files in a version-controlled directory\n2. Use descriptive filenames that indicate the user type\n3. Create templates for common user types\n4. Include only the necessary fields to avoid clutter\n5. Document the purpose of each user definition file\n6. Standardize formats for usernames and emails\n7. Group related users in subdirectories\n\n## Further Reading\n[Salesforce DX Developer Guide: User Definition Files](mdc:https:/developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs_users_def_files.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/scratch_orgs/user_definition_file_for_customizing_scratch_org_user.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/best_practices.md",
      "content": "---\ndescription: Best practices for effective source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Best practices for effective source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Best Practices for Source Tracking\n\n## Overview\nSource tracking is a powerful feature in Salesforce DX, but it requires proper techniques to use effectively. This rule compiles best practices for working with source tracking in your Salesforce DX projects.\n\n## Key Concepts\n- Source tracking requires disciplined development processes\n- Optimizing source tracking improves development efficiency\n- Best practices help prevent common source tracking issues\n- Different project types may require different source tracking approaches\n\n## Detailed Sections\n### Development Workflow Optimization\nLearn how to structure your development workflow to maximize source tracking benefits.\n\n### Team Collaboration with Source Tracking\nUnderstand techniques for effective team collaboration using source tracking.\n\n### Performance Considerations\nOptimize source tracking for better performance, especially in large projects.\n\n### Troubleshooting Common Issues\nSolutions for common source tracking problems.\n\n## Code Examples\n```bash\n# Clear source tracking after major changes\nsf org reset source-tracking -o your-org-alias\n\n# Create reliable tracking state for deployment\nsf project deploy start -o your-org-alias --ignore-conflicts\n\n# Track deployment history\nsf project deploy report --verbose\n```\n\n## Best Practices\n1. Keep local project and org in sync frequently\n2. Use a consistent branching strategy with source tracking\n3. Reset source tracking when switching between major feature branches\n4. Document source tracking reset points in your project\n5. Combine source tracking with proper version control\n6. Consider using continuous integration to automate deployments\n7. Train team members on source tracking concepts and commands\n8. Create backup copies before making large-scale changes\n\n## Further Reading\nRefer to the official Salesforce DX documentation for additional best practices and advanced techniques for source tracking.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/best_practices.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/deploy_retrieve_changes.md",
      "content": "---\ndescription: How to deploy and retrieve changes identified by source tracking\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to deploy and retrieve changes identified by source tracking\nglobs: \nalwaysApply: false\n---\n# Deploy and Retrieve Changes Identified by Source Tracking\n\n## Overview\nAfter identifying changes through source tracking, you need to know how to deploy local changes to your org and retrieve remote changes to your local project. This rule covers the processes for deploying and retrieving source-tracked changes.\n\n## Key Concepts\n- Source-tracked deployments only deploy what has changed\n- Source-tracked retrievals only retrieve what has changed\n- Changes can be deployed/retrieved selectively or all at once\n- Deployment and retrieval operations update source tracking data\n\n## Detailed Sections\n### Deploying Source-Tracked Changes\nLearn how to push your local changes to a Salesforce org.\n\n### Retrieving Source-Tracked Changes\nDiscover how to pull org changes to your local project.\n\n### Selective Deployment and Retrieval\nUnderstand how to deploy or retrieve specific components rather than all tracked changes.\n\n### Validating Deployments\nTest your deployments before committing them to production.\n\n## Code Examples\n```bash\n# Deploy source-tracked changes to org\nsf project deploy start -o your-org-alias\n\n# Retrieve source-tracked changes from org\nsf project retrieve start -o your-org-alias\n\n# Deploy specific components\nsf project deploy start -o your-org-alias -m ApexClass:MyClass,CustomObject:Account\n\n# Validate deployment without actually deploying\nsf project deploy validate -o your-org-alias\n```\n\n## Best Practices\n1. Always preview changes before deploying or retrieving\n2. Use validation deployments in critical environments\n3. Deploy and retrieve frequently to minimize conflicts\n4. Be selective with deployments when working on large orgs\n5. Keep track of your deployment history for auditing purposes\n\n## Further Reading\nSee the official Salesforce DX documentation for detailed information on deploying and retrieving tracked changes.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/deploy_retrieve_changes.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/manage_source_tracking.md",
      "content": "---\ndescription: How to manage source tracking for your Salesforce org\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to manage source tracking for your Salesforce org\nglobs: \nalwaysApply: false\n---\n# Manage Source Tracking for Your Org\n\n## Overview\nSource tracking is a critical feature in Salesforce DX that helps you track changes between your local project and your org. This rule explains how to effectively manage source tracking for your Salesforce orgs.\n\n## Key Concepts\n- Source tracking records metadata changes in your org\n- Tracking is maintained separately for each org you authorize\n- Source tracking data is stored locally on your computer\n- Changes can be tracked in both scratch orgs and non-scratch orgs\n\n## Detailed Sections\n### Enabling Source Tracking\nSource tracking is automatically enabled for scratch orgs. For non-scratch orgs, you must enable tracking with the appropriate command.\n\n### Viewing Source Tracking Status\nCheck the current status of source tracking for your connected orgs.\n\n### Clearing Source Tracking\nLearn when and how to clear source tracking data.\n\n## Code Examples\n```bash\n# Check source tracking status for an org\nsf org list source-tracking\n\n# Enable source tracking for a non-scratch org\nsf org enable source-tracking -o your-org-alias\n\n# Clear source tracking data\nsf org reset source-tracking -o your-org-alias\n```\n\n## Best Practices\n1. Regularly check source tracking status to ensure it's functioning properly\n2. Clear source tracking when you encounter sync issues\n3. Be aware of source tracking limitations for certain metadata types\n4. Use source tracking in conjunction with version control systems\n\n## Further Reading\nSee the official Salesforce DX documentation for more details on source tracking.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/manage_source_tracking.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/performance_considerations.md",
      "content": "---\ndescription: Understanding performance considerations for source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: Understanding performance considerations for source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Performance Considerations of Source Tracking\n\n## Overview\nSource tracking is a powerful tool in Salesforce DX, but it can impact performance, especially in large projects. This rule provides guidance on optimizing source tracking performance.\n\n## Key Concepts\n- Source tracking performance impacts development speed\n- Large projects face unique source tracking challenges\n- Optimizing source tracking requires understanding its resource usage\n- Different performance optimization strategies apply to different scenarios\n\n## Detailed Sections\n### Resource Requirements\nUnderstand the system resources used by source tracking.\n\n### Scaling with Project Size\nLearn how source tracking performance scales with project size and complexity.\n\n### Optimizing Source Tracking Operations\nTechniques to make source tracking operations faster and more efficient.\n\n### Balancing Coverage vs. Performance\nStrategies for finding the right balance between tracking everything and maintaining performance.\n\n## Code Examples\n```bash\n# Retrieve only specific components to improve performance\nsf project retrieve start -o your-org-alias -m ApexClass,CustomObject\n\n# Disable source tracking for larger orgs when not needed\nsf org disable source-tracking -o your-large-org-alias\n\n# Use manifest files for better performance with large deployments\nsf project deploy start -o your-org-alias -x path/to/package.xml\n```\n\n## Best Practices\n1. Limit the scope of source tracking to essential components\n2. Consider disabling source tracking for very large orgs\n3. Use selective retrieval and deployment to improve performance\n4. Schedule large operations during off-hours\n5. Optimize your local system's resources for better performance\n6. Clear source tracking data regularly to prevent bloat\n7. Monitor source tracking performance to identify bottlenecks\n8. Consider using package.xml manifests for extremely large operations\n\n## Further Reading\nSee the official Salesforce DX documentation for detailed information on performance optimization for source tracking.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/performance_considerations.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/preview_changes.md",
      "content": "---\ndescription: How to preview changes identified by source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to preview changes identified by source tracking in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Preview Changes Identified by Source Tracking\n\n## Overview\nSource tracking in Salesforce DX identifies changes between your local project and your org. This rule explains how to preview these changes before deploying or retrieving them.\n\n## Key Concepts\n- Source tracking identifies changes in both directions (local to org and org to local)\n- Changes can be previewed without committing to deployment or retrieval\n- Previewing helps validate what will be deployed or retrieved\n- Source tracking compares local metadata to the org's metadata\n\n## Detailed Sections\n### Preview Local Changes\nLearn how to see which local changes would be deployed to your org.\n\n### Preview Remote Changes\nDiscover how to see which changes in your org would be retrieved to your local project.\n\n### Understanding the Preview Output\nInterpret the source tracking preview results to make informed decisions.\n\n## Code Examples\n```bash\n# Preview local changes that would be deployed to the org\nsf project deploy preview -o your-org-alias\n\n# Preview changes in the org that would be retrieved locally\nsf project retrieve preview -o your-org-alias\n\n# Preview changes with detailed output\nsf project deploy preview -o your-org-alias --verbose\n```\n\n## Best Practices\n1. Always preview changes before deploying or retrieving\n2. Review the preview output carefully to avoid unintended changes\n3. Use preview in combination with source diff tools for detailed comparison\n4. Preview changes after each significant development phase\n\n## Further Reading\nRefer to the official Salesforce DX documentation for more information on previewing source tracked changes.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/preview_changes.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/resolve_conflicts.md",
      "content": "---\ndescription: How to resolve conflicts between your local project and Salesforce org\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to resolve conflicts between your local project and Salesforce org\nglobs: \nalwaysApply: false\n---\n# Resolve Conflicts Between Your Local Project and Org\n\n## Overview\nWhen changes occur both locally and in your Salesforce org, conflicts can arise during deployment or retrieval. This rule explains how to identify and resolve these conflicts effectively.\n\n## Key Concepts\n- Conflicts occur when the same component is modified in both locations\n- Conflict resolution requires deciding which version to keep\n- Different conflict resolution strategies apply to different scenarios\n- Source tracking helps identify potential conflicts\n\n## Detailed Sections\n### Identifying Conflicts\nLearn how to detect when local and remote changes conflict with each other.\n\n### Types of Conflicts\nUnderstand the different types of conflicts that can occur and their implications.\n\n### Resolving Local vs. Remote Conflicts\nStrategies for deciding whether to keep local changes or remote changes.\n\n### Merge Strategies\nTechniques for merging changes when both versions contain valuable modifications.\n\n## Code Examples\n```bash\n# Check for potential conflicts before deployment\nsf project deploy preview -o your-org-alias\n\n# Force local changes to overwrite remote changes\nsf project deploy start -o your-org-alias --force-overwrite\n\n# Force retrieval of remote changes to overwrite local\nsf project retrieve start -o your-org-alias --force-overwrite\n```\n\n## Best Practices\n1. Always preview changes before deploying or retrieving to identify conflicts\n2. Use a diff tool to compare local and remote versions\n3. Communicate with team members when resolving conflicts in shared components\n4. Consider creating backups before resolving complex conflicts\n5. Use source control systems to help manage conflicts\n6. Document your conflict resolution decisions for future reference\n\n## Further Reading\nSee the official Salesforce DX documentation for more details on conflict resolution strategies.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/resolve_conflicts.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/track_changes/retrieve_profile_changes.md",
      "content": "---\ndescription: How to retrieve changes to profiles with source tracking\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to retrieve changes to profiles with source tracking\nglobs: \nalwaysApply: false\n---\n# Retrieve Changes to Profiles with Source Tracking\n\n## Overview\nProfiles are complex metadata types in Salesforce that require special handling when using source tracking. This rule explains how to effectively retrieve profile changes using source tracking.\n\n## Key Concepts\n- Profiles contain permissions for various metadata types\n- Profile changes can be triggered by changes to other metadata\n- Profiles can be retrieved as a whole or in parts\n- Special considerations exist for profile retrieval with source tracking\n\n## Detailed Sections\n### Understanding Profile Structure\nLearn about how profiles are structured in the Salesforce DX format.\n\n### Profile Change Detection\nUnderstand how source tracking identifies changes to profiles.\n\n### Retrieving Complete Profiles\nHow to retrieve entire profiles when changes are detected.\n\n### Retrieving Partial Profile Changes\nTechniques for retrieving only specific parts of profiles that have changed.\n\n## Code Examples\n```bash\n# Retrieve only profile changes\nsf project retrieve start -o your-org-alias -m Profile\n\n# Retrieve specific profiles\nsf project retrieve start -o your-org-alias -m \"Profile:Admin,Profile:Standard\"\n\n# Retrieve profiles with verbose output\nsf project retrieve start -o your-org-alias -m Profile --verbose\n```\n\n## Best Practices\n1. Consider retrieving complete profiles rather than partial changes\n2. Be careful when merging profile changes to avoid permission regressions\n3. Always review profile changes before committing them to version control\n4. Use permission sets where possible to minimize profile changes\n5. Test profile changes thoroughly before deploying to production\n\n## Further Reading\nRefer to the official Salesforce DX documentation for more details about working with profiles and source tracking.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/track_changes/retrieve_profile_changes.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/troubleshoot/cli_version_information.md",
      "content": "---\ndescription: How to retrieve and use CLI version information for troubleshooting Salesforce DX issues\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to retrieve and use CLI version information for troubleshooting Salesforce DX issues\nglobs: \nalwaysApply: false\n---\n# CLI Version Information\n\n## Overview\nThis rule provides guidance on how to retrieve and use Salesforce CLI version information for troubleshooting and resolving compatibility issues.\n\n## Key Concepts\n- CLI version checking\n- Plugin management\n- Version compatibility\n- CLI updating\n\n## Checking Version Information\n\n### Basic Version Check\nThe most basic way to check your Salesforce CLI version:\n\n```bash\nsf version\n```\n\nThis shows you the main CLI version but doesn't provide detailed information about plugins.\n\n### Detailed Version Information\nFor more comprehensive information about your CLI installation:\n\n```bash\nsf plugins --core\n```\n\nThis command lists all installed core plugins and their versions.\n\n### Plugin-Specific Information\nTo see information about specific plugins:\n\n```bash\nsf plugins\n```\n\nThis shows all installed plugins, including custom ones.\n\n## Troubleshooting with Version Information\n\n### Identifying Outdated Components\n\nIf you're experiencing issues, check if any components are outdated:\n\n```bash\nsf update\n```\n\nThis will show if there are any available updates for the CLI or plugins.\n\n### Version Mismatch Issues\nCommon problems tied to version issues:\n\n1. **Command Not Found**: A command might not be available in your version\n2. **Unexpected Behavior**: Commands might work differently between versions\n3. **Deprecation Warnings**: Older commands might show deprecation warnings\n\n### Resolving Version-Related Issues\n\n#### Update the CLI\nTo update the Salesforce CLI:\n\n```bash\nsf update\n```\n\n#### Reinstall the CLI\nIf updating doesn't resolve the issue:\n\n```bash\n# For npm installation\nnpm uninstall -g @salesforce/cli\nnpm install -g @salesforce/cli\n\n# For other installation methods, reinstall via the installer\n```\n\n#### Check for Deprecated Commands\nReference the [Salesforce CLI Command Reference](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/) to see if commands have been deprecated or changed.\n\n## Using Version Information for Support\nWhen seeking help:\n\n1. Always include your CLI version information\n2. Specify which commands are causing issues\n3. Include any error messages exactly as shown\n4. Mention recent updates or changes to your environment\n\nExample support information:\n```\nCLI Version: @salesforce/cli 2.x.x\nNode Version: v16.x.x\nOS: Windows/macOS/Linux\nCommand run: sf org create scratch\nError message: <exact error message>\n```\n\n## Best Practices\n1. Regularly update the CLI using `sf update`\n2. Check release notes for breaking changes before updating\n3. Keep all plugins updated\n4. For critical environments, test CLI updates in a non-production environment first\n5. Document your CLI version in project documentation for team consistency\n\n## Further Reading\n- [Salesforce CLI Installation Guide](https://developer.salesforce.com/docs/atlas.en-us.sfdx_setup.meta/sfdx_setup/sfdx_setup_install_cli.htm)\n- [Salesforce CLI Release Notes](https://github.com/forcedotcom/cli/blob/main/releasenotes/README.md)\n- [Salesforce DX Troubleshooting](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_troubleshooting.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/troubleshoot/cli_version_information.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/troubleshoot/consumer_key_already_taken.md",
      "content": "---\ndescription: How to resolve \"Error: The consumer key is already taken\" when setting up connected apps in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to resolve \"Error: The consumer key is already taken\" when setting up connected apps in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Error: The Consumer Key is Already Taken\n\n## Overview\nThis rule provides troubleshooting steps for resolving the \"The consumer key is already taken\" error that occurs when creating or configuring connected apps for Salesforce DX.\n\n## Key Concepts\n- Connected App configuration\n- Consumer key uniqueness\n- OAuth application setup\n- JWT-based authentication\n\n## Error Details\nThe \"The consumer key is already taken\" error occurs when:\n1. You're trying to create a connected app with a consumer key that's already in use\n2. You're attempting to edit an existing connected app and change its consumer key to one that's already used by another app\n3. There's a conflict between deleted and active connected apps in your org\n\n## Resolution Steps\n\n### 1. Check Existing Connected Apps\nFirst, review all connected apps in your org:\n\n1. Log in to your Salesforce org\n2. Navigate to Setup > App Manager\n3. Click on \"Connected Apps\" in the filter dropdown\n4. Review all connected apps, including ones you may have forgotten about\n\n### 2. Generate a New Consumer Key\nInstead of manually entering a consumer key, let Salesforce generate a unique one:\n\n1. When creating a new connected app, leave the consumer key field blank\n2. Salesforce will auto-generate a unique consumer key\n3. Save the connected app with the generated key\n\n### 3. Check Recently Deleted Connected Apps\nThe issue might be with a recently deleted connected app whose consumer key is still reserved:\n\n1. Navigate to Setup > Connected Apps > Manage Connected Apps\n2. Check the \"Recently Deleted\" list (if available)\n3. Wait for the deletion to fully process (can take up to 24 hours)\n\n### 4. Create a Connected App with a Different Name\nIf you need a connected app immediately:\n\n1. Create a new connected app with a different name\n2. Let Salesforce generate the consumer key\n3. Configure all other settings as needed\n4. Use this new connected app for your integration\n\n### 5. Contact Salesforce Support\nIf the problem persists:\n\n1. Note the exact consumer key that's causing the issue\n2. Contact Salesforce Support and provide details about the error\n3. They can help identify which app is using the key or clean up backend conflicts\n\n## Best Practices\n1. Always let Salesforce generate consumer keys automatically\n2. Document your connected apps and their purposes\n3. Deactivate unused connected apps rather than deleting them\n4. Use unique, descriptive names for connected apps to avoid confusion\n5. When setting up JWT-based auth, use the org-specific connected app rather than sharing across orgs\n\n## Further Reading\n- [Salesforce Connected Apps Overview](https://help.salesforce.com/articleView?id=connected_app_overview.htm)\n- [JWT-Based Flow for Server-to-Server Integration](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_jwt_flow.htm)\n- [Creating a Connected App in Salesforce](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth_connected_app.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/troubleshoot/consumer_key_already_taken.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/troubleshoot/failed_org_authorization.md",
      "content": "---\ndescription: How to resolve issues when unable to work after a failed org authorization\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to resolve issues when unable to work after a failed org authorization\nglobs: \nalwaysApply: false\n---\n# Unable to Work After Failed Org Authorization\n\n## Overview\nThis rule provides troubleshooting steps for resolving issues that occur after a failed org authorization attempt in Salesforce DX.\n\n## Key Concepts\n- Authorization troubleshooting\n- Auth file management\n- Salesforce CLI configuration\n- Session recovery\n\n## Common Scenarios\n\n### Authentication File Corruption\nFailed authorization attempts can sometimes leave behind corrupt authentication files that prevent future login attempts.\n\n### Network Issues During Authorization\nIf network connectivity was interrupted during the authorization flow, it may lead to incomplete authentication.\n\n### Session Token Issues\nAuthorization problems can result in invalid session tokens being stored in your local environment.\n\n## Resolution Steps\n\n### 1. Clear Existing Authorization Files\nRemove the problematic authorization files:\n\n```bash\nsf org logout -o username@example.com\n```\n\nIf that doesn't work, you can manually delete the auth files:\n\n```bash\n# Find the location of auth files\nsf config get rootdir\n```\n\nNavigate to that directory and delete the relevant org's auth file in the `.sfdx/orgs/` folder.\n\n### 2. Check for Running Processes\nEnsure there are no Salesforce CLI processes running that might be locking auth files:\n\n```bash\n# For macOS/Linux\nps -ef | grep sfdx\n\n# For Windows\ntasklist | findstr sf.exe\n```\n\nTerminate any running processes if needed.\n\n### 3. Reset Salesforce CLI Config\nIf you're still having issues, you might need to reset the CLI configuration:\n\n```bash\nsf config reset\n```\n\nThis will reset your config to default values. Note that this will remove all your configuration settings, including default orgs.\n\n### 4. Clean Browser Cookies and Cache\nFor web-based authentication issues:\n1. Clear your browser cookies and cache\n2. Try using incognito/private browsing mode\n3. Try a different browser\n\n### 5. Re-Authorize the Org\nAfter cleaning up, try to authorize again:\n\n```bash\nsf org login web -a OrgAlias\n```\n\n### 6. Check Network Configuration\nEnsure your network allows connections to Salesforce domains:\n- login.salesforce.com\n- test.salesforce.com\n- *.my.salesforce.com\n\n### 7. Verify System Time\nIncorrect system time can cause authentication issues. Ensure your computer's time is synchronized correctly.\n\n## Best Practices\n1. Always use unique aliases for your orgs\n2. Keep track of authorized orgs with `sf org list`\n3. For persistent issues, try the JWT-based authentication method instead of web-based\n4. Regularly clean up unused org authorizations\n\n## Further Reading\n- [Salesforce CLI Auth Commands](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_auth.htm)\n- [Salesforce DX Authentication Troubleshooting](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_troubleshooting.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/troubleshoot/failed_org_authorization.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/troubleshoot/general_troubleshooting.md",
      "content": "---\ndescription:  General troubleshooting approaches and techniques for Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: General troubleshooting approaches and techniques for Salesforce DX\nglobs: \nalwaysApply: false\n---\n# General Salesforce DX Troubleshooting\n\n## Overview\nThis rule provides a comprehensive troubleshooting approach for resolving common issues encountered when working with Salesforce DX.\n\n## Key Concepts\n- Methodical troubleshooting approach\n- Common error patterns\n- Diagnostic commands\n- Environment verification\n\n## General Troubleshooting Process\n\n### 1. Identify the Exact Error\nBefore attempting to fix an issue:\n- Note the exact error message and code\n- Identify which command triggered the error\n- Note any recent changes to your environment or project\n\n### 2. Check CLI and System Status\n\n```bash\n# Check CLI version\nsf version\n\n# Check CLI plugins\nsf plugins\n\n# Check Node.js version\nnode -v\n\n# Check system resources\n# (Memory, disk space, etc.)\n```\n\n### 3. Verify Connectivity\n\n```bash\n# Test connectivity to Salesforce\nsf org list\n\n# Check if you can ping Salesforce domains\nping login.salesforce.com\n```\n\n### 4. Review Project Configuration\n\n```bash\n# Check project configuration\ncat sfdx-project.json\n\n# Verify org configuration\nsf org display -o YourOrgAlias\n```\n\n### 5. Common Error Categories and Solutions\n\n#### Authentication Errors\n- Verify authorization status: `sf org list`\n- Re-authenticate if needed: `sf org login web -a YourAlias`\n- Check connected app settings in Salesforce\n\n#### Deployment Errors\n- Validate your metadata: `sf project deploy validate`\n- Check API version compatibility\n- Deploy with more information: `sf project deploy start --verbose`\n\n#### Scratch Org Errors\n- Verify Dev Hub connection: `sf org display -o DevHub`\n- Check scratch org limits: `sf limits display --available`\n- Ensure org definition file is valid\n\n#### Permission Errors\n- Verify user permissions in target org\n- Check file permissions on your local machine\n- Ensure you have the correct license types\n\n#### Configuration Errors\n- Validate sfdx-project.json syntax\n- Check for correct package directories\n- Verify namespace configuration\n\n## Advanced Diagnostics\n\n### Enable Debug Logging\nFor detailed debugging information:\n\n```bash\n# Enable debug mode for a single command\nsf org list --loglevel debug\n\n# Set persistent debug logging\nsf config set logLevel=debug\n```\n\n### Check Log Files\nSalesforce CLI logs are stored in:\n- macOS/Linux: `~/.sfdx/sf/sf.log`\n- Windows: `%USERPROFILE%\\.sfdx\\sf\\sf.log`\n\n### Run Clean-Up Utilities\n\n```bash\n# Clean CLI cache\nsf plugins uninstall @salesforce/plugin-cache\nsf plugins install @salesforce/plugin-cache\nsf cache clean\n\n# Reset configuration (use with caution)\nsf config reset\n```\n\n## Common Resolution Strategies\n\n### The Restart Approach\n1. Close all terminal/command prompt windows\n2. Restart your computer\n3. Try the operation again with a fresh session\n\n### The Clean Reinstall\n1. Uninstall Salesforce CLI: `npm uninstall -g @salesforce/cli`\n2. Clear npm cache: `npm cache clean --force`\n3. Reinstall CLI: `npm install -g @salesforce/cli`\n\n### The Environment Isolation\n1. Create a new project directory\n2. Initialize a fresh SFDX project: `sf project generate`\n3. Try to reproduce the issue in the clean environment\n\n## Best Practices\n1. Keep detailed notes of errors and solutions\n2. Update CLI and plugins regularly\n3. Follow Salesforce release notes for known issues\n4. Maintain clean project structure and source organization\n5. Use version control for tracking changes\n\n## Further Reading\n- [Salesforce CLI Troubleshooting](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_troubleshooting.htm)\n- [Salesforce Developer Forums](https://developer.salesforce.com/forums)\n- [Salesforce CLI GitHub Issues](https://github.com/forcedotcom/cli/issues)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/troubleshoot/general_troubleshooting.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/troubleshoot/no_default_dev_hub.md",
      "content": "---\ndescription: How to resolve the \"No default dev hub found\" error in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to resolve the \"No default dev hub found\" error in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Error: No Default Dev Hub Found\n\n## Overview\nThis rule provides guidance for resolving the \"Error: No default dev hub found\" error that occurs when trying to create scratch orgs or work with packages in Salesforce DX.\n\n## Key Concepts\n- Dev Hub authorization and configuration\n- Default Dev Hub settings\n- Scratch org creation prerequisites\n\n## Error Details\nThe \"No default dev hub found\" error occurs when:\n1. You have not authorized a Dev Hub org\n2. You have authorized a Dev Hub org but haven't set it as the default\n3. Your Dev Hub authorization has expired\n\n## Resolution Steps\n\n### 1. Check Authorized Orgs\nFirst, check if you have any authorized orgs:\n\n```bash\nsf org list\n```\n\nLook for an org with Dev Hub enabled. If you don't see any, you need to authorize a Dev Hub org.\n\n### 2. Authorize a Dev Hub Org\nIf you haven't authorized a Dev Hub org yet:\n\n```bash\nsf org login web --set-default-dev-hub --alias DevHub\n```\n\nThe `--set-default-dev-hub` flag automatically sets this org as your default Dev Hub.\n\n### 3. Set an Existing Org as Default Dev Hub\nIf you've already authorized a Dev Hub org but it's not set as default:\n\n```bash\nsf config set target-dev-hub=your-dev-hub-username@example.com\n```\n\nAlternatively, you can use the org's alias:\n\n```bash\nsf config set target-dev-hub=DevHubAlias\n```\n\n### 4. Verify Default Dev Hub Setting\nConfirm your default Dev Hub is properly set:\n\n```bash\nsf config get target-dev-hub\n```\n\n### 5. Re-Authorize if Expired\nIf your Dev Hub authorization has expired, reauthorize it:\n\n```bash\nsf org logout -o your-dev-hub-username@example.com\nsf org login web --set-default-dev-hub --alias DevHub -o your-dev-hub-username@example.com\n```\n\n## Best Practices\n1. Always set a default Dev Hub when working with scratch orgs or packages\n2. Use meaningful aliases for your Dev Hub orgs\n3. If working on multiple projects, configure the default Dev Hub in each project's configuration file\n4. For team environments, document the Dev Hub settings to ensure consistency\n\n## Further Reading\n- [Salesforce DX Developer Guide: Set Up the Dev Hub](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_hub_intro.htm)\n- [Salesforce CLI Config Commands](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_config.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/troubleshoot/no_default_dev_hub.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/troubleshoot/resolve_authorization_errors.md",
      "content": "---\ndescription: How to resolve common authorization errors when working with Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to resolve common authorization errors when working with Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Resolve Common Authorization Errors\n\n## Overview\nThis guide helps you troubleshoot and resolve common authorization errors encountered when working with Salesforce DX and Salesforce CLI.\n\n## Key Concepts\n- Web-based authentication errors\n- JWT-based authentication errors\n- Common error messages and their resolutions\n- Troubleshooting strategies\n\n## Common Auth Errors and Solutions\n\n### Org Login Web Errors\nWeb-based authentication can fail for several reasons:\n\n1. **Authentication Server Error**\n   - Error: \"Authentication server returned 'server error'\"\n   - Resolution: Try the authentication again or use a different browser\n\n2. **Invalid Client ID**\n   - Error: \"error=invalid_client_id\"\n   - Resolution: Verify the connected app's consumer key is correct\n\n3. **Redirect URI Mismatch**\n   - Error: \"error=redirect_uri_mismatch\"\n   - Resolution: Ensure the callback URL in your connected app configuration matches the one used by CLI\n\n4. **Browser Issues**\n   - Resolution: Clear browser cache or try a different browser\n\n### Org Login JWT Errors\nJWT-based authentication issues:\n\n1. **Invalid Private Key or Certificate**\n   - Error: \"Failed: The JWT assertion is invalid\"\n   - Resolution: Verify the private key and certificate are valid and correctly formatted\n\n2. **Username/Connected App Mismatch**\n   - Error: \"Failed: Is your connected app configured to allow this user access?\"\n   - Resolution: Ensure the user has access to the connected app\n\n3. **Expired Certificate**\n   - Resolution: Generate a new certificate and update your connected app\n\n## Troubleshooting Steps\n\n1. **Verify authorization information**\n   ```bash\n   sf org display auth\n   ```\n\n2. **Log out and reauthorize**\n   ```bash\n   sf org logout -o username@example.com\n   sf org login web -a MyOrg\n   ```\n\n3. **Check connected app settings** in your Salesforce org\n\n4. **Regenerate certificates** if using JWT-based auth and experiencing issues\n   ```bash\n   sf org display auth -o username@example.com --verbose\n   ```\n\n## Best Practices\n1. Use unique alias names for each org to avoid confusion\n2. Regularly verify your authorizations using `sf org list`\n3. For automated processes, use JWT-based auth instead of web-based auth\n4. Keep private keys secure and rotate certificates periodically\n\n## Further Reading\n- [Salesforce CLI Authentication Commands](https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_auth.htm)\n- [Salesforce DX Developer Guide: Authorization](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_auth.htm)",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/troubleshoot/resolve_authorization_errors.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/work_with_data/run_soql_sosl_queries.md",
      "content": "---\ndescription: How to run SOQL or SOSL queries in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to run SOQL or SOSL queries in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Run SOQL or SOSL Queries\n\n## Overview\nThis rule covers the commands and techniques for executing SOQL (Salesforce Object Query Language) and SOSL (Salesforce Object Search Language) queries using Salesforce DX, allowing developers to efficiently retrieve and analyze data during development.\n\n## Key Concepts\n- SOQL for relational data queries\n- SOSL for text-based searches\n- Query formatting and syntax\n- Output formatting options\n- Query optimization\n\n## Detailed Sections\n### Using data:soql Commands\nThe `data:soql` command allows you to execute SOQL queries against your org:\n\n```bash\nsf data:soql:query -q \"SELECT Id, Name, Industry FROM Account WHERE Industry = 'Technology' LIMIT 10\"\n```\n\n### Using data:sosl Commands\nThe `data:sosl` command allows you to perform text-based searches:\n\n```bash\nsf data:sosl:query -q \"FIND {Acme} IN ALL FIELDS RETURNING Account(Id, Name), Contact(Id, FirstName, LastName)\"\n```\n\n### Query Formatting\nFor complex queries, you can use a file:\n\n```bash\n# query.soql file content:\nSELECT Id, Name, \n  (SELECT FirstName, LastName FROM Contacts)\nFROM Account\nWHERE Industry = 'Technology'\nLIMIT 10\n\n# Command:\nsf data:soql:query -f ./query.soql\n```\n\n### Output Formatting\nControl the format of the query results:\n\n```bash\n# JSON format\nsf data:soql:query -q \"SELECT Id, Name FROM Account LIMIT 5\" --json\n\n# CSV format\nsf data:soql:query -q \"SELECT Id, Name FROM Account LIMIT 5\" --result-format csv\n```\n\n### Query Optimization\nTechniques for optimizing query performance:\n\n```bash\n# Use selective filters\nsf data:soql:query -q \"SELECT Id, Name FROM Account WHERE CreatedDate > LAST_MONTH\"\n\n# Limit the number of records\nsf data:soql:query -q \"SELECT Id, Name FROM Contact LIMIT 100\"\n\n# Use indexed fields\nsf data:soql:query -q \"SELECT Id, Name FROM Contact WHERE Email = 'test@example.com'\"\n```\n\n## Best Practices\n1. Use selective filters in WHERE clauses to improve performance\n2. Limit the number of records returned with LIMIT\n3. Use ORDER BY only when necessary\n4. Store complex queries in .soql files for reuse\n5. Use relationship queries to minimize API calls\n6. Be aware of governor limits when querying large datasets\n7. Use COUNT() for counting records instead of retrieving all records\n8. Use SOSL when searching across multiple objects for text matches\n\n## Further Reading\nFor more detailed information, refer to the official Salesforce DX documentation on SOQL and SOSL queries.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/work_with_data/run_soql_sosl_queries.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/work_with_data/upload_file_to_org.md",
      "content": "---\ndescription: How to upload a file to your Salesforce org using Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to upload a file to your Salesforce org using Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Upload a File to Your Org\n\n## Overview\nThis rule covers the techniques and commands for uploading files to your Salesforce org using Salesforce DX, including how to work with Salesforce Content, attachments, and document storage.\n\n## Key Concepts\n- File upload strategies in Salesforce DX\n- Content management in Salesforce\n- File attachment to records\n- Document uploading and management\n\n## Detailed Sections\n### Using the data:files Commands\nThe Salesforce CLI provides commands for working with files in your org:\n\n- `sf data:files:upload` - Upload a file to your org\n\n### Basic File Upload\nTo upload a file to your Salesforce org:\n\n```bash\nsf data:files:upload -f ./path/to/file.pdf -n \"Document Title\" -d \"Document description\"\n```\n\n### Associating Files with Records\nTo upload a file and associate it with a specific record:\n\n```bash\nsf data:files:upload -f ./path/to/file.pdf -n \"Customer Specification\" -p 001xx000003GYcZAAW\n```\n\n### Setting File Visibility\nControl the visibility of your uploaded file:\n\n```bash\n# Share with all users\nsf data:files:upload -f ./path/to/file.pdf -n \"Public Document\" --sharingprivate AllUsers\n\n# Keep private\nsf data:files:upload -f ./path/to/file.pdf -n \"Private Document\" --sharingprivate Privately\n```\n\n### Bulk File Upload\nTo upload multiple files, you can use a script:\n\n```bash\n#!/bin/bash\nfor file in ./documents/*.pdf; do\n  filename=$(basename \"$file\")\n  sf data:files:upload -f \"$file\" -n \"$filename\"\ndone\n```\n\n## Best Practices\n1. Use descriptive titles for uploaded files\n2. Add detailed descriptions for better searchability\n3. Organize files by associating them with relevant records\n4. Consider file visibility settings based on security requirements\n5. Use standard file formats (PDF, DOCX, XLSX) for maximum compatibility\n6. Be aware of file size limits for your org\n7. For large files, consider using chunked uploads or external storage options\n\n## Further Reading\nFor more detailed information, refer to the official Salesforce DX documentation on file management and the Salesforce Content API.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/work_with_data/upload_file_to_org.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/work_with_data/work_with_individual_records.md",
      "content": "---\ndescription: How to work with individual records in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to work with individual records in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Work With Individual Records\n\n## Overview\nThis rule covers commands and techniques for creating, retrieving, updating, and deleting individual records in Salesforce using Salesforce DX, providing a streamlined approach for working with single records during development.\n\n## Key Concepts\n- Single record CRUD operations\n- Data:record commands\n- Record creation and manipulation\n- Field value formatting and validation\n\n## Detailed Sections\n### Using data:record Commands\nThe `data:record` commands allow you to work with individual records directly:\n\n- `sf data:record:create` - Create a new record\n- `sf data:record:get` - Retrieve a record by ID\n- `sf data:record:update` - Update an existing record\n- `sf data:record:delete` - Delete a record by ID\n\n### Creating Records\nTo create a new record:\n\n```bash\nsf data:record:create -s Account -v \"Name='Acme Corp' Industry=Technology\"\n```\n\n### Retrieving Records\nTo get a record by ID:\n\n```bash\nsf data:record:get -s Account -i 001xx000003GYcZAAW\n```\n\n### Updating Records\nTo update an existing record:\n\n```bash\nsf data:record:update -s Account -i 001xx000003GYcZAAW -v \"Name='Acme Corporation' Website=www.acme.com\"\n```\n\n### Deleting Records\nTo delete a record:\n\n```bash\nsf data:record:delete -s Account -i 001xx000003GYcZAAW\n```\n\n### Working with Complex Field Values\nFor complex field values, use proper formatting:\n\n```bash\n# Date field\nsf data:record:create -s Contact -v \"FirstName=John LastName=Doe Birthdate=1990-01-15\"\n\n# Boolean field\nsf data:record:create -s Lead -v \"Company=Acme LastName=Smith DoNotCall=true\"\n\n# Reference field (lookup)\nsf data:record:create -s Contact -v \"LastName=Smith AccountId=001xx000003GYcZAAW\"\n```\n\n## Best Practices\n1. Use data:record commands for quick operations during development\n2. Verify record IDs before updating or deleting\n3. Use the --json flag to get machine-readable output\n4. Quote field values that contain spaces or special characters\n5. Use --target-org (-o) to specify which org to use when working with multiple orgs\n6. Escape special characters in field values as needed\n\n## Further Reading\nFor more detailed information, refer to the official Salesforce DX documentation on record operations.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/work_with_data/work_with_individual_records.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/work_with_data/work_with_large_datasets.md",
      "content": "---\ndescription: How to work with large datasets in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to work with large datasets in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Work With Large Datasets\n\n## Overview\nThis rule covers techniques and commands for efficiently working with large volumes of data in Salesforce DX, including bulk data operations, ETL processes, and performance optimization strategies.\n\n## Key Concepts\n- Bulk data operations in Salesforce DX\n- Data:bulk commands for large dataset manipulation\n- CSV file processing\n- Performance considerations for large data volumes\n\n## Detailed Sections\n### Using data:bulk Commands\nThe `data:bulk` commands are specifically designed for working with large datasets:\n\n- `sf data:bulk:delete` - Delete records in bulk\n- `sf data:bulk:upsert` - Insert or update records in bulk\n- `sf data:bulk:status` - Check the status of bulk data jobs\n\n### Preparing CSV Files\nFor bulk operations, data should be prepared in CSV format:\n\n```csv\nId,Name,Industry,AnnualRevenue\n,Acme Corporation,Manufacturing,10000000\n,Universal Containers,Technology,5000000\n,Robotics Inc,Technology,7500000\n```\n\n### Bulk Upsert Operations\nTo upsert records from a CSV file:\n\n```bash\nsf data:bulk:upsert -i Id -f ./data/accounts.csv -s Account -w 5\n```\n\n### Bulk Delete Operations\nTo delete records based on a CSV file containing IDs:\n\n```bash\nsf data:bulk:delete -f ./data/account_ids.csv -s Account -w 5\n```\n\n### Monitoring Bulk Jobs\nTo check the status of a bulk job:\n\n```bash\nsf data:bulk:status -i 750xx000000005sAAA\n```\n\n## Best Practices\n1. Use data:bulk commands for datasets with more than 200 records\n2. Split very large datasets into multiple files of 5,000-10,000 records each\n3. Include an external ID field for efficient upsert operations\n4. Monitor system performance during bulk operations\n5. Schedule bulk operations during off-peak hours\n6. Validate data quality before performing bulk operations\n7. Use the wait (-w) parameter to monitor job completion\n\n## Further Reading\nFor more detailed information, refer to the official Salesforce DX documentation on bulk data operations.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/work_with_data/work_with_large_datasets.mdc"
    },
    {
      "path": "registry/default/cursor-rules/sf_dx/work_with_data/work_with_small_datasets.md",
      "content": "---\ndescription: How to work with small datasets in Salesforce DX\nglobs: \nalwaysApply: false\n---\n ---\ndescription: How to work with small datasets in Salesforce DX\nglobs: \nalwaysApply: false\n---\n# Work With Small Datasets\n\n## Overview\nThis rule covers the techniques and commands for working with small datasets in Salesforce DX, including how to create, retrieve, update, and delete records efficiently when dealing with limited data volumes.\n\n## Key Concepts\n- Small dataset operations in Salesforce DX\n- Data:tree commands for working with sample data\n- Importing and exporting small datasets\n- Managing records through the Salesforce CLI\n\n## Detailed Sections\n### Using data:tree Commands\nThe `data:tree` commands help you work with small to medium sized datasets using JSON files:\n\n- `sf data:tree:export` - Export data from your org to JSON files\n- `sf data:tree:import` - Import data from JSON files into your org\n\n### Sample Data Format\nData is stored in a specific JSON format that preserves record relationships:\n\n```json\n{\n    \"records\": [\n        {\n            \"attributes\": {\n                \"type\": \"Account\",\n                \"referenceId\": \"AccountRef1\"\n            },\n            \"Name\": \"Sample Account\",\n            \"Industry\": \"Technology\",\n            \"Contacts\": {\n                \"records\": [\n                    {\n                        \"attributes\": {\n                            \"type\": \"Contact\",\n                            \"referenceId\": \"ContactRef1\"\n                        },\n                        \"FirstName\": \"John\",\n                        \"LastName\": \"Doe\",\n                        \"Email\": \"john.doe@example.com\"\n                    }\n                ]\n            }\n        }\n    ]\n}\n```\n\n### Exporting Data\nTo export data from your org to a JSON file:\n\n```bash\nsf data:tree:export -q \"SELECT Name, Industry, (SELECT FirstName, LastName, Email FROM Contacts) FROM Account LIMIT 10\" -d ./data\n```\n\n### Importing Data\nTo import data from a JSON file into your org:\n\n```bash\nsf data:tree:import -f ./data/Account.json -u your-org-alias\n```\n\n## Best Practices\n1. Use data:tree commands for datasets with less than 200 records\n2. Maintain data files in a dedicated directory in your project\n3. Include sample data files in your version control system for consistent development environments\n4. Use meaningful reference IDs to make relationships clear\n5. Export representative subsets of data for testing purposes\n\n## Further Reading\nFor more detailed information, refer to the official Salesforce DX documentation on working with data.",
      "type": "registry:file",
      "target": ".cursor/rules/sf_dx/work_with_data/work_with_small_datasets.mdc"
    }
  ]
}